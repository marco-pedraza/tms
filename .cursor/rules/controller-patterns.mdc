---
description: Patterns for controllers in Encore applications
globs: *.controller.ts
alwaysApply: false
---
# Controller Patterns

## Rules for Controllers

1. Controllers should ONLY:

   - Define API routes and endpoints
   - Handle request/response transformation
   - Manage error handling through the shared `parseApiError` utility
   - Call repository methods directly for CRUD operations

2. No business logic in controllers

3. Use HTTP status codes consistently through Encore's APIError:

   - 200: Success
   - 201: Created
   - 204: No Content
   - 400: Bad Request (ErrCode.InvalidArgument)
   - 404: Not Found (ErrCode.NotFound)
   - 409: Conflict (ErrCode.AlreadyExists)
   - 500: Internal Server Error (ErrCode.Internal)

4. All endpoints must use shared error handling

5. Use clear and consistent route naming:

   - GET /entities - List
   - GET /entities/:id - Get One
   - POST /entities - Create
   - PUT /entities/:id - Update
   - DELETE /entities/:id - Delete

6. Document all endpoints with clear descriptions

7. Use descriptive names for endpoint functions (e.g., `createEntity`, `getEntity`, etc.)

## Implementation Example

```typescript
import { api } from 'encore.dev';
import { APIError } from 'encore.dev/api';
import { parseApiError } from '../../shared/errors';
import { countryRepository } from './countries.repository';
import type {
  Country,
  Countries,
  CreateCountryPayload,
  UpdateCountryPayload,
} from './countries.types';

/**
 * Creates a new country.
 * @param params - The country data to create
 * @returns {Promise<Country>} The created country
 * @throws {APIError} If the country creation fails
 */
export const createCountry = api(
  { method: 'POST', path: '/countries' },
  async (params: CreateCountryPayload): Promise<Country> => {
    try {
      return await countryRepository.create(params);
    } catch (error) {
      const parsedError = parseApiError(error);
      throw parsedError;
    }
  }
);

/**
 * Retrieves a country by its ID.
 * @param params - Object containing the country ID
 * @param params.id - The ID of the country to retrieve
 * @returns {Promise<Country>} The found country
 * @throws {APIError} If the country is not found or retrieval fails
 */
export const getCountry = api(
  { method: 'GET', path: '/countries/:id' },
  async ({ id }: { id: number }): Promise<Country> => {
    try {
      return await countryRepository.findOne(id);
    } catch (error) {
      const parsedError = parseApiError(error);
      throw parsedError;
    }
  }
);

/**
 * Retrieves all countries.
 * @returns {Promise<Countries>} An object containing an array of countries
 * @throws {APIError} If the retrieval fails
 */
export const listCountries = api(
  { method: 'GET', path: '/countries' },
  async (): Promise<Countries> => {
    try {
      return await countryRepository.findAll();
    } catch (error) {
      const parsedError = parseApiError(error);
      throw parsedError;
    }
  }
);

/**
 * Updates an existing country.
 * @param params - Object containing the country ID and update data
 * @param params.id - The ID of the country to update
 * @param params.data - The country data to update
 * @returns {Promise<Country>} The updated country
 * @throws {APIError} If the country is not found or update fails
 */
export const updateCountry = api(
  { method: 'PUT', path: '/countries/:id' },
  async ({ id, ...data }: UpdateCountryPayload & { id: number }): Promise<Country> => {
    try {
      return await countryRepository.update(id, data);
    } catch (error) {
      const parsedError = parseApiError(error);
      throw parsedError;
    }
  }
);

/**
 * Deletes a country by its ID.
 * @param params - Object containing the country ID
 * @param params.id - The ID of the country to delete
 * @returns {Promise<Country>} The deleted country
 * @throws {APIError} If the country is not found or deletion fails
 */
export const deleteCountry = api(
  { method: 'DELETE', path: '/countries/:id' },
  async ({ id }: { id: number }): Promise<Country> => {
    try {
      return await countryRepository.delete(id);
    } catch (error) {
      const parsedError = parseApiError(error);
      throw parsedError;
    }
  }
);
```

## Best Practices

1. **Direct Repository Usage**

   - Call repository methods directly for CRUD operations
   - No need for intermediate handlers unless complex business logic is required
   - Use repository instances as singletons

2. **Error Handling**

   - Use the shared `parseApiError` utility consistently
   - Wrap all repository calls in try/catch blocks
   - Transform domain errors to appropriate API errors

3. **Request/Response**

   - Strong typing with payload types
   - Clear parameter documentation
   - Consistent response structures
   - Proper validation handling

4. **Code Structure**

   - Keep controllers thin
   - No business logic
   - Consistent naming for endpoints
   - Clear documentation
   - Homogeneous code structure

5. **When to Add a Handler**
   - Only add a handler when complex business logic is needed
   - Examples of when to use a handler:
     - Operations involving multiple repositories
     - Complex data transformations
     - Integration with external services
     - Complex business rules processing

## Testing

1. **Unit Tests**
   - Mock repository calls
   - Test error handling
   - Verify correct API error mapping
   - Test request/response transformation

```typescript
import { countryRepository } from './countries.repository';
import { createCountry } from './countries.controller';

jest.mock('./countries.repository');

describe('Country Controller', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('createCountry', () => {
    it('should create a country successfully', async () => {
      const mockCountry = { id: 1, name: 'Test', code: 'TST' };
      (countryRepository.create as jest.Mock).mockResolvedValue(mockCountry);

      const result = await createCountry({ name: 'Test', code: 'TST' });

      expect(result).toEqual(mockCountry);
      expect(countryRepository.create).toHaveBeenCalledWith({
        name: 'Test',
        code: 'TST',
      });
    });

    it('should handle validation errors', async () => {
      const errorMessage = 'Country with this code already exists';
      (countryRepository.create as jest.Mock).mockRejectedValue(new Error(errorMessage));

      await expect(createCountry({ name: 'Test', code: 'TST' })).rejects.toThrow();
    });
  });
});
```

## Common Patterns

1. **Route Organization**

   - Group related endpoints together
   - Use consistent route naming
   - Follow REST conventions

2. **Parameter Handling**

   - Validate required parameters
   - Use proper types for parameters
   - Document parameter constraints

3. **Response Formatting**

   - Consistent response structures
   - Proper error responses
   - Clear success messages

4. **Documentation**
   - Clear endpoint descriptions
   - Parameter documentation
   - Response type documentation
   - Error scenarios documentation
