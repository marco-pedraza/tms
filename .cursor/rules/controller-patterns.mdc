---
description: Patterns for controllers in Encore applications
globs: *.controller.ts
alwaysApply: false
---
# Controller Patterns

## Core Principles

1. Controllers should ONLY:

   - Define API routes and endpoints with Encore's `api` function
   - Handle request/response transformation
   - Delegate operations to repositories or use cases
   - Maintain clean separation from business logic

2. Use middleware for error handling (no try/catch needed in controllers)

3. Use HTTP methods and status codes consistently:

   - GET: Retrieve resources
   - POST: Create resources, perform operations and list entities with complex conditionals
   - PUT: Update resources
   - DELETE: Remove resources
   - PATCH: Partial updates (less common)

4. Expose endpoints with the `expose: true` option

5. Use clear and consistent route naming patterns:

   - GET /resources/:id - Get one resource by ID
   - GET /resources - List all resources (deprecated)
   - POST /get-resources - Get filtered resources
   - POST /get-resources/paginated - Get paginated resources
   - POST /resources - Create resource
   - PUT /resources/:id - Update resource
   - DELETE /resources/:id - Delete resource
   - GET /resources/search - Search resources
   - POST /resources/search/paginated - Search resources with pagination

6. Document all endpoints with JSDoc comments

## Implementation Example

```typescript
import { api } from 'encore.dev/api';
import { countryRepository } from './countries.repository';
import type {
  Country,
  Countries,
  CreateCountryPayload,
  UpdateCountryPayload,
  PaginatedCountries,
  PaginationParamsCountries,
  CountriesQueryOptions,
} from './countries.types';

/**
 * Creates a new country.
 * @param params - The country data to create
 * @returns {Promise<Country>} The created country
 * @throws {APIError} If the country creation fails
 */
export const createCountry = api(
  { expose: true, method: 'POST', path: '/countries' },
  async (params: CreateCountryPayload): Promise<Country> => {
    return await countryRepository.create(params);
  },
);

/**
 * Retrieves a country by its ID.
 * @param params - Object containing the country ID
 * @param params.id - The ID of the country to retrieve
 * @returns {Promise<Country>} The found country
 * @throws {APIError} If the country is not found or retrieval fails
 */
export const getCountry = api(
  { expose: true, method: 'GET', path: '/countries/:id' },
  async ({ id }: { id: number }): Promise<Country> => {
    return await countryRepository.findOne(id);
  },
);

/**
 * Retrieves all countries without pagination (useful for dropdowns).
 * @returns {Promise<Countries>} An object containing an array of countries
 * @throws {APIError} If retrieval fails
 */
export const listCountries = api(
  { expose: true, method: 'POST', path: '/get-countries' },
  async (params: CountriesQueryOptions): Promise<Countries> => {
    const countries = await countryRepository.findAll(params);
    return {
      countries,
    };
  },
);

/**
 * Retrieves countries with pagination (useful for tables).
 * @param params - Pagination parameters
 * @returns {Promise<PaginatedCountries>} Paginated list of countries
 * @throws {APIError} If retrieval fails
 */
export const listCountriesPaginated = api(
  { expose: true, method: 'POST', path: '/get-countries/paginated' },
  async (params: PaginationParamsCountries): Promise<PaginatedCountries> => {
    return await countryRepository.findAllPaginated(params);
  },
);

/**
 * Updates an existing country.
 * @param params - Object containing the country ID and update data
 * @param params.id - The ID of the country to update
 * @returns {Promise<Country>} The updated country
 * @throws {APIError} If the country is not found or update fails
 */
export const updateCountry = api(
  { expose: true, method: 'PUT', path: '/countries/:id' },
  async ({
    id,
    ...data
  }: UpdateCountryPayload & { id: number }): Promise<Country> => {
    return await countryRepository.update(id, data);
  },
);

/**
 * Searches for countries by matching a search term against name and code.
 * @param params - Search parameters
 * @param params.term - The search term to match against country name and code
 * @returns {Promise<Countries>} List of matching countries
 * @throws {APIError} If search fails or no searchable fields are configured
 */
export const searchCountries = api(
  { expose: true, method: 'GET', path: '/countries/search' },
  async ({ term }: { term: string }): Promise<Countries> => {
    const countries = await countryRepository.search(term);
    return {
      countries,
    };
  },
);

/**
 * Searches for countries with pagination by matching a search term against name and code.
 * @param params - Search and pagination parameters
 * @param params.term - The search term to match against country name and code
 * @param params.page - Page number for pagination (optional, default: 1)
 * @param params.pageSize - Number of items per page (optional, default: 10)
 * @param params.orderBy - Sorting criteria (optional)
 * @param params.filters - Additional filters to apply (optional)
 * @returns {Promise<PaginatedCountries>} Paginated list of matching countries
 * @throws {APIError} If search fails or no searchable fields are configured
 */
export const searchCountriesPaginated = api(
  { expose: true, method: 'POST', path: '/countries/search/paginated' },
  async ({
    term,
    ...params
  }: PaginationParamsCountries & {
    term: string;
  }): Promise<PaginatedCountries> => {
    return await countryRepository.searchPaginated(term, params);
  },
);
```

## Controller Best Practices

1. **Feature-First Organization**

   - Group all endpoints for a feature in a single controller file
   - Keep endpoints for the same resource together
   - Use descriptive function names matching operations

2. **Simplification**

   - Rely on middleware for error handling (no try/catch needed)
   - Delegate directly to repositories for CRUD operations
   - Call use cases for complex business operations
   - Keep controller functions short and focused

3. **Type Safety**

   - Import all types from feature's `.types.ts` file
   - Use proper type annotations for parameters and returns
   - Ensure consistent response structures

4. **Documentation**

   - Document all endpoints with JSDoc comments
   - Include descriptions of possible error scenarios
   - Document parameters and return types
   - Add notes for any special handling

5. **Use Case Integration**

   - For CRUD operations: call repository directly
   - For complex operations: delegate to use cases
   - Example endpoints using use cases:
     ```typescript
     export const createRoute = api(
       { method: 'POST', path: '/routes', expose: true },
       async (params: CreateSimpleRoutePayload): Promise<Route> => {
         return await routeUseCases.createSimpleRoute(params);
       },
     );
     ```

## Controller Testing

We test controllers using integration tests with a real database instead of mocks. Vitest is used as the testing framework.

```typescript
import { expect, describe, test, afterAll, beforeAll } from 'vitest';
import { createCountry, getCountry, updateCountry, deleteCountry } from './countries.controller';

describe('Countries Controller', () => {
  // Test data and setup
  const testCountry = {
    name: 'Test Country',
    code: 'TC',
    active: true,
  };

  // Variable to store created IDs for cleanup
  let createdCountryId: number;

  afterAll(async () => {
    // Clean up test data
    if (createdCountryId) {
      try {
        await deleteCountry({ id: createdCountryId });
      } catch (error) {
        console.log('Error cleaning up test country:', error);
      }
    }
  });

  describe('success scenarios', () => {
    test('should create a new country', async () => {
      // Create a new country
      const response = await createCountry(testCountry);

      // Store the ID for later cleanup
      createdCountryId = response.id;

      // Assertions
      expect(response).toBeDefined();
      expect(response.id).toBeDefined();
      expect(response.name).toBe(testCountry.name);
      expect(response.code).toBe(testCountry.code);
    });

    test('should retrieve a country by ID', async () => {
      const response = await getCountry({ id: createdCountryId });

      expect(response).toBeDefined();
      expect(response.id).toBe(createdCountryId);
      expect(response.name).toBe(testCountry.name);
    });

    test('should update a country', async () => {
      const updatedName = 'Updated Test Country';
      const response = await updateCountry({
        id: createdCountryId,
        name: updatedName,
      });

      expect(response).toBeDefined();
      expect(response.id).toBe(createdCountryId);
      expect(response.name).toBe(updatedName);
    });
  });

  describe('error scenarios', () => {
    test('should handle not found errors', async () => {
      await expect(getCountry({ id: 9999 })).rejects.toThrow();
    });
  });
});
```

## Common Controller Patterns

### Standard Endpoints for Resources

All resources should implement these standard endpoints:

1. **Create Resource**
   ```typescript
   export const createResource = api(
     { expose: true, method: 'POST', path: '/resources' },
     async (params: CreateResourcePayload): Promise<Resource> => {
       return await resourceRepository.create(params);
     },
   );
   ```

2. **Get Resource by ID**
   ```typescript
   export const getResource = api(
     { expose: true, method: 'GET', path: '/resources/:id' },
     async ({ id }: { id: number }): Promise<ResourceWithRelations> => {
       return await resourceRepository.findOneWithRelations(id);
     },
   );
   ```

3. **List Resources (with filters)**
   ```typescript
   export const listResources = api(
     { expose: true, method: 'POST', path: '/get-resources' },
     async (params: ResourceQueryOptions): Promise<Resources> => {
       const resources = await resourceRepository.findAll(params);
       return { resources };
     },
   );
   ```

4. **List Resources with Pagination**
   ```typescript
   export const listResourcesPaginated = api(
     { expose: true, method: 'POST', path: '/get-resources/paginated' },
     async (params: PaginationParamsResources): Promise<PaginatedResources> => {
       return await resourceRepository.findAllPaginated(params);
     },
   );
   ```

5. **Update Resource**
   ```typescript
   export const updateResource = api(
     { expose: true, method: 'PUT', path: '/resources/:id' },
     async ({ id, ...data }: UpdateResourcePayload & { id: number }): Promise<Resource> => {
       return await resourceRepository.update(id, data);
     },
   );
   ```

6. **Delete Resource**
   ```typescript
   export const deleteResource = api(
     { expose: true, method: 'DELETE', path: '/resources/:id' },
     async ({ id }: { id: number }): Promise<Resource> => {
       return await resourceRepository.delete(id);
     },
   );
   ```

7. **Search Resources**
   ```typescript
   export const searchResources = api(
     { expose: true, method: 'GET', path: '/resources/search' },
     async ({ term }: { term: string }): Promise<Resources> => {
       const resources = await resourceRepository.search(term);
       return { resources };
     },
   );
   ```

8. **Search Resources with Pagination**
   ```typescript
   export const searchResourcesPaginated = api(
     { expose: true, method: 'POST', path: '/resources/search/paginated' },
     async ({
       term,
       ...params
     }: PaginationParamsResources & {
       term: string;
     }): Promise<PaginatedResources> => {
       return await resourceRepository.searchPaginated(term, params);
     },
   );
   ```
