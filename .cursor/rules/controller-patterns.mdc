---
description: Patterns for controllers in Encore applications
globs: *.controller.ts
alwaysApply: false
---
# Controller Patterns

## Core Principles

1. Controllers should ONLY:

   - Define API routes and endpoints with Encore's `api` function
   - Handle request/response transformation
   - Call domain validation functions
   - Delegate operations to repositories, domains or use cases
   - Maintain clean separation from business logic

2. Use middleware for error handling (no try/catch needed in controllers)

3. Use domain validation for business rule validations

4. Follow REST standards with specific exceptions for complex filtering operations

5. Expose endpoints with the `expose: true` option

6. Use HTTP methods and status codes consistently following REST conventions:

   - **POST**: Create operations and operations requiring complex request bodies (like filtering)
   - **GET**: Simple retrieval operations (get one resource)
   - **PUT**: Update operations
   - **DELETE**: Delete operations

7. Use clear and consistent route naming patterns:

   - **POST** `/resources/create` - Create resource
   - **GET** `/resources/:id` - Get one resource by ID (REST-compliant)
   - **POST** `/resources/list/all` - Get filtered resources (non-paginated with complex filters)
   - **POST** `/resources/list` - Get paginated resources (with complex filters)
   - **PUT** `/resources/:id/update` - Update resource
   - **DELETE** `/resources/:id/delete` - Delete resource

   **Note**: List operations use POST to support complex filters in request body, which is an exception to REST standards for practical reasons.

8. Document all endpoints with JSDoc comments

## Implementation Example

```typescript
import { api } from 'encore.dev/api';
import type {
  Country,
  CreateCountryPayload,
  ListCountriesQueryParams,
  ListCountriesResult,
  PaginatedListCountriesQueryParams,
  PaginatedListCountriesResult,
  UpdateCountryPayload,
} from './countries.types';
import { countryRepository } from './countries.repository';
import { validateCountry } from './countries.domain';

/**
 * Creates a new country.
 * @param params - The country data to create
 * @returns {Promise<Country>} The created country
 * @throws {APIError} If the country creation fails
 */
export const createCountry = api(
  { expose: true, method: 'POST', path: '/countries/create' },
  async (params: CreateCountryPayload): Promise<Country> => {
    await validateCountry(params);
    return await countryRepository.create(params);
  },
);

/**
 * Retrieves a country by its ID.
 * @param params - Object containing the country ID
 * @param params.id - The ID of the country to retrieve
 * @returns {Promise<Country>} The found country
 * @throws {APIError} If the country is not found or retrieval fails
 */
export const getCountry = api(
  { expose: true, method: 'GET', path: '/countries/:id' },
  async ({ id }: { id: number }): Promise<Country> => {
    return await countryRepository.findOne(id);
  },
);

/**
 * Retrieves all countries without pagination (useful for dropdowns).
 * @param params - Query parameters including orderBy, filters, and searchTerm
 * @returns {Promise<ListCountriesResult>} Unified response with data property containing array of countries
 * @throws {APIError} If retrieval fails
 */
export const listCountries = api(
  { expose: true, method: 'POST', path: '/countries/list/all' },
  async (params: ListCountriesQueryParams): Promise<ListCountriesResult> => {
    const countries = await countryRepository.findAll(params);
    return {
      data: countries,
    };
  },
);

/**
 * Retrieves countries with pagination (useful for tables).
 * @param params - Pagination and query parameters including page, pageSize, orderBy, filters, and searchTerm
 * @returns {Promise<PaginatedListCountriesResult>} Unified paginated response with data and pagination properties
 * @throws {APIError} If retrieval fails
 */
export const listCountriesPaginated = api(
  { expose: true, method: 'POST', path: '/countries/list' },
  async (
    params: PaginatedListCountriesQueryParams,
  ): Promise<PaginatedListCountriesResult> => {
    return await countryRepository.findAllPaginated(params);
  },
);

/**
 * Updates an existing country.
 * @param params - Object containing the country ID and update data
 * @param params.id - The ID of the country to update
 * @returns {Promise<Country>} The updated country
 * @throws {APIError} If the country is not found or update fails
 */
export const updateCountry = api(
  { expose: true, method: 'PUT', path: '/countries/:id/update' },
  async ({
    id,
    ...data
  }: UpdateCountryPayload & { id: number }): Promise<Country> => {
    await validateCountry(data, id);
    return await countryRepository.update(id, data);
  },
);

/**
 * Deletes a country by its ID.
 * @param params - Object containing the country ID
 * @param params.id - The ID of the country to delete
 * @returns {Promise<Country>} The deleted country
 * @throws {APIError} If the country is not found or deletion fails
 */
export const deleteCountry = api(
  { expose: true, method: 'DELETE', path: '/countries/:id/delete' },
  async ({ id }: { id: number }): Promise<Country> => {
    return await countryRepository.delete(id);
  },
);
```

## Controller Best Practices

1. **Feature-First Organization**

   - Group all endpoints for a feature in a single controller file
   - Keep endpoints for the same resource together
   - Use descriptive function names matching operations

2. **Validation and Business Logic**

   - Call domain validation functions before creating or updating resources
   - Delegate domain validation to `.domain.ts` files for business rules and uniqueness constraints
   - Use domain validation for both create and update operations
   - Pass current entity ID for update operations to exclude it from uniqueness checks

3. **Simplification**

   - Rely on middleware for error handling (no try/catch needed)
   - Delegate directly to repositories for CRUD operations
   - Call use cases for complex business operations
   - Keep controller functions short and focused

4. **Type Safety**

   - Import all types from feature's `.types.ts` file
   - Use proper type annotations for parameters and returns
   - Ensure consistent response structures

5. **Documentation**

   - Document all endpoints with JSDoc comments
   - Include descriptions of possible error scenarios
   - Document parameters and return types
   - Add notes for any special handling

6. **Use Case Integration**

   - For CRUD operations: call domain validation, then repository directly
   - For complex operations: delegate to use cases
   - Example endpoints using use cases:
     ```typescript
     export const createRoute = api(
       { method: 'POST', path: '/routes/create', expose: true },
       async (params: CreateSimpleRoutePayload): Promise<Route> => {
         return await routeUseCases.createSimpleRoute(params);
       },
     );
     ```

## Controller Testing

We test controllers using integration tests with a real database instead of mocks. Vitest is used as the testing framework.

```typescript
import { expect, describe, test, afterAll, beforeAll } from 'vitest';
import { createCountry, getCountry, updateCountry, deleteCountry } from './countries.controller';

describe('Countries Controller', () => {
  // Test data and setup
  const testCountry = {
    name: 'Test Country',
    code: 'TC',
    active: true,
  };

  // Variable to store created IDs for cleanup
  let createdCountryId: number;

  afterAll(async () => {
    // Clean up test data
    if (createdCountryId) {
      try {
        await deleteCountry({ id: createdCountryId });
      } catch (error) {
        console.log('Error cleaning up test country:', error);
      }
    }
  });

  describe('success scenarios', () => {
    test('should create a new country', async () => {
      // Create a new country
      const response = await createCountry(testCountry);

      // Store the ID for later cleanup
      createdCountryId = response.id;

      // Assertions
      expect(response).toBeDefined();
      expect(response.id).toBeDefined();
      expect(response.name).toBe(testCountry.name);
      expect(response.code).toBe(testCountry.code);
    });

    test('should retrieve a country by ID', async () => {
      const response = await getCountry({ id: createdCountryId });

      expect(response).toBeDefined();
      expect(response.id).toBe(createdCountryId);
      expect(response.name).toBe(testCountry.name);
    });

    test('should update a country', async () => {
      const updatedName = 'Updated Test Country';
      const response = await updateCountry({
        id: createdCountryId,
        name: updatedName,
      });

      expect(response).toBeDefined();
      expect(response.id).toBe(createdCountryId);
      expect(response.name).toBe(updatedName);
    });
  });

  describe('error scenarios', () => {
    test('should handle not found errors', async () => {
      await expect(getCountry({ id: 9999 })).rejects.toThrow();
    });
  });
});
```

## Common Controller Patterns

### Standard Endpoints for Resources

All resources should implement these standard endpoints following REST conventions with exceptions for complex filtering:

1. **Create Resource**
   ```typescript
   export const createResource = api(
     { expose: true, method: 'POST', path: '/resources/create' },
     async (params: CreateResourcePayload): Promise<Resource> => {
       return await resourceRepository.create(params);
     },
   );
   ```

2. **Get Resource by ID**
   ```typescript
   export const getResource = api(
     { expose: true, method: 'GET', path: '/resources/:id' },
     async ({ id }: { id: number }): Promise<ResourceWithRelations> => {
       return await resourceRepository.findOneWithRelations(id);
     },
   );
   ```

3. **List Resources (non-paginated with search support)**
   ```typescript
   export const listResources = api(
     { expose: true, method: 'POST', path: '/resources/list/all' },
     async (params: ListResourcesQueryParams): Promise<ListResourcesResult> => {
       const resources = await resourceRepository.findAll(params);
       return {
         data: resources,
       };
     },
   );
   ```

4. **List Resources with Pagination (with search support)**
   ```typescript
   export const listResourcesPaginated = api(
     { expose: true, method: 'POST', path: '/resources/list' },
     async (params: PaginatedListResourcesQueryParams): Promise<PaginatedListResourcesResult> => {
       return await resourceRepository.findAllPaginated(params);
     },
   );
   ```

5. **Update Resource**
   ```typescript
   export const updateResource = api(
     { expose: true, method: 'PUT', path: '/resources/:id/update' },
     async ({ id, ...data }: UpdateResourcePayload & { id: number }): Promise<Resource> => {
       return await resourceRepository.update(id, data);
     },
   );
   ```

6. **Delete Resource**
   ```typescript
   export const deleteResource = api(
     { expose: true, method: 'DELETE', path: '/resources/:id/delete' },
     async ({ id }: { id: number }): Promise<Resource> => {
       return await resourceRepository.delete(id);
     },
   );
   ```