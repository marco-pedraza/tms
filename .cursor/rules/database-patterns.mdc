---
description: define how to manages database schemas
globs: **/server/db/**
alwaysApply: false
---
# Database Organization Patterns

## Overview

This document defines database patterns in our Encore application, following the Repository pattern and Locality of Behavior (LoB) principle. Each feature defines its schema in its own directory, while a central schema.ts file aggregates them for migrations.

### Key Principles:

1. **Complete Base Repository**: Base implementation encapsulates CRUD operations and common functionality. Don't create unnecessary wrappers.

2. **Minimal Extension**: Only implement custom methods when needed:
   - Loading relationships (with Drizzle's relations)
   - Validating domain-specific rules
   - Transforming data before/after database operations

3. **Function Declarations**: Use `function` declarations instead of arrow functions

4. **Configuration Over Implementation**: Use options to configure behavior rather than overriding methods

## Directory Structure

```
apps/server/
├── db/                       # Root-level database configuration
│   ├── database.ts          # Database connection configuration
│   ├── schema.ts            # Schema exports aggregation
│   ├── index.ts             # Database exports aggregation
│   └── migrations/          # Database migrations
├── shared/                  # Shared utilities
│   └── base-repository.ts   # Base repository implementation
└── [subsystem]/[feature]/   # Feature-specific implementations
    ├── [feature].schema.ts  # Schema definition
    └── [feature].repository.ts # Repository implementation
```

## Core Components

### 1. Base Repository Implementation and Available Methods

The base repository provides a complete set of CRUD operations and common functionality. **You should not re-implement these methods** in feature repositories unless you need to add specific validation or transformation logic.

The base repository provides a comprehensive set of methods for database operations. **All methods are fully implemented** - you should not re-implement them unless you need specific validation or transformation logic.

**Complete Method Reference**: For the full interface definition and JSDoc documentation of all methods, see `packages/base-repo/src/base-repository.ts`.

#### Core CRUD Operations
```typescript
findOne(id: number): Promise<TEntity>                    // Find entity by ID
create(data: TCreatePayload): Promise<TEntity>           // Create new entity  
update(id: number, data: TUpdatePayload): Promise<TEntity> // Update existing entity
delete(id: number): Promise<TEntity>                     // Delete entity (soft/hard based on config)
```

#### Bulk Operations  
```typescript
findAll(params?: QueryOptions): Promise<TEntity[]>      // Get all entities with filters/search/ordering
findAllPaginated(params?: PaginationParams): Promise<PaginatedResult> // Paginated results
deleteAll(): Promise<number>                            // Delete all records (returns count)
deleteMany(ids: number[]): Promise<TEntity[]>           // Delete multiple entities by IDs
```

#### Field-Based Queries
```typescript
findBy(field: PgColumn, value: unknown): Promise<TEntity | null>     // Find single entity by field
findAllBy(field: PgColumn, value: unknown, options?: QueryOptions): Promise<TEntity[]> // Find all by field
findByPaginated(field: PgColumn, value: unknown, params?: PaginationParams): Promise<PaginatedResult> // Paginated field search
```

#### Validation & Existence Checks
```typescript
existsBy(field: PgColumn, value: unknown, excludeId?: number): Promise<boolean> // Check if entity exists by field
countAll(options?: QueryOptions): Promise<number>       // Count entities with filters/search
checkUniqueness(fields: UniqueFieldConfig[], excludeId?: number): Promise<ConflictInfo[]> // Validate uniqueness
validateRelationExists(relatedTable, relationId, relationName?, hasSoftDelete?): Promise<void> // Validate FK
```

#### Soft Delete Operations (requires `softDeleteEnabled: true`)
```typescript
forceDelete(id: number): Promise<TEntity>               // Permanently delete (hard delete)
restore(id: number): Promise<TEntity>                   // Restore soft-deleted entity
```

#### Search Operations (DEPRECATED - requires `searchableFields` configuration)
```typescript
search(term: string): Promise<TEntity[]>                // ⚠️ DEPRECATED: Use findAll({ searchTerm })
searchPaginated(term: string, params?: PaginationParams): Promise<PaginatedResult> // ⚠️ DEPRECATED: Use findAllPaginated({ searchTerm })
```

**⚠️ Important**: These methods are deprecated and should be removed when possible. Use `findAll({ searchTerm })` and `findAllPaginated({ searchTerm })` instead.

#### Transaction Support
```typescript
transaction<T>(callback: (txRepo, tx) => Promise<T>): Promise<T> // Execute in transaction
withTransaction(tx: TransactionalDB): BaseRepository     // Create transaction-scoped repository
```

#### Advanced Query Building
```typescript
buildQueryExpressions(params?: QueryOptions): { baseWhere?: SQL, baseOrderBy?: SQL[] } // Build reusable query conditions
```

#### Configuration Options
```typescript
export interface BaseRepositoryOptions<TSchema> {
  searchableFields?: TSchema[];        // Fields to search against (required for search methods)
  softDeleteEnabled?: boolean;         // Enable soft delete functionality
  orderByField?: TSchema;             // Default ordering field
  orderDirection?: 'asc' | 'desc';    // Default ordering direction
}
```

### 2. Creating Feature Repositories

When creating a feature repository, follow these guidelines:

```typescript
import { featureSchema } from './feature.schema';
import type { FeatureEntity, CreateFeaturePayload, UpdateFeaturePayload } from './feature.types';
import { createBaseRepository } from '@repo/base-repo';
import { db } from '../db-service';

// Use function declaration instead of arrow functions
export function createFeatureRepository() {
  // Configure the base repository with types and options
  const baseRepository = createBaseRepository<
    FeatureEntity,                // Import from types.ts, don't redefine
    CreateFeaturePayload,         // Import from types.ts
    UpdateFeaturePayload,         // Import from types.ts
    typeof featureSchema          // Schema from schema.ts
  >(db, featureSchema, 'Feature', {
    searchableFields: [featureSchema.name], // Fields for text search
  });

  // ONLY add custom methods when needed, such as:
  // 1. Loading relationships (with Drizzle's "with" functionality)
  async function findOneWithRelations(id: number) {
    const result = await db.query.features.findFirst({
      where: eq(featureSchema.id, id),
      with: {
        relatedEntity: true,
      },
    });

    if (!result) throw new NotFoundError(`Feature not found`);
    return result;
  }

  // 2. Custom validations/transformations before database operations
  async function create(data: CreateFeaturePayload) {
    // Validate or transform data before creating
    validateData(data);

    // No need to create a wrapper if no additional logic is needed
    return baseRepository.create(data);
  }

  return {
    ...baseRepository,           // Spread ALL base repository methods
    findOneWithRelations,        // Add custom methods only when needed
    create,                      // Override base methods only when necessary
  };
}

// Export the instance to use throughout the application
export const featureRepository = createFeatureRepository();
```

### 3. Minimal Repository Example (Countries)

```typescript
// inventory/countries/countries.repository.ts
import { countries } from './countries.schema';
import type {
  Country,
  CreateCountryPayload,
  UpdateCountryPayload,
} from './countries.types';
import { createBaseRepository } from '@repo/base-repo';
import { db } from '../db-service';

/**
 * Creates a repository for managing country entities
 */
export function createCountryRepository() {
  // No custom methods needed - just configure the base repository
  return createBaseRepository<
    Country,
    CreateCountryPayload,
    UpdateCountryPayload,
    typeof countries
  >(db, countries, 'Country', {
    searchableFields: [countries.name, countries.code],
    softDeleteEnabled: true,
  });
}

export const countryRepository = createCountryRepository();
```

### 4. Repository with Relationships (Terminals)

```typescript
// inventory/terminals/terminals.repository.ts
import { terminals } from './terminals.schema';
import type {
  Terminal,
  CreateTerminalPayload,
  UpdateTerminalPayload,
  TerminalWithCity,
} from './terminals.types';
import { createBaseRepository } from '@repo/base-repo';
import { db } from '../db-service';
import { eq } from 'drizzle-orm';
import { validateOperatingHours } from './terminals.utils';
import { createSlug } from '../../shared/utils';

/**
 * Creates a repository for managing terminal entities
 */
export function createTerminalRepository() {
  const baseRepository = createBaseRepository<
    Terminal,
    CreateTerminalPayload & { slug: string },
    UpdateTerminalPayload & { slug?: string },
    typeof terminals
  >(db, terminals, 'Terminal', {
    searchableFields: [terminals.name, terminals.code, terminals.slug],
  });

  /**
   * Finds a terminal with its associated city
   * Custom method to load relationship data
   */
  async function findOneWithCity(id: number): Promise<TerminalWithCity> {
    const terminal = await db.query.terminals.findFirst({
      where: eq(terminals.id, id),
      with: { city: true }, // Load the city relationship
    });

    if (!terminal) {
      throw new NotFoundError('Terminal not found');
    }

    return terminal;
  }

  /**
   * Creates a new terminal with auto-generated slug and validation
   * Custom validation and data transformation before create
   */
  async function create(data: CreateTerminalPayload): Promise<Terminal> {
    // Domain-specific validation
    if (data.operatingHours) {
      validateOperatingHours(data.operatingHours);
    }

    // Generate a slug from the name
    const slug = createSlug(data.name, 't');

    // Use base repository create with enhanced data
    return await baseRepository.create({ ...data, slug });
  }

  return {
    ...baseRepository,
    findOneWithCity,
    create,
    // Add other custom methods as needed
  };
}

export const terminalRepository = createTerminalRepository();
```

### 5. Transaction and Compound Operations

```typescript
// Example using transaction for operations across multiple repositories
async function createCompoundEntity(data) {
  // Use transaction to ensure all-or-nothing operation
  return mainRepository.transaction(async (txMainRepo, tx) => {
    // Create transaction-scoped repositories
    const txRelatedRepo = relatedRepository.withTransaction(tx);

    // Create main entity
    const entity = await txMainRepo.create({
      name: data.name,
      // other fields
    });

    // Create related entities in the same transaction
    await txRelatedRepo.create({
      mainEntityId: entity.id,
      // other fields
    });

    // Return only the ID from within the transaction
    return entity.id;
  }).then(id => {
    // After transaction completes successfully, retrieve with full details
    return mainRepository.findOneWithDetails(id);
  });
}
```

## Common Method Usage Examples

### Validation and Existence Checks

```typescript
// Check if a country code already exists (for validation)
const codeExists = await countryRepository.existsBy(countries.code, 'US');

// Check uniqueness excluding current record (for updates)
const conflicts = await countryRepository.checkUniqueness([
  { field: countries.code, value: 'US' },
  { field: countries.name, value: 'United States' }
], excludeId);

// Count active countries
const activeCount = await countryRepository.countAll({ 
  filters: { active: true } 
});

// Validate that a related city exists before creating a terminal
await terminalRepository.validateRelationExists(
  cities, 
  terminalData.cityId, 
  'City',
  true // City table has soft delete enabled
);
```

### Field-Based Queries

```typescript
// Find all terminals in a specific city
const cityTerminals = await terminalRepository.findAllBy(
  terminals.cityId, 
  cityId,
  { orderBy: [{ field: terminals.name, direction: 'asc' }] }
);

// Find a country by code
const country = await countryRepository.findBy(countries.code, 'MX');

// Paginated search by field
const result = await terminalRepository.findByPaginated(
  terminals.cityId,
  cityId,
  { page: 1, pageSize: 10 }
);
```

### Bulk Operations

```typescript
// Delete multiple countries by IDs
const deletedCountries = await countryRepository.deleteMany([1, 2, 3]);

// Count total records
const totalCount = await countryRepository.countAll();

// Get all active entities with search (preferred method)
const activeEntities = await entityRepository.findAll({
  filters: { active: true },
  searchTerm: 'search term',
  orderBy: [{ field: schema.name, direction: 'asc' }]
});

// Paginated search (preferred method)
const searchResults = await entityRepository.findAllPaginated({
  searchTerm: 'search term',
  filters: { active: true },
  page: 1,
  pageSize: 10
});
```

### Soft Delete Operations

```typescript
// Permanently delete a soft-deleted record
await countryRepository.forceDelete(countryId);

// Restore a soft-deleted record
const restoredCountry = await countryRepository.restore(countryId);
```

### Advanced Query Building

```typescript
// Build reusable query conditions for complex queries with relations
const { baseWhere, baseOrderBy } = terminalRepository.buildQueryExpressions({
  filters: { active: true },
  searchTerm: 'central',
  orderBy: [{ field: terminals.name, direction: 'asc' }]
});

// Use in a complex query with relations
const terminalsWithCities = await db.query.terminals.findMany({
  where: baseWhere,
  orderBy: baseOrderBy,
  with: { city: true }
});
```

## Repository Best Practices

1. **Use Function Declarations**: Prefer `function createRepository()` over arrow functions
2. **Import Types**: Get types from `types.ts`, not inline declarations
3. **Configure Options**: Set `searchableFields` instead of overriding search methods
4. **Minimal Extensions**: Only add methods when base repository is insufficient
5. **Clear Purpose**: Each custom method should solve a specific use case
6. **Transaction Support**: Use `withTransaction` to coordinate complex operations
7. **Handle Relations**: Use Drizzle's `with` functionality to load relationships
8. **Leverage Built-in Methods**: Use `existsBy`, `countAll`, `deleteMany` instead of custom implementations
9. **Avoid Deprecated Methods**: Use `findAll({ searchTerm })` and `findAllPaginated({ searchTerm })` instead of `search()` and `searchPaginated()`

## Common Repository Patterns

1. **Minimal Repository**: Just configure base repository, no custom methods (Countries)
2. **Repository with Relationships**: Add methods for eager-loading relations (Terminals, Routes)
3. **Repository with Validation**: Override create/update to add validation (Terminals)
4. **Repository with Transformations**: Transform data before/after operations (Slugs)
5. **Repository with Transactions**: Coordinate operations across repositories (RouteSegments)

## Schema Definition Patterns

### 1. Simple Schema (No Relations)

```typescript
// inventory/countries/countries.schema.ts
import { pgTable, serial, text, timestamp, boolean, index, uniqueIndex } from 'drizzle-orm/pg-core';
import { isNull } from 'drizzle-orm';

export const countries = pgTable('countries', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(), // Don't use .unique() with soft delete
  code: text('code').notNull(), // Don't use .unique() with soft delete
  active: boolean('active').notNull().default(true),
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow(),
  deletedAt: timestamp('deleted_at'), // Optional: for soft delete
}, (table) => [
  // If using soft delete, use conditional unique indexes instead of .unique()
  uniqueIndex().on(table.name).where(isNull(table.deletedAt)),
  uniqueIndex().on(table.code).where(isNull(table.deletedAt)),
  index().on(table.deletedAt) // Index for soft delete performance
]);
```

### 2. Schema with Soft Delete

```typescript
// inventory/features/features.schema.ts
import { pgTable, serial, text, timestamp, boolean, index, uniqueIndex } from 'drizzle-orm/pg-core';
import { isNull } from 'drizzle-orm';

export const features = pgTable('features', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(), // Remove .unique() for soft delete compatibility
  code: text('code').notNull(), // Remove .unique() for soft delete compatibility
  active: boolean('active').notNull().default(true),
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow(),
  deletedAt: timestamp('deleted_at'), // Required for soft delete
}, (table) => [
  // Conditional unique indexes - only apply to non-soft-deleted records
  uniqueIndex().on(table.name).where(isNull(table.deletedAt)),
  uniqueIndex().on(table.code).where(isNull(table.deletedAt)),
  index().on(table.deletedAt) // Index for performance
]);
```

**Critical**: When using soft delete, replace `.unique()` constraints with conditional `uniqueIndex` to avoid conflicts with soft-deleted records.

### 3. Schema with Relations

```typescript
// inventory/routes/routes.schema.ts
import { pgTable, serial, text, integer, real, boolean, timestamp } from 'drizzle-orm/pg-core';
import { relations } from 'drizzle-orm';
import { cities } from '../cities/cities.schema';
import { terminals } from '../terminals/terminals.schema';
import { pathways } from '../pathways/pathways.schema';

// Define the table schema
export const routes = pgTable('routes', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
  originCityId: integer('origin_city_id')
    .notNull()
    .references(() => cities.id),
  destinationCityId: integer('destination_city_id')
    .notNull()
    .references(() => cities.id),
  distance: real('distance').notNull(),
  // Other fields...
});

// Define relations (for Drizzle ORM's relationship loading)
export const routesRelations = relations(routes, ({ one, many }) => ({
  originCity: one(cities, {
    fields: [routes.originCityId],
    references: [cities.id],
  }),
  destinationCity: one(cities, {
    fields: [routes.destinationCityId],
    references: [cities.id],
  }),
  // Other relations...
}));
```

### 4. Aggregating Schemas for Migrations

All schemas are exported in `db/schema.ts` for Drizzle to generate migrations:

```typescript
// db/schema.ts
export { countries } from '../inventory/countries/countries.schema';
export { states } from '../inventory/states/states.schema';
export { cities } from '../inventory/cities/cities.schema';
export {
  terminals,
  terminalsRelations,
} from '../inventory/terminals/terminals.schema';
// ... other exports
```


## Adding New Features

1. Create schema in feature directory (`feature.schema.ts`)
2. Export schema in central `db/schema.ts`
3. Create repository (`function createRepository()`)
4. Generate migrations (`drizzle-kit generate`)
5. Implement controller with Encore APIs

## Repository Creation Checklist

- [ ] Import types from `.types.ts` file
- [ ] Use function declaration, not arrow function
- [ ] Configure searchable fields appropriately
- [ ] Only add custom methods when needed
- [ ] Export singleton instance