---
description: Patterns for error handling in Encore applications
globs: *.controller.ts, apps/server/*/*/*.ts
alwaysApply: false
---
# Error Handling Patterns

## Overview

This document defines the standard error handling patterns in our Encore application. We use a centralized approach with consistent error types and handling across all layers of the application.

## Error Types

### Base Error Classes

```typescript
// shared/errors.ts
import { APIError, ErrCode } from 'encore.dev/api';

/**
 * Base error for resources not found
 */
export class NotFoundError extends Error {
  constructor(message: string = 'Resource not found') {
    super(message);
    this.name = 'NotFoundError';
  }
}

/**
 * Base error for validation failures
 */
export class ValidationError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'ValidationError';
  }
}

/**
 * Base error for duplicate resource errors
 */
export class DuplicateError extends Error {
  constructor(message: string = 'Resource already exists') {
    super(message);
    this.name = 'DuplicateError';
  }
}
```

### Error Mapping

```typescript
/**
 * Maps domain errors to Encore APIError with appropriate codes
 * @param error - The error to handle
 * @returns {APIError} Mapped API error
 */
export const parseApiError = (error: unknown): APIError => {
  if (error instanceof NotFoundError) {
    return new APIError(ErrCode.NotFound, error.message);
  }
  if (error instanceof ValidationError) {
    return new APIError(ErrCode.InvalidArgument, error.message);
  }
  if (error instanceof DuplicateError) {
    return new APIError(ErrCode.AlreadyExists, error.message);
  }
  return new APIError(ErrCode.Internal, 'Internal server error');
};
```

## Usage Patterns

### 1. In Repositories

Repositories throw domain-specific errors for data access issues:

```typescript
// feature/repository.ts
export const createFeatureRepository = () => {
  const findOne = async (id: number): Promise<Entity> => {
    const [entity] = await db.select().from(schema).where(eq(schema.id, id)).limit(1);

    if (!entity) {
      throw new NotFoundError('Entity not found');
    }

    return entity;
  };

  const validateUniqueness = async (name: string, excludeId?: number): Promise<void> => {
    const existing = await findByName(name);
    if (existing && existing.id !== excludeId) {
      throw new DuplicateError('Entity with this name already exists');
    }
  };

  return {
    findOne,
    validateUniqueness,
    // ... other methods
  };
};
```

### 2. In Controllers

Controllers catch domain errors and map them to API errors:

```typescript
// feature/controller.ts
export const getEntity = api(
  { method: 'GET', path: '/entities/:id' },
  async ({ id }: { id: number }): Promise<Entity> => {
    try {
      return await entityRepository.findOne(id);
    } catch (error) {
      throw parseApiError(error);
    }
  }
);

export const createEntity = api(
  { method: 'POST', path: '/entities' },
  async (params: CreateEntityPayload): Promise<Entity> => {
    try {
      return await entityRepository.create(params);
    } catch (error) {
      throw parseApiError(error);
    }
  }
);
```

### 3. In Handlers (When Used)

Handlers add business context to errors:

```typescript
// feature/handler.ts
export const createFeatureHandler = () => {
  const processComplexOperation = async (data: ComplexPayload) => {
    try {
      // Validate business rules
      if (!isValidOperation(data)) {
        throw new ValidationError('Invalid operation parameters');
      }

      // Coordinate multiple repositories
      const result = await repository.transaction(async (trx) => {
        // ... complex logic
      });

      return result;
    } catch (error) {
      if (error instanceof ValidationError) {
        throw error;
      }
      throw new ValidationError('Operation failed: ' + error.message);
    }
  };

  return {
    processComplexOperation,
  };
};
```

## Error Mapping Table

| Domain Error    | API Error Code          | HTTP Status | Use Case                    |
| --------------- | ----------------------- | ----------- | --------------------------- |
| NotFoundError   | ErrCode.NotFound        | 404         | Resource doesn't exist      |
| ValidationError | ErrCode.InvalidArgument | 400         | Invalid input/parameters    |
| DuplicateError  | ErrCode.AlreadyExists   | 409         | Unique constraint violation |
| Other Errors    | ErrCode.Internal        | 500         | Unexpected errors           |

## Best Practices

1. **Error Creation**

   - Use descriptive error messages
   - Include relevant context
   - Keep messages user-friendly
   - Avoid exposing internal details

2. **Error Handling**

   - Catch errors at appropriate levels
   - Transform errors consistently
   - Log errors with context
   - Maintain error hierarchy

3. **Repository Layer**

   - Throw specific domain errors
   - Include relevant error context
   - Handle database errors appropriately
   - Validate data constraints

4. **Controller Layer**

   - Use parseApiError consistently
   - Handle all possible errors
   - Return appropriate status codes
   - Keep error responses consistent

5. **Handler Layer**

   - Add business context to errors
   - Handle complex validation errors
   - Maintain transaction integrity
   - Provide clear error messages

6. **General Guidelines**
   - Never expose stack traces
   - Log errors for debugging
   - Use consistent error patterns
   - Document error scenarios
   - Test error cases thoroughly

