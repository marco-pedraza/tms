---
description: Structure and patterns for features in Encore-based applications
globs: **/server/**
alwaysApply: false
---

# Feature Structure Pattern

> **ðŸ“– See `AGENTS.md` for complete pattern selection guide (Entity vs Repository Pattern) and DDD philosophy**

## Essential Description

Features follow hierarchical structure (subsystem/feature). Each feature defines its own schema following Locality of Behavior. **Entity Pattern is the standard** for domain entities; **Repository Pattern only for value objects**. See `AGENTS.md` for decision criteria.

## File Structure

### Entity Pattern (Standard for domain entities)

```
feature-name/
â”œâ”€â”€ feature-name.entity.ts              # Entity factory with behavior
â”œâ”€â”€ feature-name.application-service.ts  # Orchestration and transactions
â”œâ”€â”€ feature-name.domain-service.ts       # Complex operations (optional)
â”œâ”€â”€ feature-name.controller.ts           # API endpoints
â”œâ”€â”€ feature-name.repository.ts           # Data access
â”œâ”€â”€ feature-name.types.ts                # Types (includes Entity types)
â”œâ”€â”€ feature-name.schema.ts               # Database schema
â”œâ”€â”€ feature-name.errors.ts               # Domain-specific errors
â””â”€â”€ feature-name.controller.spec.ts      # Integration tests
```

**Minimal entity.ts example**:

```typescript
export function createFeatureEntity(dependencies) {
  function create(payload): FeatureEntity {
    validateBusinessRules(payload);
    return createInstance(payload);
  }

  function fromData(data): FeatureEntity {
    return createInstance(data);
  }

  async function findOne(id): Promise<FeatureEntity> {
    const data = await repository.findOne(id);
    return createInstance(data);
  }

  return { create, fromData, findOne };
}
```

**Minimal application-service.ts example**:

```typescript
export function createFeatureApplicationService() {
  const entityFactory = createFeatureEntity({ repository });

  return {
    create: (payload) => {
      const entity = entityFactory.create(payload);
      return entity.save();
    },
    // ... other methods
  };
}
```

### Repository Pattern (Only for value objects)

```
feature-name/
â”œâ”€â”€ feature-name.repository.ts    # Data access (extends base repo)
â”œâ”€â”€ feature-name.controller.ts     # API endpoints
â”œâ”€â”€ feature-name.domain.ts         # Validation and business rules
â”œâ”€â”€ feature-name.types.ts          # TypeScript types
â”œâ”€â”€ feature-name.schema.ts         # Database schema
â””â”€â”€ feature-name.controller.spec.ts # Tests
```

**Minimal repository.ts example**:

```typescript
export function createFeatureRepository() {
  return createBaseRepository<Feature, CreatePayload, UpdatePayload, typeof schema>(
    db,
    schema,
    'Feature',
    { searchableFields: [schema.name] }
  );
}

export const featureRepository = createFeatureRepository();
```

**Minimal domain.ts example**:

```typescript
export async function validateFeature(payload: CreatePayload, currentId?: number): Promise<void> {
  const collector = new FieldErrorCollector();
  const conflicts = await repository.checkUniqueness(
    [{ field: schema.name, value: payload.name }],
    currentId
  );
  conflicts.forEach((conflict) => {
    standardFieldErrors.duplicate('Feature', conflict.field, conflict.value, collector);
  });
  collector.throwIfErrors();
}
```

**Minimal controller.ts example**:

```typescript
export const createFeature = api(
  { method: 'POST', path: '/features/create', auth: true },
  async (params: CreatePayload): Promise<Feature> => {
    await validateFeature(params);
    return await repository.create(params);
  }
);
```

## References

- See `AGENTS.md` section "Backend Pattern Selection: Entity vs Repository" for decision criteria
- See `AGENTS.md` section "Entity Pattern Components" for Application Service and Domain Service details
- See `AGENTS.md` section "Domain Validation" for validation patterns
