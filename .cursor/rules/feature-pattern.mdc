---
description: Structure and patterns for features in Encore-based applications
globs: **/server/**
alwaysApply: false
---
# Feature Structure Pattern

## Overview

This document defines the standard structure and implementation patterns for features in our Encore-based application. The codebase is organized hierarchically with systems, subsystems, and features. Following the Locality of Behavior (LoB) principle, each feature includes its own database schema alongside its business logic.

## Directory Structure

```
apps/
└── server/                   # Main system
    ├── db/                   # Root-level database configuration and aggregation
    │   ├── database.ts       # Database connection configuration
    │   ├── schema.ts         # Schema exports aggregation
    │   ├── index.ts          # Database exports aggregation
    │   ├── migrations/       # Database migrations
    │   └── schemas/          # Reserved for shared schemas (if needed)
    ├── inventory/            # Subsystem for inventory management
    │   ├── countries/        # Feature: countries management
    │   │   ├── countries.handler.ts          # Business logic (Handler)
    │   │   ├── countries.controller.ts       # API endpoints (Controller)
    │   │   ├── countries.types.ts            # Type definitions
    │   │   ├── countries.schema.ts           # Database schema definition
    │   │   └── countries.controller.spec.ts  # Unit tests
    │   └── states/           # Feature: states management
    │       ├── states.handler.ts
    │       ├── states.controller.ts
    │       ├── states.types.ts
    │       ├── states.schema.ts
    │       └── states.controller.spec.ts
    ├── users/                # Another subsystem
    │   └── ...
    └── shared/               # Utilities shared across subsystems
        ├── errors.ts         # Centralized error handling
        └── validators.ts     # Shared validation utilities
```

## Feature Structure

Each feature follows this structure:

```
feature-name/                 # Example: countries/
├── feature-name.handler.ts           # Handler with business logic
├── feature-name.controller.ts        # Encore API endpoints
├── feature-name.types.ts             # Type definitions
├── feature-name.schema.ts            # Database schema definition
└── feature-name.controller.spec.ts   # Unit tests for controller
```

## Type Structure

Each feature should have the following type definitions:

1. Base entity interface (e.g., `Country`, `State`)
2. Creation payload (e.g., `CreateCountryPayload`, `CreateStatePayload`)
3. Update payload (e.g., `UpdateCountryPayload`, `UpdateStatePayload`)
4. List response (e.g., `Countries`, `States`)

## Specific Rules

### General Rules

1. Each feature should be contained in its own directory inside the relevant subsystem
2. All files in a feature should be prefixed with the feature name
3. Keep feature-specific code, including schema definitions, within the feature directory
4. Maximum file size should not exceed 500 lines
5. Use meaningful and descriptive names for all entities
6. Follow TypeScript naming conventions strictly

For detailed documentation of each component, see:

- [typescript-patterns.mdc](mdc:.cursor/rules/typescript-patterns.mdc) - General TypeScript patterns
- [handler-patterns.mdc](mdc:.cursor/rules/handler-patterns.mdc) - Patterns for handlers
- [controller-patterns.mdc](mdc:.cursor/rules/controller-patterns.mdc) - Patterns for controllers
- [types-patterns.mdc](mdc:.cursor/rules/types-patterns.mdc) - Patterns for type definitions
- [error-handling.mdc](mdc:.cursor/rules/error-handling.mdc) - Error handling
- [testing-patterns.mdc](mdc:.cursor/rules/testing-patterns.mdc) - Testing standards and patterns
- [database-patterns.mdc](mdc:.cursor/rules/database-patterns.mdc) - Database standars and patterns

## Creating New Features

### Adding a New Feature to an Existing Subsystem

1. Create a new directory with the feature name inside the subsystem (e.g., `inventory/cities/`)
2. Create the standard feature files with appropriate naming:
   - `cities.handler.ts` (Handler)
   - `cities.controller.ts` (API endpoints)
   - `cities.types.ts` (Types and DTOs)
   - `cities.schema.ts` (Database schema)
   - `cities.controller.spec.ts` (Tests)
3. Export the schema in the root `db/schema.ts` file
4. Implement the feature following the established patterns

### Creating a New Subsystem

1. Create a new directory in `apps/server/` for the subsystem (e.g., `logistics/`)
2. Add feature directories inside the subsystem
3. Reuse the shared utilities from `server/shared/`
4. Utilize the root-level database configuration

### Database Schema Best Practices

1. **Schema Definition**:

   - Define tables with clear, descriptive column names
   - Use appropriate data types for columns
   - Define relationships using foreign keys
   - Document complex relationships or constraints

2. **Schema References**:

   - When referencing schemas from other features, import them directly
   - Example: `import { countries } from '../countries/countries.schema';`

3. **Schema Exports**:
   - Export schema definitions for use in other features
   - Add new schema exports to `db/schema.ts` for migration generation

## Important Guidelines

1. Code Organization

   - Maintain consistent file structure
   - Follow naming conventions
   - Keep responsibilities separated
   - Document complex logic
   - Use strict TypeScript types
   - Handle errors consistently
   - Follow Locality of Behavior by keeping related code together

2. Code Quality

   - Write unit tests for all features
   - Maintain 80% or higher test coverage
   - Use TypeScript strict mode
   - Follow ESLint rules
   - Use Prettier for formatting
   - Review code before committing

3. Performance

   - Optimize database queries
   - Use proper indexing
   - Implement caching when necessary
   - Handle pagination properly

4. Security
   - Validate all inputs
   - Sanitize all outputs
   - Use proper authentication
   - Implement authorization
   - Handle sensitive data appropriately
   - Follow security best practices
