---
description: Structure and patterns for features in Encore-based applications
globs: **/server/**
alwaysApply: false
---
# Feature Structure Pattern

## Overview

This document defines the standard structure and implementation patterns for features in our Encore-based application. The codebase is organized hierarchically with systems, subsystems, and features. Following the Locality of Behavior (LoB) principle, each feature includes its own database schema alongside its data access layer.

## Directory Structure

```
apps/
└── server/                   # Main system
    ├── db/                   # Root-level database configuration and aggregation
    │   ├── database.ts       # Database connection configuration
    │   ├── schema.ts         # Schema exports aggregation
    │   ├── index.ts         # Database exports aggregation
    │   ├── migrations/       # Database migrations
    │   └── schemas/          # Reserved for shared schemas (if needed)
    ├── inventory/            # Subsystem for inventory management
    │   ├── countries/        # Feature: countries management
    │   │   ├── countries.repository.ts       # Data access layer (Repository)
    │   │   ├── countries.controller.ts       # API endpoints (Controller)
    │   │   ├── countries.types.ts            # Type definitions
    │   │   ├── countries.schema.ts           # Database schema definition
    │   │   └── countries.controller.spec.ts  # Unit tests
    │   └── states/           # Feature: states management
    │       ├── states.repository.ts
    │       ├── states.controller.ts
    │       ├── states.types.ts
    │       ├── states.schema.ts
    │       └── states.controller.spec.ts
    ├── users/                # Another subsystem
    │   └── ...
    └── shared/               # Utilities shared across subsystems
        ├── errors.ts         # Centralized error handling
        ├── validators.ts     # Shared validation utilities
        └── base-repository.ts # Base repository implementation
```

## Feature Structure

Each feature follows this structure:

```
feature-name/                 # Example: countries/
├── feature-name.repository.ts        # Data access layer (Repository)
├── feature-name.controller.ts        # Encore API endpoints
├── feature-name.types.ts             # Type definitions
├── feature-name.schema.ts            # Database schema definition
└── feature-name.controller.spec.ts   # Unit tests for controller
```

## Repository Pattern

The Repository pattern is used for features that primarily deal with CRUD operations. This pattern:

1. **Encapsulates Data Access**: All database operations are contained within the repository
2. **Provides Clean API**: Offers a clear interface for data operations
3. **Handles Validation**: Manages data validation and uniqueness constraints
4. **Reuses Common Logic**: Extends from base repository for standard CRUD operations

### Repository as Primary Pattern

The Repository pattern should be the default choice for all features. Most features will only need a repository since they primarily deal with CRUD operations and data validation.

### When to Add a Handler

Handlers are optional and should only be added when:

- Complex business logic that goes beyond CRUD operations is needed
- Operations need to coordinate multiple repositories
- Feature requires orchestration of multiple services or external integrations
- There's significant data transformation or business rules processing

In most cases, a repository alone is sufficient. Only create a handler when there's a clear need for complex business logic that can't be handled appropriately in the repository layer.

## Type Structure

Each feature should have the following type definitions:

1. Base entity interface (e.g., `Country`, `State`)
2. Creation payload (e.g., `CreateCountryPayload`, `CreateStatePayload`)
3. Update payload (e.g., `UpdateCountryPayload`, `UpdateStatePayload`)
4. List response (e.g., `Countries`, `States`)
5. Repository interface (e.g., `CountryRepository`, `StateRepository`)

## Specific Rules

### General Rules

1. Each feature should be contained in its own directory inside the relevant subsystem
2. All files in a feature should be prefixed with the feature name
3. Keep feature-specific code, including schema definitions, within the feature directory
4. Maximum file size should not exceed 500 lines
5. Use meaningful and descriptive names for all entities
6. Follow TypeScript naming conventions strictly
7. Extend from base repository for common CRUD operations
8. Implement feature-specific validations in the repository

For detailed documentation of each component, see:

- [typescript-patterns.mdc](mdc:.cursor/rules/typescript-patterns.mdc) - General TypeScript patterns
- [controller-patterns.mdc](mdc:.cursor/rules/controller-patterns.mdc) - Patterns for controllers
- [types-patterns.mdc](mdc:.cursor/rules/types-patterns.mdc) - Patterns for type definitions
- [error-handling.mdc](mdc:.cursor/rules/error-handling.mdc) - Error handling
- [testing-patterns.mdc](mdc:.cursor/rules/testing-patterns.mdc) - Testing standards and patterns
- [database-patterns.mdc](mdc:.cursor/rules/database-patterns.mdc) - - Database standards and patterns

## Creating New Features

### Adding a New Feature to an Existing Subsystem

1. Create a new directory with the feature name inside the subsystem (e.g., `inventory/cities/`)
2. Create the standard feature files with appropriate naming:
   - `cities.repository.ts` (Repository)
   - `cities.controller.ts` (API endpoints)
   - `cities.types.ts` (Types and DTOs)
   - `cities.schema.ts` (Database schema)
   - `cities.controller.spec.ts` (Tests)
3. Export the schema in the root `db/schema.ts` file
4. Implement the feature following the established patterns

### Creating a New Subsystem

1. Create a new directory in `apps/server/` for the subsystem (e.g., `logistics/`)
2. Add feature directories inside the subsystem
3. Reuse the shared utilities from `server/shared/`
4. Utilize the root-level database configuration

### Repository Implementation Best Practices

1. **Base Repository Usage**:

   - Extend from base repository for common CRUD operations
   - Override methods only when custom behavior is needed
   - Implement feature-specific validations

2. **Validation Rules**:

   - Implement uniqueness constraints
   - Add field-level validations
   - Handle complex validation scenarios

3. **Error Handling**:
   - Use standard error types from shared error utilities
   - Provide clear error messages
   - Handle edge cases appropriately

### Database Schema Best Practices

1. **Schema Definition**:

   - Define tables with clear, descriptive column names
   - Use appropriate data types for columns
   - Define relationships using foreign keys
   - Document complex relationships or constraints

2. **Schema References**:

   - When referencing schemas from other features, import them directly
   - Example: `import { countries } from '../countries/countries.schema';`

3. **Schema Exports**:
   - Export schema definitions for use in other features
   - Add new schema exports to `db/schema.ts` for migration generation

## Important Guidelines

1. Code Organization

   - Maintain consistent file structure
   - Follow naming conventions
   - Keep responsibilities separated
   - Document complex logic
   - Use strict TypeScript types
   - Handle errors consistently
   - Follow Locality of Behavior by keeping related code together

2. Code Quality

   - Write unit tests for all features
   - Maintain 80% or higher test coverage
   - Use TypeScript strict mode
   - Follow ESLint rules
   - Use Prettier for formatting
   - Review code before committing

3. Performance

   - Optimize database queries
   - Use proper indexing
   - Implement caching when necessary
   - Handle pagination properly

4. Security
   - Validate all inputs
   - Sanitize all outputs
   - Use proper authentication
   - Implement authorization
   - Handle sensitive data appropriately
   - Follow security best practices

