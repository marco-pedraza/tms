---
description: Patterns for services in Encore applications
globs: *.handler.ts
alwaysApply: false
---
# Handler Patterns

## Overview

Handlers in our Encore application are optional service layers that encapsulate complex business logic. They are used when operations require more than simple CRUD operations, which are handled directly by repositories.

## When to Use Handlers

1. **Use Handlers When:**

   - Complex business logic is required
   - Multiple repositories need to be coordinated
   - Additional validations beyond basic CRUD are needed
   - Operations involve multiple steps or transactions
   - Business rules need to be enforced

2. **Skip Handlers When:**
   - Only basic CRUD operations are needed
   - No complex business logic is involved
   - Single repository operations are sufficient

## Rules for Handlers

1. Handlers should contain:

   - Complex business logic
   - Multi-step operations
   - Cross-repository operations
   - Advanced validation rules
   - Domain-specific business rules

2. Handlers should NOT:

   - Directly access the database (use repositories instead)
   - Duplicate repository logic
   - Handle basic CRUD operations

3. Keep methods focused and descriptive:

   - Use clear method naming that describes the business operation
   - Keep methods small and single-purpose
   - Document complex business rules with JSDoc

4. Error handling:

   - Use appropriate error classes from shared error utilities
   - Add context to repository errors when needed
   - Handle business rule violations explicitly

5. Export the handler as a singleton instance using a factory function

## Implementation Example

```typescript
import { NotFoundError, ValidationError } from '../../shared/errors';
import { createProductRepository } from '../products/product.repository';
import { createInventoryRepository } from '../inventory/inventory.repository';
import type { CreateOrderPayload, Order, OrderItem } from './order.types';

/**
 * Creates a handler for managing orders with complex business logic
 * @returns {Object} An object containing order-specific operations
 */
export const createOrderHandler = () => {
  const productRepository = createProductRepository();
  const inventoryRepository = createInventoryRepository();

  /**
   * Validates order items availability
   * @param items Order items to validate
   * @throws {ValidationError} If products are not available
   */
  const validateOrderItems = async (items: OrderItem[]): Promise<void> => {
    for (const item of items) {
      // Check product exists
      const product = await productRepository.findOne(item.productId);

      // Check inventory level
      const inventory = await inventoryRepository.findByProductId(item.productId);

      if (!inventory || inventory.quantity < item.quantity) {
        throw new ValidationError(`Insufficient stock for product: ${product.name}`);
      }
    }
  };

  /**
   * Updates inventory levels for ordered items
   * @param items Items to update inventory for
   * @param trx Transaction instance
   */
  const updateInventoryLevels = async (items: OrderItem[], trx?: unknown): Promise<void> => {
    for (const item of items) {
      await inventoryRepository.decrementStock(item.productId, item.quantity, trx);
    }
  };

  /**
   * Creates a new order with inventory validation and stock updates
   * @param data Order creation payload
   * @throws {ValidationError} If products are not available
   * @returns Created order
   */
  const createOrder = async (data: CreateOrderPayload): Promise<Order> => {
    try {
      // Validate all products exist and have sufficient stock
      await validateOrderItems(data.items);

      // Start transaction for order creation and inventory updates
      const order = await orderRepository.transaction(async (trx) => {
        // Create the order
        const newOrder = await orderRepository.create(data, trx);

        // Update inventory for each item
        await updateInventoryLevels(data.items, trx);

        return newOrder;
      });

      return order;
    } catch (error) {
      if (error instanceof Error) {
        throw new ValidationError(error.message);
      }
      throw error;
    }
  };

  /**
   * Cancels an order and restores inventory
   */
  const cancelOrder = async (orderId: number): Promise<Order> => {
    const order = await orderRepository.findOne(orderId);

    if (order.status === 'CANCELLED') {
      throw new ValidationError('Order is already cancelled');
    }

    if (order.status === 'DELIVERED') {
      throw new ValidationError('Cannot cancel a delivered order');
    }

    return orderRepository.transaction(async (trx) => {
      // Update order status
      const cancelledOrder = await orderRepository.update(orderId, { status: 'CANCELLED' }, trx);

      // Restore inventory levels
      for (const item of order.items) {
        await inventoryRepository.incrementStock(item.productId, item.quantity, trx);
      }

      return cancelledOrder;
    });
  };

  return {
    createOrder,
    cancelOrder,
  };
};

// Export the handler instance
export const orderHandler = createOrderHandler();
```

## Best Practices

1. **Functional Approach**

   - Use factory functions to create handlers
   - Keep helper functions inside the closure
   - Return only the public interface
   - Maintain clean separation of concerns

2. **Business Logic Focus**

   - Implement complex business rules
   - Handle multi-step operations
   - Coordinate between multiple repositories
   - Manage transactions when needed

3. **Error Handling**

   - Use domain-specific errors
   - Add context to repository errors
   - Handle business rule violations
   - Maintain transaction integrity

4. **Code Organization**

   - Keep methods focused
   - Use clear naming
   - Document complex logic
   - Follow single responsibility principle

5. **Testing**

   - Mock repository dependencies
   - Test business rules thoroughly
   - Cover error scenarios
   - Verify transaction rollbacks

6. **Performance**
   - Use transactions appropriately
   - Optimize database operations
   - Handle bulk operations efficiently
   - Consider caching when needed

