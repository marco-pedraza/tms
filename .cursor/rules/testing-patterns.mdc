---
description: Patterns for testing in Encore applications
globs: apps/server/*/*/*.spec.ts, apps/server/*/*/*.test.ts
alwaysApply: false
---
# Testing Patterns

## Overview

Tests in our Encore application focus on controllers and follow a consistent structure for both success and error scenarios.

## Framework and Structure

```typescript
import { expect, describe, test, beforeAll, afterAll } from 'vitest';
```

Tests are organized into:

- One `feature.controller.spec.ts` file per feature
- Test data setup at the beginning
- Cleanup in `afterAll`
- Test groups by scenario

## Base Structure

```typescript
describe('Feature Controller', () => {
  // Test data
  const testData = {
    name: 'Test Entity',
    code: 'TE',
  };

  // IDs for cleanup
  let createdId: number;

  // Cleanup
  afterAll(async () => {
    if (createdId) {
      try {
        await deleteEntity({ id: createdId });
      } catch (error) {
        console.log('Error cleaning up:', error);
      }
    }
  });

  describe('success scenarios', () => {
    // CRUD tests
  });

  describe('error scenarios', () => {
    // Error handling tests
  });

  describe('pagination', () => {
    // Pagination tests
  });
});
```

## Implementation Example

```typescript
import { expect, describe, test, beforeAll, afterAll } from 'vitest';
import {
  createEntity,
  getEntity,
  listEntities,
  updateEntity,
  deleteEntity,
} from './entity.controller';

describe('Entity Controller', () => {
  const testEntity = {
    name: 'Test Entity',
    code: 'TE',
    active: true,
  };

  let createdEntityId: number;

  afterAll(async () => {
    if (createdEntityId) {
      try {
        await deleteEntity({ id: createdEntityId });
      } catch (error) {
        console.log('Error cleaning up test entity:', error);
      }
    }
  });

  describe('success scenarios', () => {
    test('should create a new entity', async () => {
      const response = await createEntity(testEntity);
      createdEntityId = response.id;

      expect(response).toBeDefined();
      expect(response.id).toBeDefined();
      expect(response.name).toBe(testEntity.name);
      expect(response.code).toBe(testEntity.code);
      expect(response.active).toBe(testEntity.active);
      expect(response.createdAt).toBeDefined();
    });

    test('should retrieve an entity by ID', async () => {
      const response = await getEntity({ id: createdEntityId });

      expect(response).toBeDefined();
      expect(response.id).toBe(createdEntityId);
      expect(response.name).toBe(testEntity.name);
    });

    test('should update an entity', async () => {
      const updatedName = 'Updated Test Entity';
      const response = await updateEntity({
        id: createdEntityId,
        name: updatedName,
      });

      expect(response).toBeDefined();
      expect(response.id).toBe(createdEntityId);
      expect(response.name).toBe(updatedName);
    });

    test('should delete an entity', async () => {
      const entityToDelete = await createEntity({
        name: 'Entity To Delete',
        code: 'ETD',
      });

      await expect(deleteEntity({ id: entityToDelete.id })).resolves.not.toThrow();

      await expect(getEntity({ id: entityToDelete.id })).rejects.toThrow();
    });
  });

  describe('error scenarios', () => {
    test('should handle not found errors', async () => {
      await expect(getEntity({ id: 9999 })).rejects.toThrow();
    });

    test('should handle duplicate errors', async () => {
      await expect(
        createEntity({
          name: testEntity.name,
          code: testEntity.code,
        })
      ).rejects.toThrow();
    });
  });
});
```

## Scenarios to Test

1. **CRUD Operations**

   - Create: Verify creation and response
   - Read: Get by ID and list
   - Update: Modify and verify changes
   - Delete: Remove and verify non-existence

2. **Error Handling**

   - Not Found (non-existent ID)
   - Duplicates (uniqueness)
   - Invalid dependencies

3. **Pagination**
   - Default parameters
   - Page and pageSize
   - Sorting
   - Non-paginated list

## Validation Testing Approach

In our Encore-based application, input validation is handled automatically by the Encore runtime based on the type definitions and validators (such as `MinLen`, `MatchesRegexp`, etc.) specified in our `.types.ts` files.

Because of this architecture:

1. We do not test basic validations in controller tests (handled by Encore runtime)
2. Validation tests would require integration tests with Encore runtime
3. Focus on business logic validation in the service layer

## Best Practices

1. **Test Independence**

   - Each test should be independent
   - Setup and teardown handled appropriately
   - Clean up all created resources

2. **Test Organization**

   - Group related tests logically
   - Separate success and error scenarios
   - Keep test files focused
   - Use descriptive test names

3. **Assertions**

   - Make specific assertions about response structure
   - Test both presence and values of fields
   - Use appropriate matchers
   - Verify side effects when relevant

4. **Dependencies**

   - Create required dependencies in `beforeAll`
   - Clean up in reverse order in `afterAll`
   - Handle resource dependencies explicitly

5. **Error Testing**

   - Test appropriate error responses
   - Focus on business/domain errors
   - Verify error handling in edge cases
   - Skip framework validation tests

6. **Data Management**
   - Use realistic test data
   - Clean up all created data
   - Keep track of IDs for cleanup
   - Avoid test data pollution
