---
description: Patterns for type definitions in Encore applications
globs: ['apps/server/*/*/*.types.ts']
alwaysApply: false
---
# Types Patterns

## Core Type Structure

Each feature should have these core type definitions:

1. **Base Entity Interface** - Represents the database entity
   ```typescript
   export interface Country {
     id: number;
     name: string;
     code: string;
     active: boolean;
     createdAt: Date | null;
     updatedAt: Date | null;
   }
   ```

2. **Create Payload** - DTO for creating new entities with validations
   ```typescript
   export interface CreateCountryPayload {
     name: string & MinLen<1> & MatchesRegexp<'.*\\S.*'>;
     code: string & MinLen<1> & MatchesRegexp<'.*\\S.*'>;
     active?: boolean;
   }
   ```

3. **Update Payload** - DTO for updating entities with all fields optional
   ```typescript
   export interface UpdateCountryPayload {
     name?: string & MinLen<1>;
     code?: string & MinLen<1>;
     active?: boolean;
   }
   ```

4. **Query Options** - Filtering and ordering parameters
   ```typescript
   export interface CountriesQueryOptions {
     orderBy?: { field: keyof Country; direction: 'asc' | 'desc' }[];
     filters?: Partial<Country>;
   }
   ```

5. **List Response** - Response for listing entities
   ```typescript
   export interface Countries {
     countries: Country[];
   }
   ```

6. **Pagination Parameters** - Extends PaginationParams with query options
   ```typescript
   export interface PaginationParamsCountries
     extends PaginationParams, CountriesQueryOptions {}
   ```

7. **Paginated Response** - Generic paginated result type
   ```typescript
   export type PaginatedCountries = PaginatedResult<Country>;
   ```

## Additional Type Patterns

### 1. Entity Relationships

For entities with relationships, define extended interfaces:

```typescript
// Base entity
export interface Terminal {
  id: number;
  name: string;
  cityId: number;
  // ...other properties
}

// Extended entity with relationships
export interface TerminalWithCity extends Terminal {
  city: City;
}
```

### 2. Compound Types

When a feature has complex operations, define specialized payload types:

```typescript
// Basic route creation payload
export interface CreateRoutePayload {
  name: string;
  distance: number;
  // ...other fields
}

// Specialized payload for creating a simple route with pathway
export interface CreateSimpleRoutePayload
  extends Omit<
    CreateRoutePayload,
    'pathwayId' | 'distance' | 'totalDistance'
  > {
  // Additional fields specific to this operation
  pathwayName?: string;
  isCompound: false;
}
```

### 3. Complex Entity Types

For entities with nested structures, define helper interfaces:

```typescript
// Helper interface for nested structure
export interface Facility {
  name: string;
  description?: string;
  icon?: string;
}

// Helper interface for nested structure
export interface TimeSlot {
  open: string;
  close: string;
}

// Main entity interface using nested types
export interface Terminal {
  // ...base fields
  facilities?: Facility[];
  operatingHours?: OperatingHours;
}
```

## Type Best Practices

1. **Documentation**
   - Use JSDoc comments for all entity interfaces and complex types
   - Document validation constraints directly in JSDoc
   - Add `@default` tags for fields with default values

2. **Validation**
   - Use Encore's validation decorators on input DTOs:
     - `MinLen<1>` for required string fields
     - `MatchesRegexp<'.*\\S.*'>` for non-empty strings
     - `Min<1>` for required IDs
     - `Min<0>` for non-negative numeric values

3. **Naming Conventions**
   - Use consistent naming patterns:
     - Entity interface: `Feature` (ex: `Country`, `Terminal`)
     - Create DTO: `CreateFeaturePayload` (ex: `CreateCountryPayload`)
     - Update DTO: `UpdateFeaturePayload` (ex: `UpdateTerminalPayload`)
     - List response: `Features` (ex: `Countries`, `Terminals`)
     - With relations: `FeatureWithRelation` (ex: `TerminalWithCity`)
     - Query options: `FeaturesQueryOptions` (ex: `TerminalsQueryOptions`)
     - Pagination params: `PaginationParamsFeatures` (ex: `PaginationParamsTerminals`)

4. **Type Composition**
   - Use `extends` for specializing interfaces
   - Use `Omit<T, K>` to exclude fields when extending
   - Use `Partial<T>` for making all fields optional
   - Use `Pick<T, K>` to select specific fields
   - Use union types for fields with multiple possible values

5. **Shared Types**
   - Import shared pagination types from `../../shared/types.ts`
   - Import related entity types (ex: `import { City } from '../cities/cities.types';`)
   - Use `PaginatedResult<T>` for all paginated responses

## Type Creation Checklist

- [ ] Create base entity interface with all DB fields
- [ ] Add detailed JSDoc comments to all entity properties
- [ ] Create CreateXPayload with appropriate validations
- [ ] Create UpdateXPayload with all fields optional
- [ ] Define query options interface with orderBy and filters
- [ ] Create list response interface (ex: `Features`) that returns array of entities
- [ ] Define pagination parameters that extend from shared types
- [ ] Create extended interfaces for entities with relationships

