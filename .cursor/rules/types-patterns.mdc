---
description: 
globs: *.types.ts
alwaysApply: false
---
# Types Patterns

## Core Type Structure

Each feature should have these core type definitions:

1. **Base Entity Interface** - Represents the database entity
   ```typescript
   export interface Country {
     id: number;
     name: string;
     code: string;
     active: boolean;
     createdAt: Date | string | null;
     updatedAt: Date | string | null;
   }
   ```

2. **Create Payload** - DTO for creating new entities with validations
   ```typescript
   export interface CreateCountryPayload {
     name: string & MinLen<1> & MatchesRegexp<'.*\\S.*'>;
     code: string & MinLen<1> & MatchesRegexp<'.*\\S.*'>;
     active?: boolean;
   }
   ```

3. **Update Payload** - DTO for updating entities with all fields optional
   ```typescript
   export interface UpdateCountryPayload {
     name?: string & MinLen<1>;
     code?: string & MinLen<1>;
     active?: boolean;
   }
   ```

## Unified API Response Patterns

Use standardized response patterns from shared types for consistency:

4. **List Query Parameters** - Non-paginated list queries
   ```typescript
   import {
     ListQueryParams,
     ListQueryResult,
     PaginatedListQueryParams,
     PaginatedListQueryResult,
   } from '../../shared/types';

  export type ListCountriesQueryParams = ListQueryParams<Country>;
  export type ListCountriesResult = ListQueryResult<Country>;
   ```

5. **Paginated Query Parameters** - Paginated queries
   ```typescript
  export type PaginatedListCountriesQueryParams =
    PaginatedListQueryParams<Country>;
  export type PaginatedListCountriesResult = PaginatedListQueryResult<Country>;
   ```

## Additional Type Patterns

### 1. Entity Relationships

For entities with relationships, define extended interfaces:

```typescript
// Base entity
export interface Terminal {
  id: number;
  name: string;
  cityId: number;
  // ...other properties
}

// Extended entity with relationships
export interface TerminalWithCity extends Terminal {
  city: City;
}
```

### 2. Compound Types

When a feature has complex operations, define specialized payload types:

```typescript
// Basic route creation payload
export interface CreateRoutePayload {
  name: string;
  distance: number;
  // ...other fields
}

// Specialized payload for creating a simple route with pathway
export interface CreateSimpleRoutePayload
  extends Omit<
    CreateRoutePayload,
    'pathwayId' | 'distance' | 'totalDistance'
  > {
  // Additional fields specific to this operation
  pathwayName?: string;
  isCompound: false;
}
```

### 3. Complex Entity Types

For entities with nested structures, define helper interfaces:

```typescript
// Helper interface for nested structure
export interface Facility {
  name: string;
  description?: string;
  icon?: string;
}

// Helper interface for nested structure
export interface TimeSlot {
  open: string;
  close: string;
}

// Main entity interface using nested types
export interface Terminal {
  // ...base fields
  facilities?: Facility[];
  operatingHours?: OperatingHours;
}
```

## Type Best Practices

1. **Documentation**
   - Use JSDoc comments for all entity interfaces and complex types
   - Document validation constraints directly in JSDoc
   - Add `@default` tags for fields with default values

2. **Validation**
   - Use Encore's validation decorators on input DTOs:
     - `MinLen<1>` for required string fields
     - `MatchesRegexp<'.*\\S.*'>` for non-empty strings
     - `Min<1>` for required IDs
     - `Min<0>` for non-negative numeric values

3. **Naming Conventions**
   - Use consistent naming patterns:
     - Entity interface: `Feature` (ex: `Country`, `Terminal`)
     - Create DTO: `CreateFeaturePayload` (ex: `CreateCountryPayload`)
     - Update DTO: `UpdateFeaturePayload` (ex: `UpdateTerminalPayload`)
     - List params: `ListFeaturesQueryParams` (ex: `ListCountriesQueryParams`)
     - List result: `ListFeaturesResult` (ex: `ListCountriesResult`)
     - Paginated params: `PaginatedListFeaturesQueryParams`
     - Paginated result: `PaginatedListFeaturesResult`
     - With relations: `FeatureWithRelation` (ex: `TerminalWithCity`)

4. **Type Composition**
   - Use `extends` for specializing interfaces
   - Use `Omit<T, K>` to exclude fields when extending
   - Use `Partial<T>` for making all fields optional
   - Use `Pick<T, K>` to select specific fields
   - Use union types for fields with multiple possible values

5. **Shared Types**
   - Always import shared types from `../../shared/types.ts`
   - Import related entity types (ex: `import { City } from '../cities/cities.types';`)
   - Use unified response patterns with `data` property
   - Use `ListQueryResult<T>` and `PaginatedListQueryResult<T>` consistently

## Type Creation Checklist

- [ ] Create base entity interface with all DB fields
- [ ] Add detailed JSDoc comments to all entity properties
- [ ] Create CreateXPayload with appropriate validations
- [ ] Create UpdateXPayload with all fields optional
- [ ] Create unified list query parameters type alias using ListQueryParams<T>
- [ ] Create unified list result type alias using ListQueryResult<T>
- [ ] Create unified paginated parameters type alias using PaginatedListQueryParams<T>
- [ ] Create unified paginated result type alias using PaginatedListQueryResult<T>
- [ ] Create extended interfaces for entities with relationships
- [ ] Import all shared types from ../../shared/types.ts

