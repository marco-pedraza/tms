---
description: Patterns for services in Encore applications
globs: *.use-cases.ts
alwaysApply: false
---
# Use Case Patterns

## Overview

Use cases in our Encore application are optional service layers that encapsulate complex business logic. They are used when operations require more than simple CRUD operations, which are handled directly by repositories.

## When to Use Use Cases

1. **Use Use Cases When:**

   - Complex business logic is required
   - Multiple repositories need to be coordinated
   - Additional validations beyond basic CRUD are needed
   - Operations involve multiple steps or transactions
   - Business rules need to be enforced
   - Data needs to be transformed between related entities
   - Operations need to work across entity boundaries

2. **Skip Use Cases When:**
   - Only basic CRUD operations are needed
   - No complex business logic is involved
   - Single repository operations are sufficient
   - No data transformation or cross-entity logic is required

## Rules for Use Cases

1. Use cases should contain:

   - Complex business logic
   - Multi-step operations
   - Cross-repository operations
   - Advanced validation rules
   - Domain-specific business rules
   - Transaction management across multiple repositories

2. Use cases should NOT:

   - Directly access the database (use repositories instead)
   - Duplicate repository logic
   - Handle basic CRUD operations without additional complexity

3. Keep methods focused and descriptive:

   - Use clear method naming that describes the business operation
   - Keep methods small and single-purpose
   - Document complex business rules with JSDoc
   - Define private helper functions for reusable logic

4. Error handling:

   - Define a constant object for domain-specific error messages
   - Use appropriate error classes from shared error utilities
   - Add context to repository errors when needed
   - Handle business rule violations explicitly

5. Export the use case as a singleton instance using a factory function

## Implementation Example

```typescript
import { ValidationError } from '../../shared/errors';
import { createProductRepository } from '../products/product.repository';
import { createInventoryRepository } from '../inventory/inventory.repository';
import type { CreateOrderPayload, Order, OrderItem } from './order.types';

// Define domain-specific error messages as constants
const ORDER_ERRORS = {
  INSUFFICIENT_STOCK: (product: string) => `Insufficient stock for product: ${product}`,
  ALREADY_CANCELLED: 'Order is already cancelled',
  CANNOT_CANCEL_DELIVERED: 'Cannot cancel a delivered order',
  VALIDATION_FAILED: 'Order validation failed'
};

/**
 * Creates a use case for managing orders with complex business logic
 * @returns {Object} An object containing order-specific operations
 */
export const createOrderUseCase = () => {
  const productRepository = createProductRepository();
  const inventoryRepository = createInventoryRepository();
  const orderRepository = createOrderRepository();

  /**
   * Validates order items availability
   * @param items Order items to validate
   * @throws {ValidationError} If products are not available
   */
  const validateOrderItems = async (items: OrderItem[]): Promise<void> => {
    for (const item of items) {
      // Check product exists
      const product = await productRepository.findOne(item.productId);

      // Check inventory level
      const inventory = await inventoryRepository.findByProductId(item.productId);

      if (!inventory || inventory.quantity < item.quantity) {
        throw new ValidationError(ORDER_ERRORS.INSUFFICIENT_STOCK(product.name));
      }
    }
  };

  /**
   * Updates inventory levels for ordered items
   * @param items Items to update inventory for
   * @param trx Transaction instance
   */
  const updateInventoryLevels = async (items: OrderItem[], trx?: unknown): Promise<void> => {
    // Create scoped repository with the transaction
    const txInventoryRepo = inventoryRepository.withTransaction(trx);

    for (const item of items) {
      await txInventoryRepo.decrementStock(item.productId, item.quantity);
    }
  };

  /**
   * Creates a new order with inventory validation and stock updates
   * @param data Order creation payload
   * @throws {ValidationError} If products are not available
   * @returns Created order
   */
  const createOrder = async (data: CreateOrderPayload): Promise<Order> => {
    try {
      // Validate all products exist and have sufficient stock
      await validateOrderItems(data.items);

      // Start transaction for order creation and inventory updates
      return orderRepository
        .transaction(async (txOrderRepo, trx) => {
          // Create the order
          const newOrder = await txOrderRepo.create(data);

          // Update inventory for each item
          await updateInventoryLevels(data.items, trx);

          // Return the order ID for post-processing
          return newOrder.id;
        })
        .then((orderId) => {
          // After transaction completes successfully, retrieve order with full details
          return orderRepository.findOneWithDetails(orderId);
        });
    } catch (error) {
      if (error instanceof Error) {
        throw new ValidationError(error.message);
      }
      throw error;
    }
  };

  /**
   * Cancels an order and restores inventory
   * @param orderId The ID of the order to cancel
   * @returns The cancelled order
   * @throws {ValidationError} If the order cannot be cancelled
   */
  const cancelOrder = async (orderId: number): Promise<Order> => {
    const order = await orderRepository.findOne(orderId);

    if (order.status === 'CANCELLED') {
      throw new ValidationError(ORDER_ERRORS.ALREADY_CANCELLED);
    }

    if (order.status === 'DELIVERED') {
      throw new ValidationError(ORDER_ERRORS.CANNOT_CANCEL_DELIVERED);
    }

    return orderRepository
      .transaction(async (txOrderRepo, trx) => {
        // Create scoped repository with the transaction
        const txInventoryRepo = inventoryRepository.withTransaction(trx);

        // Update order status
        await txOrderRepo.update(orderId, { status: 'CANCELLED' });

        // Restore inventory levels
        for (const item of order.items) {
          await txInventoryRepo.incrementStock(item.productId, item.quantity);
        }

        // Return the order ID for post-processing
        return orderId;
      })
      .then((orderId) => {
        // After transaction completes successfully, retrieve order with full details
        return orderRepository.findOneWithDetails(orderId);
      });
  };

  /**
   * Creates a compound order from multiple existing orders
   * @param orderIds Array of order IDs to combine
   * @param customerId Customer ID for the compound order
   * @returns The created compound order
   * @throws {ValidationError} If orders cannot be combined
   */
  const createCompoundOrder = async (
    orderIds: number[],
    customerId: number
  ): Promise<Order> => {
    // Validate the orders exist and are valid for combining
    const orders = await Promise.all(
      orderIds.map(id => orderRepository.findOne(id))
    );

    // Validate all orders belong to the same customer
    if (!orders.every(order => order.customerId === customerId)) {
      throw new ValidationError('Orders must belong to the same customer');
    }

    // Create compound order transaction
    return orderRepository
      .transaction(async (txOrderRepo, trx) => {
        // Create compound order
        const compoundOrder = await txOrderRepo.create({
          customerId,
          status: 'PENDING',
          isCompound: true,
          items: orders.flatMap(order => order.items),
          // Additional compound order fields
        });

        // Update source orders
        for (const order of orders) {
          await txOrderRepo.update(order.id, {
            parentOrderId: compoundOrder.id,
            status: 'COMPOUNDED'
          });
        }

        return compoundOrder.id;
      })
      .then((orderId) => {
        // After transaction completes, retrieve compound order with full details
        return orderRepository.findOneWithFullDetails(orderId);
      });
  };

  return {
    createOrder,
    cancelOrder,
    createCompoundOrder
  };
};

// Export the use case instance
export const orderUseCase = createOrderUseCase();
```

## Best Practices

1. **Functional Approach**

   - Use factory functions to create use cases
   - Keep helper functions inside the closure
   - Return only the public interface
   - Maintain clean separation of concerns

2. **Business Logic Focus**

   - Implement complex business rules
   - Handle multi-step operations
   - Coordinate between multiple repositories
   - Manage transactions when needed

3. **Error Handling**

   - Define domain-specific error messages as constants
   - Use appropriate error classes (ValidationError, NotFoundError, etc.)
   - Add context to repository errors
   - Handle business rule violations with clear messaging
   - Maintain transaction integrity

4. **Transaction Management**

   - Use the primary repository's transaction for the main entity
   - Use the `.withTransaction(tx)` pattern for secondary repositories
   - Structure transaction blocks with clear steps
   - Return minimal data from transaction blocks (usually just IDs)
   - Use `.then()` for post-transaction retrieval of complete entities

5. **Compound Operations**

   - Implement patterns for combining related entities
   - Use clear validation before starting transactions
   - Define relationships between composite and component entities
   - Maintain data integrity across entity boundaries

6. **Code Organization**

   - Keep methods focused on a single responsibility
   - Use clear, descriptive naming
   - Document complex logic with JSDoc
   - Group related functions together

7. **Testing**

   - Mock repository dependencies
   - Test business rules thoroughly
   - Cover error scenarios
   - Verify transaction rollbacks
   - Test compound operations carefully

8. **Performance**
   - Use transactions efficiently
   - Optimize database operations
   - Handle bulk operations in batches
   - Consider caching for frequently accessed data
   - Minimize redundant database calls
