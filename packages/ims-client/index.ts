// Code generated by the Encore v1.48.9 client generator. DO NOT EDIT.

// Disable eslint, jshint, and jslint for this file.
/* eslint-disable */
/* jshint ignore:start */
/*jslint-disable*/

/**
 * BaseURL is the base URL for calling the Encore application's API.
 */
export type BaseURL = string

export const Local: BaseURL = "http://localhost:4000"

/**
 * Environment returns a BaseURL for calling the cloud environment with the given name.
 */
export function Environment(name: string): BaseURL {
    return `https://${name}-server-nest-8sci.encr.app`
}

/**
 * PreviewEnv returns a BaseURL for calling the preview environment with the given PR number.
 */
export function PreviewEnv(pr: number | string): BaseURL {
    return Environment(`pr${pr}`)
}

const BROWSER = typeof globalThis === "object" && ("window" in globalThis);

/**
 * Client is an API client for the server-nest-8sci Encore application.
 */
export default class Client {
    public readonly inventory: inventory.ServiceClient
    public readonly users: users.ServiceClient
    private readonly options: ClientOptions
    private readonly target: string


    /**
     * Creates a Client for calling the public and authenticated APIs of your Encore application.
     *
     * @param target  The target which the client should be configured to use. See Local and Environment for options.
     * @param options Options for the client
     */
    constructor(target: BaseURL, options?: ClientOptions) {
        this.target = target
        this.options = options ?? {}
        const base = new BaseClient(this.target, this.options)
        this.inventory = new inventory.ServiceClient(base)
        this.users = new users.ServiceClient(base)
    }

    /**
     * Creates a new Encore client with the given client options set.
     *
     * @param options Client options to set. They are merged with existing options.
     **/
    public with(options: ClientOptions): Client {
        return new Client(this.target, {
            ...this.options,
            ...options,
        })
    }
}

/**
 * ClientOptions allows you to override any default behaviour within the generated Encore client.
 */
export interface ClientOptions {
    /**
     * By default the client will use the inbuilt fetch function for making the API requests.
     * however you can override it with your own implementation here if you want to run custom
     * code on each API request made or response received.
     */
    fetcher?: Fetcher

    /** Default RequestInit to be used for the client */
    requestInit?: Omit<RequestInit, "headers"> & { headers?: Record<string, string> }

    /**
     * Allows you to set the authentication data to be used for each
     * request either by passing in a static object or by passing in
     * a function which returns a new object for each request.
     */
    auth?: users.AuthParams | AuthDataGenerator
}

export namespace inventory {

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.assignAmenitiesToInstallation = this.assignAmenitiesToInstallation.bind(this)
            this.assignAmenitiesToServiceType = this.assignAmenitiesToServiceType.bind(this)
            this.assignCitiesToPopulation = this.assignCitiesToPopulation.bind(this)
            this.assignCityToPopulation = this.assignCityToPopulation.bind(this)
            this.assignEventTypesToInstallationType = this.assignEventTypesToInstallationType.bind(this)
            this.assignEventsToNode = this.assignEventsToNode.bind(this)
            this.assignLabelsToNode = this.assignLabelsToNode.bind(this)
            this.createAmenity = this.createAmenity.bind(this)
            this.createBus = this.createBus.bind(this)
            this.createBusDiagramModel = this.createBusDiagramModel.bind(this)
            this.createBusDiagramModelZone = this.createBusDiagramModelZone.bind(this)
            this.createBusLine = this.createBusLine.bind(this)
            this.createBusModel = this.createBusModel.bind(this)
            this.createCity = this.createCity.bind(this)
            this.createCompoundRoute = this.createCompoundRoute.bind(this)
            this.createCountry = this.createCountry.bind(this)
            this.createDriver = this.createDriver.bind(this)
            this.createEventType = this.createEventType.bind(this)
            this.createInstallation = this.createInstallation.bind(this)
            this.createInstallationSchema = this.createInstallationSchema.bind(this)
            this.createInstallationType = this.createInstallationType.bind(this)
            this.createLabel = this.createLabel.bind(this)
            this.createNode = this.createNode.bind(this)
            this.createPathway = this.createPathway.bind(this)
            this.createPopulation = this.createPopulation.bind(this)
            this.createRoute = this.createRoute.bind(this)
            this.createSeatDiagramZone = this.createSeatDiagramZone.bind(this)
            this.createServiceType = this.createServiceType.bind(this)
            this.createState = this.createState.bind(this)
            this.createTransporter = this.createTransporter.bind(this)
            this.deleteAmenity = this.deleteAmenity.bind(this)
            this.deleteBus = this.deleteBus.bind(this)
            this.deleteBusDiagramModel = this.deleteBusDiagramModel.bind(this)
            this.deleteBusDiagramModelZone = this.deleteBusDiagramModelZone.bind(this)
            this.deleteBusLine = this.deleteBusLine.bind(this)
            this.deleteBusModel = this.deleteBusModel.bind(this)
            this.deleteCity = this.deleteCity.bind(this)
            this.deleteCountry = this.deleteCountry.bind(this)
            this.deleteDriver = this.deleteDriver.bind(this)
            this.deleteEventType = this.deleteEventType.bind(this)
            this.deleteInstallation = this.deleteInstallation.bind(this)
            this.deleteInstallationSchema = this.deleteInstallationSchema.bind(this)
            this.deleteInstallationType = this.deleteInstallationType.bind(this)
            this.deleteLabel = this.deleteLabel.bind(this)
            this.deleteNode = this.deleteNode.bind(this)
            this.deletePathway = this.deletePathway.bind(this)
            this.deletePopulation = this.deletePopulation.bind(this)
            this.deleteRoute = this.deleteRoute.bind(this)
            this.deleteSeatDiagram = this.deleteSeatDiagram.bind(this)
            this.deleteSeatDiagramZone = this.deleteSeatDiagramZone.bind(this)
            this.deleteServiceType = this.deleteServiceType.bind(this)
            this.deleteState = this.deleteState.bind(this)
            this.deleteTransporter = this.deleteTransporter.bind(this)
            this.findPopulationByAssignedCity = this.findPopulationByAssignedCity.bind(this)
            this.getAmenity = this.getAmenity.bind(this)
            this.getBus = this.getBus.bind(this)
            this.getBusDiagramModel = this.getBusDiagramModel.bind(this)
            this.getBusDiagramModelSeats = this.getBusDiagramModelSeats.bind(this)
            this.getBusDiagramModelZone = this.getBusDiagramModelZone.bind(this)
            this.getBusLine = this.getBusLine.bind(this)
            this.getBusModel = this.getBusModel.bind(this)
            this.getCity = this.getCity.bind(this)
            this.getCountry = this.getCountry.bind(this)
            this.getDriver = this.getDriver.bind(this)
            this.getEventType = this.getEventType.bind(this)
            this.getInstallation = this.getInstallation.bind(this)
            this.getInstallationSchema = this.getInstallationSchema.bind(this)
            this.getInstallationType = this.getInstallationType.bind(this)
            this.getInstallationTypeSchema = this.getInstallationTypeSchema.bind(this)
            this.getLabel = this.getLabel.bind(this)
            this.getLabelsMetrics = this.getLabelsMetrics.bind(this)
            this.getNode = this.getNode.bind(this)
            this.getPathway = this.getPathway.bind(this)
            this.getPopulation = this.getPopulation.bind(this)
            this.getPopulationCities = this.getPopulationCities.bind(this)
            this.getRoute = this.getRoute.bind(this)
            this.getRouteWithFullDetails = this.getRouteWithFullDetails.bind(this)
            this.getSeatDiagram = this.getSeatDiagram.bind(this)
            this.getSeatDiagramSeats = this.getSeatDiagramSeats.bind(this)
            this.getSeatDiagramZone = this.getSeatDiagramZone.bind(this)
            this.getServiceType = this.getServiceType.bind(this)
            this.getState = this.getState.bind(this)
            this.getTimezone = this.getTimezone.bind(this)
            this.getTransporter = this.getTransporter.bind(this)
            this.listAmenities = this.listAmenities.bind(this)
            this.listAmenitiesPaginated = this.listAmenitiesPaginated.bind(this)
            this.listAvailableCities = this.listAvailableCities.bind(this)
            this.listBusDiagramModels = this.listBusDiagramModels.bind(this)
            this.listBusDiagramModelsPaginated = this.listBusDiagramModelsPaginated.bind(this)
            this.listBusLines = this.listBusLines.bind(this)
            this.listBusLinesPaginated = this.listBusLinesPaginated.bind(this)
            this.listBusModels = this.listBusModels.bind(this)
            this.listBusModelsPaginated = this.listBusModelsPaginated.bind(this)
            this.listBusValidNextStatuses = this.listBusValidNextStatuses.bind(this)
            this.listBuses = this.listBuses.bind(this)
            this.listBusesPaginated = this.listBusesPaginated.bind(this)
            this.listCities = this.listCities.bind(this)
            this.listCitiesPaginated = this.listCitiesPaginated.bind(this)
            this.listCountries = this.listCountries.bind(this)
            this.listCountriesPaginated = this.listCountriesPaginated.bind(this)
            this.listDriverValidNextStatuses = this.listDriverValidNextStatuses.bind(this)
            this.listDrivers = this.listDrivers.bind(this)
            this.listDriversPaginated = this.listDriversPaginated.bind(this)
            this.listEventTypes = this.listEventTypes.bind(this)
            this.listEventTypesPaginated = this.listEventTypesPaginated.bind(this)
            this.listInstallationSchemas = this.listInstallationSchemas.bind(this)
            this.listInstallationSchemasPaginated = this.listInstallationSchemasPaginated.bind(this)
            this.listInstallationTypes = this.listInstallationTypes.bind(this)
            this.listInstallationTypesPaginated = this.listInstallationTypesPaginated.bind(this)
            this.listInstallations = this.listInstallations.bind(this)
            this.listInstallationsPaginated = this.listInstallationsPaginated.bind(this)
            this.listLabels = this.listLabels.bind(this)
            this.listLabelsPaginated = this.listLabelsPaginated.bind(this)
            this.listNodes = this.listNodes.bind(this)
            this.listNodesPaginated = this.listNodesPaginated.bind(this)
            this.listPathways = this.listPathways.bind(this)
            this.listPathwaysPaginated = this.listPathwaysPaginated.bind(this)
            this.listPopulations = this.listPopulations.bind(this)
            this.listPopulationsPaginated = this.listPopulationsPaginated.bind(this)
            this.listRoutes = this.listRoutes.bind(this)
            this.listRoutesPaginated = this.listRoutesPaginated.bind(this)
            this.listServiceTypes = this.listServiceTypes.bind(this)
            this.listServiceTypesPaginated = this.listServiceTypesPaginated.bind(this)
            this.listStates = this.listStates.bind(this)
            this.listStatesPaginated = this.listStatesPaginated.bind(this)
            this.listTimezones = this.listTimezones.bind(this)
            this.listTransporters = this.listTransporters.bind(this)
            this.listTransportersPaginated = this.listTransportersPaginated.bind(this)
            this.listValidInitialStatuses = this.listValidInitialStatuses.bind(this)
            this.listZonesByDiagram = this.listZonesByDiagram.bind(this)
            this.listZonesByDiagramModel = this.listZonesByDiagramModel.bind(this)
            this.listZonesByDiagramModelPaginated = this.listZonesByDiagramModelPaginated.bind(this)
            this.listZonesByDiagramPaginated = this.listZonesByDiagramPaginated.bind(this)
            this.regenerateSeats = this.regenerateSeats.bind(this)
            this.searchRoutes = this.searchRoutes.bind(this)
            this.searchRoutesPaginated = this.searchRoutesPaginated.bind(this)
            this.syncInstallationSchemas = this.syncInstallationSchemas.bind(this)
            this.updateAmenity = this.updateAmenity.bind(this)
            this.updateBus = this.updateBus.bind(this)
            this.updateBusDiagramModel = this.updateBusDiagramModel.bind(this)
            this.updateBusDiagramModelZone = this.updateBusDiagramModelZone.bind(this)
            this.updateBusLine = this.updateBusLine.bind(this)
            this.updateBusModel = this.updateBusModel.bind(this)
            this.updateCity = this.updateCity.bind(this)
            this.updateCompoundRouteSegments = this.updateCompoundRouteSegments.bind(this)
            this.updateCountry = this.updateCountry.bind(this)
            this.updateDriver = this.updateDriver.bind(this)
            this.updateEventType = this.updateEventType.bind(this)
            this.updateInstallation = this.updateInstallation.bind(this)
            this.updateInstallationProperties = this.updateInstallationProperties.bind(this)
            this.updateInstallationSchema = this.updateInstallationSchema.bind(this)
            this.updateInstallationType = this.updateInstallationType.bind(this)
            this.updateLabel = this.updateLabel.bind(this)
            this.updateNode = this.updateNode.bind(this)
            this.updatePathway = this.updatePathway.bind(this)
            this.updatePopulation = this.updatePopulation.bind(this)
            this.updateSeatConfiguration = this.updateSeatConfiguration.bind(this)
            this.updateSeatDiagram = this.updateSeatDiagram.bind(this)
            this.updateSeatDiagramConfiguration = this.updateSeatDiagramConfiguration.bind(this)
            this.updateSeatDiagramZone = this.updateSeatDiagramZone.bind(this)
            this.updateServiceType = this.updateServiceType.bind(this)
            this.updateState = this.updateState.bind(this)
            this.updateTransporter = this.updateTransporter.bind(this)
        }

        /**
         * Assigns amenities to an installation (destructive operation).
         * This replaces all existing amenity assignments for the installation.
         * @param params - Object containing the installation ID and amenity IDs to assign
         * @param params.id - The ID of the installation to assign amenities to
         * @param params.amenityIds - Array of amenity IDs to assign
         * @returns {Promise<InstallationWithDetails>} The updated installation with new amenity assignments
         * @throws {APIError} If the installation is not found, amenities are not found, or assignment fails
         */
        public async assignAmenitiesToInstallation(id: number, params: {
    /**
     * Array of amenity IDs to assign to the installation
     * Only amenities with type = 'installation' are allowed
     * Must be positive numbers
     */
    amenityIds: number[]
}): Promise<installations.InstallationWithDetails> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/installations/${encodeURIComponent(id)}/amenities/assign`, JSON.stringify(params))
            return await resp.json() as installations.InstallationWithDetails
        }

        /**
         * Assigns amenities to a service type (destructive operation).
         * Replaces existing amenity assignments for the service type.
         */
        public async assignAmenitiesToServiceType(id: number, params: {
    /**
     * Amenity IDs to assign to the service type (replaces existing)
     */
    amenityIds: number[]
}): Promise<service_types.ServiceTypeWithAmenities> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/service-types/${encodeURIComponent(id)}/amenities/assign`, JSON.stringify(params))
            return await resp.json() as service_types.ServiceTypeWithAmenities
        }

        /**
         * Assigns cities to a population, replacing all existing assignments.
         * @param params - Object containing the population ID and city assignment data
         * @param params.id - The ID of the population to assign cities to
         * @param params.cityIds - Array of city IDs to assign
         * @returns {Promise<Population>} The updated population
         * @throws {APIError} If the population or any city is not found, or if there are duplicate city IDs
         */
        public async assignCitiesToPopulation(id: number, params: {
    /**
     * Array of city IDs to assign to the population
     * Must not contain duplicates
     */
    cityIds: number[]
}): Promise<populations.PopulationWithRelations> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/populations/${encodeURIComponent(id)}/cities/assign`, JSON.stringify(params))
            return await resp.json() as populations.PopulationWithRelations
        }

        /**
         * Assigns a city to a population.
         * @param params - Object containing the population ID and city ID
         * @param params.id - The ID of the population to assign the city to
         * @param params.cityId - The ID of the city to assign to the population
         * @returns {Promise<Population>} The updated population
         * @throws {APIError} If the population or city is not found or assignment fails
         */
        public async assignCityToPopulation(id: number, params: {
    cityId: number
}): Promise<populations.PopulationWithRelations> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/populations/${encodeURIComponent(id)}/cities/assign/one`, JSON.stringify(params))
            return await resp.json() as populations.PopulationWithRelations
        }

        /**
         * Assigns multiple event types to an installation type (destructive operation).
         * This replaces all existing event type assignments for the installation type.
         * @param params - Object containing the installation type ID and event type IDs to assign
         * @param params.id - The ID of the installation type to assign event types to
         * @param params.eventTypeIds - Array of event type IDs to assign
         * @returns {Promise<InstallationTypeWithRelations>} The updated installation type with new event type relationships
         * @throws {APIError} If the installation type is not found, event types are not found, or assignment fails
         */
        public async assignEventTypesToInstallationType(id: number, params: {
    /**
     * Array of event type IDs to assign
     */
    eventTypeIds: number[]
}): Promise<installation_types.InstallationTypeWithRelations> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/installation/types/${encodeURIComponent(id)}/event-types/assign`, JSON.stringify(params))
            return await resp.json() as installation_types.InstallationTypeWithRelations
        }

        /**
         * Assigns events to a node.
         * This is a destructive operation that replaces existing events.
         * @param params - Object containing the node ID and events to assign
         * @param params.id - The ID of the node to assign events to
         * @param params.events - Array of events to assign to the node
         * @returns {Promise<NodeWithRelations>} The updated node with its relations and assigned events
         * @throws {APIError} If the node is not found, validation fails, or assignment fails
         */
        public async assignEventsToNode(id: number, params: {
    events: nodes.NodeEventAssignmentPayload[]
}): Promise<nodes.NodeWithRelations> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/nodes/${encodeURIComponent(id)}/events/assign`, JSON.stringify(params))
            return await resp.json() as nodes.NodeWithRelations
        }

        /**
         * Assigns labels to a node by replacing all existing label assignments.
         * This is a destructive operation that replaces existing labels.
         * @param params - Object containing the node ID and label IDs to assign
         * @param params.id - The ID of the node to assign labels to
         * @param params.labelIds - Array of label IDs to assign to the node
         * @returns {Promise<NodeWithRelations>} The updated node with its relations including the new labels
         * @throws {APIError} If the node is not found, validation fails, or assignment fails
         */
        public async assignLabelsToNode(id: number, params: {
    /**
     * Array of label IDs to assign to the node
     * Replaces all existing label assignments
     */
    labelIds: number[]
}): Promise<nodes.NodeWithRelations> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/nodes/${encodeURIComponent(id)}/labels/assign`, JSON.stringify(params))
            return await resp.json() as nodes.NodeWithRelations
        }

        /**
         * Creates a new amenity.
         * @param params - The amenity data to create
         * @returns {Promise<Amenity>} The created amenity
         * @throws {APIError} If the amenity creation fails
         */
        public async createAmenity(params: amenities.CreateAmenityPayload): Promise<amenities.Amenity> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/amenities/create`, JSON.stringify(params))
            return await resp.json() as amenities.Amenity
        }

        /**
         * Creates a new bus.
         * @param params - The bus data to create
         * @returns {Promise<Bus>} The created bus
         * @throws {APIError} If the bus creation fails
         */
        public async createBus(params: buses.CreateBusPayload): Promise<buses.Bus> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/buses/create`, JSON.stringify(params))
            return await resp.json() as buses.Bus
        }

        /**
         * Creates a new bus diagram model and automatically generates seat models in a single transaction.
         * @param params - Data for the new bus diagram model
         * @returns {Promise<BusDiagramModel>} The created bus diagram model
         * @throws {APIError} If creation fails or validation fails
         */
        public async createBusDiagramModel(params: bus_diagram_models.CreateBusDiagramModelPayload): Promise<bus_diagram_models.BusDiagramModel> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/bus-diagram-models`, JSON.stringify(params))
            return await resp.json() as bus_diagram_models.BusDiagramModel
        }

        /**
         * Creates a new bus diagram model zone.
         * @param params - The zone data to create
         * @returns {Promise<BusDiagramModelZone>} The created zone
         * @throws {APIError} If creation fails
         */
        public async createBusDiagramModelZone(busDiagramModelId: number, params: {
    /**
     * Name of the zone
     * Must have at least 1 character
     */
    name: string

    /**
     * Array of row numbers that belong to this zone
     */
    rowNumbers: number[]

    /**
     * Price multiplier for seats in this zone
     * @default 1.0
     */
    priceMultiplier?: number
}): Promise<bus_diagram_model_zones.BusDiagramModelZone> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/bus-diagram-models/${encodeURIComponent(busDiagramModelId)}/zones`, JSON.stringify(params))
            return await resp.json() as bus_diagram_model_zones.BusDiagramModelZone
        }

        /**
         * Creates a new bus line.
         * @param params - The bus line data to create
         * @returns {Promise<BusLine>} The created bus line
         * @throws {APIError} If the bus line creation fails
         */
        public async createBusLine(params: bus_lines.CreateBusLinePayload): Promise<bus_lines.BusLine> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/bus-lines/create`, JSON.stringify(params))
            return await resp.json() as bus_lines.BusLine
        }

        /**
         * Creates a new bus model.
         * @param params - The bus model data to create
         * @returns {Promise<BusModel>} The created bus model
         * @throws {APIError} If the bus model creation fails
         */
        public async createBusModel(params: bus_models.CreateBusModelPayload): Promise<bus_models.BusModel> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/bus-models/create`, JSON.stringify(params))
            return await resp.json() as bus_models.BusModel
        }

        /**
         * Creates a new city.
         * @param params - The city data to create
         * @returns {Promise<City>} The created city
         * @throws {APIError} If the city creation fails
         */
        public async createCity(params: cities.CreateCityPayload): Promise<cities.City> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/cities/create`, JSON.stringify(params))
            return await resp.json() as cities.City
        }

        /**
         * Creates a new compound route by connecting multiple existing routes.
         * @param params - Data for creating a compound route
         * @param params.name - Name of the compound route
         * @param params.description - Description of the compound route
         * @param params.routeIds - Array of route IDs to connect in sequence
         * @returns {Promise<RouteWithFullDetails>} The created compound route with full details
         * @throws {APIError} If creation fails, routes don't exist, or connections are invalid
         */
        public async createCompoundRoute(params: {
    name: string
    description: string
    routeIds: number[]
}): Promise<routes.RouteWithFullDetails> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/routes/compound`, JSON.stringify(params))
            return await resp.json() as routes.RouteWithFullDetails
        }

        /**
         * Creates a new country.
         * @param params - The country data to create
         * @returns {Promise<Country>} The created country
         * @throws {APIError} If the country creation fails
         */
        public async createCountry(params: countries.CreateCountryPayload): Promise<countries.Country> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/countries/create`, JSON.stringify(params))
            return await resp.json() as countries.Country
        }

        /**
         * Creates a new driver.
         * @throws {APIError} If the driver creation fails
         */
        public async createDriver(params: drivers.CreateDriverPayload): Promise<drivers.Driver> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/drivers`, JSON.stringify(params))
            return await resp.json() as drivers.Driver
        }

        /**
         * Creates a new event type.
         * @param params - The event type data to create
         * @returns {Promise<EventType>} The created event type
         * @throws {APIError} If the event type creation fails
         */
        public async createEventType(params: event_types.CreateEventTypePayload): Promise<event_types.EventType> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/event-types/create`, JSON.stringify(params))
            return await resp.json() as event_types.EventType
        }

        /**
         * Creates a new installation associated with a node.
         * @param params - The installation data including nodeId, name, and optional description
         * @returns {Promise<InstallationWithDetails>} The created installation with location information from the associated node
         * @throws {APIError} If the node is not found, already has an installation, or creation fails
         */
        public async createInstallation(params: installations.CreateNodeInstallationPayload): Promise<installations.InstallationWithDetails> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/installations/create`, JSON.stringify(params))
            return await resp.json() as installations.InstallationWithDetails
        }

        /**
         * Creates a new installation schema.
         * @param params - The installation schema data to create
         * @returns {Promise<InstallationSchema>} The created installation schema
         * @throws {APIError} If the installation schema creation fails
         */
        public async createInstallationSchema(params: installation_schemas.CreateInstallationSchemaPayload): Promise<installation_schemas.InstallationSchema> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/installation/schemas/create`, JSON.stringify(params))
            return await resp.json() as installation_schemas.InstallationSchema
        }

        /**
         * Creates a new installation type.
         * @param params - The installation type data to create
         * @returns {Promise<InstallationType>} The created installation type
         * @throws {APIError} If the installation type creation fails
         */
        public async createInstallationType(params: installation_types.CreateInstallationTypePayload): Promise<installation_types.InstallationType> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/installation/types/create`, JSON.stringify(params))
            return await resp.json() as installation_types.InstallationType
        }

        /**
         * Creates a new label.
         * @param params - The label data to create
         * @returns {Promise<Label>} The created label
         * @throws {APIError} If the label creation fails
         */
        public async createLabel(params: labels.CreateLabelPayload): Promise<labels.Label> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/labels/create`, JSON.stringify(params))
            return await resp.json() as labels.Label
        }

        /**
         * Creates a new node.
         * @param params - The node data to create
         * @returns {Promise<Node>} The created node
         * @throws {APIError} If the node creation fails
         */
        public async createNode(params: nodes.CreateNodePayload): Promise<nodes.Node> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/nodes/create`, JSON.stringify(params))
            return await resp.json() as nodes.Node
        }

        /**
         * Creates a new pathway
         * @param params - The pathway data to create
         * @returns {Promise<Pathway>} The created pathway
         * @throws {APIError} If the pathway creation fails
         */
        public async createPathway(params: pathways.CreatePathwayPayload): Promise<pathways.Pathway> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/pathways`, JSON.stringify(params))
            return await resp.json() as pathways.Pathway
        }

        /**
         * Creates a new population.
         * @param params - The population data to create
         * @returns {Promise<Population>} The created population
         * @throws {APIError} If the population creation fails
         */
        public async createPopulation(params: populations.CreatePopulationPayload): Promise<populations.Population> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/populations/create`, JSON.stringify(params))
            return await resp.json() as populations.Population
        }

        /**
         * Creates a new simple route with its related pathway.
         * @param params - The data for creating the route and pathway
         * @returns {Promise<Route>} The created route
         * @throws {APIError} If creation fails
         */
        public async createRoute(params: routes.CreateSimpleRoutePayload): Promise<routes.Route> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/routes`, JSON.stringify(params))
            return await resp.json() as routes.Route
        }

        /**
         * Creates a new seat diagram zone.
         * @param params - The zone data to create
         * @returns {Promise<SeatDiagramZone>} The created zone
         * @throws {APIError} If creation fails
         */
        public async createSeatDiagramZone(seatDiagramId: number, params: {
    /**
     * Name of the zone
     * Must have at least 1 character
     */
    name: string

    /**
     * Array of row numbers that belong to this zone
     */
    rowNumbers: number[]

    /**
     * Price multiplier for seats in this zone
     * @default 1.0
     */
    priceMultiplier?: number
}): Promise<seat_diagram_zones.SeatDiagramZone> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/seat-diagrams/${encodeURIComponent(seatDiagramId)}/zones`, JSON.stringify(params))
            return await resp.json() as seat_diagram_zones.SeatDiagramZone
        }

        /**
         * Creates a new service type.
         * @param payload - Service type data to create
         * @returns The newly created service type
         */
        public async createServiceType(params: service_types.CreateServiceTypePayload): Promise<service_types.ServiceType> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/service-types/create`, JSON.stringify(params))
            return await resp.json() as service_types.ServiceType
        }

        /**
         * Creates a new state.
         */
        public async createState(params: states.CreateStatePayload): Promise<states.State> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/states/create`, JSON.stringify(params))
            return await resp.json() as states.State
        }

        /**
         * Creates a new transporter.
         * @param params - The transporter data to create
         * @returns {Promise<Transporter>} The created transporter
         * @throws {APIError} If the transporter creation fails
         */
        public async createTransporter(params: transporters.CreateTransporterPayload): Promise<transporters.Transporter> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/transporters/create`, JSON.stringify(params))
            return await resp.json() as transporters.Transporter
        }

        /**
         * Deletes an amenity by its ID.
         * @param params - Object containing the amenity ID
         * @param params.id - The ID of the amenity to delete
         * @returns {Promise<Amenity>} The deleted amenity
         * @throws {APIError} If the amenity is not found or deletion fails
         */
        public async deleteAmenity(id: number): Promise<amenities.Amenity> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/amenities/${encodeURIComponent(id)}/delete`)
            return await resp.json() as amenities.Amenity
        }

        /**
         * Deletes a bus by its ID.
         * @param params - Object containing the bus ID
         * @param params.id - The ID of the bus to delete
         * @returns {Promise<Bus>} The deleted bus
         * @throws {APIError} If the bus is not found or deletion fails
         */
        public async deleteBus(id: number): Promise<buses.Bus> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/buses/${encodeURIComponent(id)}/delete`)
            return await resp.json() as buses.Bus
        }

        /**
         * Deletes a bus diagram model by its ID.
         * @param params - Object containing the bus diagram model ID
         * @param params.id - The ID of the bus diagram model to delete
         * @returns {Promise<BusDiagramModel>} The deleted bus diagram model
         * @throws {APIError} If deletion fails or the bus diagram model doesn't exist
         */
        public async deleteBusDiagramModel(id: number): Promise<bus_diagram_models.BusDiagramModel> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/bus-diagram-models/${encodeURIComponent(id)}`)
            return await resp.json() as bus_diagram_models.BusDiagramModel
        }

        /**
         * Deletes a bus diagram model zone by its ID.
         * @param params - Object containing the zone ID and model ID
         * @param params.id - The ID of the zone to delete
         * @param params.busDiagramModelId - The ID of the model the zone belongs to
         * @returns {Promise<BusDiagramModelZone>} The deleted zone
         * @throws {APIError} If deletion fails or zone doesn't exist
         */
        public async deleteBusDiagramModelZone(busDiagramModelId: number, id: number): Promise<bus_diagram_model_zones.BusDiagramModelZone> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/bus-diagram-models/${encodeURIComponent(busDiagramModelId)}/zones/${encodeURIComponent(id)}`)
            return await resp.json() as bus_diagram_model_zones.BusDiagramModelZone
        }

        /**
         * Deletes a bus line by its ID.
         * @param params - Object containing the bus line ID
         * @param params.id - The ID of the bus line to delete
         * @returns {Promise<BusLine>} The deleted bus line
         * @throws {APIError} If the bus line is not found or deletion fails
         */
        public async deleteBusLine(id: number): Promise<bus_lines.BusLine> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/bus-lines/${encodeURIComponent(id)}/delete`)
            return await resp.json() as bus_lines.BusLine
        }

        /**
         * Deletes a bus model by its ID.
         * @param params - Object containing the bus model ID
         * @param params.id - The ID of the bus model to delete
         * @returns {Promise<BusModel>} The deleted bus model
         * @throws {APIError} If the bus model is not found or deletion fails
         */
        public async deleteBusModel(id: number): Promise<bus_models.BusModel> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/bus-models/${encodeURIComponent(id)}/delete`)
            return await resp.json() as bus_models.BusModel
        }

        /**
         * Deletes a city by its ID.
         * @param params - Object containing the city ID
         * @param params.id - The ID of the city to delete
         * @returns {Promise<City>} The deleted city
         * @throws {APIError} If the city is not found or deletion fails
         */
        public async deleteCity(id: number): Promise<cities.City> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/cities/${encodeURIComponent(id)}/delete`)
            return await resp.json() as cities.City
        }

        /**
         * Deletes a country by its ID.
         * @param params - Object containing the country ID
         * @param params.id - The ID of the country to delete
         * @returns {Promise<Country>} The deleted country
         * @throws {APIError} If the country is not found or deletion fails
         */
        public async deleteCountry(id: number): Promise<countries.Country> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/countries/${encodeURIComponent(id)}/delete`)
            return await resp.json() as countries.Country
        }

        /**
         * Deletes a driver by its ID.
         * @param params - Object containing the driver ID
         * @param params.id - The ID of the driver to delete
         * @returns {Promise<Driver>} The deleted driver
         * @throws {APIError} If the driver is not found or deletion fails
         */
        public async deleteDriver(id: number): Promise<drivers.Driver> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/drivers/${encodeURIComponent(id)}`)
            return await resp.json() as drivers.Driver
        }

        /**
         * Deletes an event type by its ID.
         * @param params - Object containing the event type ID
         * @param params.id - The ID of the event type to delete
         * @returns {Promise<EventType>} The deleted event type
         * @throws {APIError} If the event type is not found or deletion fails
         */
        public async deleteEventType(id: number): Promise<event_types.EventType> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/event-types/${encodeURIComponent(id)}/delete`)
            return await resp.json() as event_types.EventType
        }

        /**
         * Deletes an installation by its ID.
         * @param params - Object containing the installation ID
         * @param params.id - The ID of the installation to delete
         * @returns {Promise<Installation>} The deleted installation
         * @throws {APIError} If the installation is not found or deletion fails
         */
        public async deleteInstallation(id: number): Promise<installations.Installation> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/installations/${encodeURIComponent(id)}/delete`)
            return await resp.json() as installations.Installation
        }

        /**
         * Deletes an installation schema by its ID.
         * @param params - Object containing the installation schema ID
         * @param params.id - The ID of the installation schema to delete
         * @returns {Promise<InstallationSchema>} The deleted installation schema
         * @throws {APIError} If the installation schema is not found or deletion fails
         */
        public async deleteInstallationSchema(id: number): Promise<installation_schemas.InstallationSchema> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/installation/schemas/${encodeURIComponent(id)}/delete`)
            return await resp.json() as installation_schemas.InstallationSchema
        }

        /**
         * Deletes an installation type by its ID.
         * @param params - Object containing the installation type ID
         * @param params.id - The ID of the installation type to delete
         * @returns {Promise<InstallationType>} The deleted installation type
         * @throws {APIError} If the installation type is not found or deletion fails
         */
        public async deleteInstallationType(id: number): Promise<installation_types.InstallationType> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/installation/types/${encodeURIComponent(id)}/delete`)
            return await resp.json() as installation_types.InstallationType
        }

        /**
         * Deletes a label by ID.
         * @param params - Object containing the label ID to delete
         * @returns {Promise<Label>} The deleted label
         * @throws {APIError} If the label is not found
         */
        public async deleteLabel(id: number): Promise<labels.Label> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/labels/${encodeURIComponent(id)}/delete`)
            return await resp.json() as labels.Label
        }

        /**
         * Deletes a node by its ID.
         * @param params - Object containing the node ID
         * @param params.id - The ID of the node to delete
         * @returns {Promise<Node>} The deleted node
         * @throws {APIError} If the node is not found or deletion fails
         */
        public async deleteNode(id: number): Promise<nodes.Node> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/nodes/${encodeURIComponent(id)}/delete`)
            return await resp.json() as nodes.Node
        }

        /**
         * Deletes a pathway by its ID.
         * @param params - Object containing the pathway ID
         * @param params.id - The ID of the pathway to delete
         * @returns {Promise<Pathway>} The deleted pathway
         * @throws {APIError} If the pathway is not found or deletion fails
         */
        public async deletePathway(id: number): Promise<pathways.Pathway> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/pathways/${encodeURIComponent(id)}`)
            return await resp.json() as pathways.Pathway
        }

        /**
         * Deletes a population by its ID.
         * @param params - Object containing the population ID
         * @param params.id - The ID of the population to delete
         * @returns {Promise<Population>} The deleted population
         * @throws {APIError} If the population is not found or deletion fails
         */
        public async deletePopulation(id: number): Promise<populations.Population> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/populations/${encodeURIComponent(id)}/delete`)
            return await resp.json() as populations.Population
        }

        /**
         * Deletes a route by its ID.
         * @param params - Object containing the route ID
         * @param params.id - The ID of the route to delete
         * @returns {Promise<Route>} The deleted route
         * @throws {APIError} If the route is not found or deletion fails
         */
        public async deleteRoute(id: number): Promise<routes.Route> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/routes/${encodeURIComponent(id)}`)
            return await resp.json() as routes.Route
        }

        /**
         * Deletes a seat diagram by its ID.
         * @param params - Object containing the seat diagram ID
         * @param params.id - The ID of the seat diagram to delete
         * @returns {Promise<SeatDiagram>} The deleted seat diagram
         * @throws {APIError} If deletion fails or the seat diagram doesn't exist
         */
        public async deleteSeatDiagram(id: number): Promise<seat_diagrams.SeatDiagram> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/seat-diagrams/${encodeURIComponent(id)}`)
            return await resp.json() as seat_diagrams.SeatDiagram
        }

        /**
         * Deletes a seat diagram zone.
         * @param params - Object containing the zone ID and diagram ID
         * @param params.id - The ID of the zone to delete
         * @param params.seatDiagramId - The ID of the diagram the zone belongs to
         * @returns {Promise<void>} No content on success
         * @throws {APIError} If deletion fails or zone doesn't exist
         */
        public async deleteSeatDiagramZone(seatDiagramId: number, id: number): Promise<void> {
            await this.baseClient.callTypedAPI("DELETE", `/seat-diagrams/${encodeURIComponent(seatDiagramId)}/zones/${encodeURIComponent(id)}`)
        }

        /**
         * Deletes a service type by its ID.
         * @param params - Object containing the service type ID to delete
         * @returns The deleted service type
         */
        public async deleteServiceType(id: number): Promise<service_types.ServiceType> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/service-types/${encodeURIComponent(id)}/delete`)
            return await resp.json() as service_types.ServiceType
        }

        /**
         * Deletes a state by its ID.
         */
        public async deleteState(id: number): Promise<states.State> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/states/${encodeURIComponent(id)}/delete`)
            return await resp.json() as states.State
        }

        /**
         * Deletes a transporter by its ID.
         * @param params - Object containing the transporter ID
         * @param params.id - The ID of the transporter to delete
         * @returns {Promise<Transporter>} The deleted transporter
         * @throws {APIError} If the transporter is not found or deletion fails
         */
        public async deleteTransporter(id: number): Promise<transporters.Transporter> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/transporters/${encodeURIComponent(id)}/delete`)
            return await resp.json() as transporters.Transporter
        }

        /**
         * Finds a population by its assigned city.
         * @param params - Object containing the city ID
         * @param params.cityId - The ID of the city to find the population by
         * @returns {Promise<FindPopulationByAssignedCityResult>} The found population with related cities or undefined if no population is assigned to the city
         * @throws {APIError} If the population is not found or retrieval fails
         */
        public async findPopulationByAssignedCity(cityId: number): Promise<populations.FindPopulationByAssignedCityResult> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/populations/find/${encodeURIComponent(cityId)}`)
            return await resp.json() as populations.FindPopulationByAssignedCityResult
        }

        /**
         * Retrieves an amenity by its ID.
         * @param params - Object containing the amenity ID
         * @param params.id - The ID of the amenity to retrieve
         * @returns {Promise<Amenity>} The found amenity
         * @throws {APIError} If the amenity is not found or retrieval fails
         */
        public async getAmenity(id: number): Promise<amenities.Amenity> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/amenities/${encodeURIComponent(id)}`)
            return await resp.json() as amenities.Amenity
        }

        /**
         * Retrieves a bus by its ID.
         * @param params - Object containing the bus ID
         * @param params.id - The ID of the bus to retrieve
         * @returns {Promise<ExtendedBusData>} The found bus
         * @throws {APIError} If the bus is not found or retrieval fails
         */
        public async getBus(id: number): Promise<buses.ExtendedBusData> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/buses/${encodeURIComponent(id)}`)
            return await resp.json() as buses.ExtendedBusData
        }

        /**
         * Retrieves a bus diagram model by its ID.
         * @param params - Object containing the bus diagram model ID
         * @param params.id - The ID of the bus diagram model to retrieve
         * @returns {Promise<BusDiagramModel>} The requested bus diagram model
         * @throws {APIError} If retrieval fails or the bus diagram model doesn't exist
         */
        public async getBusDiagramModel(id: number): Promise<bus_diagram_models.BusDiagramModel> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/bus-diagram-models/${encodeURIComponent(id)}`)
            return await resp.json() as bus_diagram_models.BusDiagramModel
        }

        /**
         * Retrieves all seat models for a specific bus diagram model.
         * @param params - Object containing the bus diagram model ID
         * @param params.id - The ID of the bus diagram model to get seats for
         * @returns {Promise<BusSeatModels>} Object containing array of seat models
         * @throws {APIError} If retrieval fails or the bus diagram model doesn't exist
         */
        public async getBusDiagramModelSeats(id: number): Promise<bus_seat_models.BusSeatModels> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/bus-diagram-models/${encodeURIComponent(id)}/seats`)
            return await resp.json() as bus_seat_models.BusSeatModels
        }

        /**
         * Retrieves a bus diagram model zone by its ID.
         * @param params - Object containing the zone ID and model ID
         * @param params.id - The ID of the zone to retrieve
         * @param params.busDiagramModelId - The ID of the model the zone belongs to
         * @returns {Promise<BusDiagramModelZone>} The requested zone
         * @throws {APIError} If retrieval fails or zone doesn't exist
         */
        public async getBusDiagramModelZone(busDiagramModelId: number, id: number): Promise<bus_diagram_model_zones.BusDiagramModelZone> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/bus-diagram-models/${encodeURIComponent(busDiagramModelId)}/zones/${encodeURIComponent(id)}`)
            return await resp.json() as bus_diagram_model_zones.BusDiagramModelZone
        }

        /**
         * Retrieves a bus line by its ID.
         * @param params - Object containing the bus line ID
         * @param params.id - The ID of the bus line to retrieve
         * @returns {Promise<BusLineWithTransporterAndServiceType>} The found bus line with relations
         * @throws {APIError} If the bus line is not found or retrieval fails
         */
        public async getBusLine(id: number): Promise<bus_lines.BusLineWithTransporterAndServiceType> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/bus-lines/${encodeURIComponent(id)}`)
            return await resp.json() as bus_lines.BusLineWithTransporterAndServiceType
        }

        /**
         * Retrieves a bus model by its ID.
         * @param params - Object containing the bus model ID
         * @param params.id - The ID of the bus model to retrieve
         * @returns {Promise<BusModel>} The found bus model
         * @throws {APIError} If the bus model is not found or retrieval fails
         */
        public async getBusModel(id: number): Promise<bus_models.BusModel> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/bus-models/${encodeURIComponent(id)}`)
            return await resp.json() as bus_models.BusModel
        }

        /**
         * Retrieves a city by its ID with related state, country, and population information.
         * @param params - Object containing the city ID
         * @param params.id - The ID of the city to retrieve
         * @returns {Promise<CityWithRelations>} The found city with state, country, and population information
         * @throws {APIError} If the city is not found or retrieval fails
         */
        public async getCity(id: number): Promise<cities.CityWithRelations> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/cities/${encodeURIComponent(id)}`)
            return await resp.json() as cities.CityWithRelations
        }

        /**
         * Retrieves a country by its ID.
         * @param params - Object containing the country ID
         * @param params.id - The ID of the country to retrieve
         * @returns {Promise<Country>} The found country
         * @throws {APIError} If the country is not found or retrieval fails
         */
        public async getCountry(id: number): Promise<countries.Country> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/countries/${encodeURIComponent(id)}`)
            return await resp.json() as countries.Country
        }

        /**
         * Retrieves a driver by its ID.
         * @throws {APIError} If the driver is not found or retrieval fails
         */
        public async getDriver(id: number): Promise<drivers.Driver> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/drivers/${encodeURIComponent(id)}`)
            return await resp.json() as drivers.Driver
        }

        /**
         * Retrieves an event type by its ID.
         * @param params - Object containing the event type ID
         * @param params.id - The ID of the event type to retrieve
         * @returns {Promise<EventType>} The found event type
         * @throws {APIError} If the event type is not found or retrieval fails
         */
        public async getEventType(id: number): Promise<event_types.EventType> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/event-types/${encodeURIComponent(id)}`)
            return await resp.json() as event_types.EventType
        }

        /**
         * Retrieves an installation by its ID with location information.
         * @param params - Object containing the installation ID
         * @param params.id - The ID of the installation to retrieve
         * @returns {Promise<InstallationWithDetails>} The found installation with location data
         * @throws {APIError} If the installation is not found or retrieval fails
         */
        public async getInstallation(id: number): Promise<installations.InstallationWithDetails> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/installations/${encodeURIComponent(id)}`)
            return await resp.json() as installations.InstallationWithDetails
        }

        /**
         * Retrieves an installation schema with its related installation type by its ID.
         * @param params - Object containing the installation schema ID
         * @param params.id - The ID of the installation schema to retrieve
         * @returns {Promise<InstallationSchemaWithRelations>} The found installation schema with related data
         * @throws {APIError} If the installation schema is not found or retrieval fails
         */
        public async getInstallationSchema(id: number): Promise<installation_schemas.InstallationSchemaWithRelations> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/installation/schemas/${encodeURIComponent(id)}`)
            return await resp.json() as installation_schemas.InstallationSchemaWithRelations
        }

        /**
         * Retrieves an installation type by its ID with related event types information.
         * @param params - Object containing the installation type ID
         * @param params.id - The ID of the installation type to retrieve
         * @returns {Promise<InstallationTypeWithRelations>} The found installation type with related event types
         * @throws {APIError} If the installation type is not found or retrieval fails
         */
        public async getInstallationType(id: number): Promise<installation_types.InstallationTypeWithRelations> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/installation/types/${encodeURIComponent(id)}`)
            return await resp.json() as installation_types.InstallationTypeWithRelations
        }

        /**
         * Retrieves the schema definition for a specific installation type.
         * @param params - Object containing the installation type ID
         * @param params.id - The ID of the installation type to get schema for
         * @returns {Promise<ListInstallationSchemasResult>} Object containing array of schema definitions for the installation type
         * @throws {APIError} If the installation type is not found or retrieval fails
         */
        public async getInstallationTypeSchema(id: number): Promise<installation_schemas.ListInstallationSchemasResult> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/installation/types/${encodeURIComponent(id)}/schema`)
            return await resp.json() as installation_schemas.ListInstallationSchemasResult
        }

        /**
         * Retrieves a single label by ID with node count.
         * @param params - Object containing the label ID to retrieve
         * @returns {Promise<LabelWithNodeCount>} The label with node count
         * @throws {APIError} If the label is not found
         */
        public async getLabel(id: number): Promise<labels.LabelWithNodeCount> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/labels/${encodeURIComponent(id)}`)
            return await resp.json() as labels.LabelWithNodeCount
        }

        /**
         * Gets metrics data for labels dashboard.
         * @returns {Promise<LabelsMetrics>} Metrics including total labels, labels in use, and most used label info
         */
        public async getLabelsMetrics(): Promise<labels.LabelsMetrics> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/labels/metrics`)
            return await resp.json() as labels.LabelsMetrics
        }

        /**
         * Retrieves a node by its ID with related information.
         * @param params - Object containing the node ID
         * @param params.id - The ID of the node to retrieve
         * @returns {Promise<NodeWithRelations>} The found node with related information
         * @throws {APIError} If the node is not found or retrieval fails
         */
        public async getNode(id: number): Promise<nodes.NodeWithRelations> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/nodes/${encodeURIComponent(id)}`)
            return await resp.json() as nodes.NodeWithRelations
        }

        /**
         * Retrieves a pathway by its ID
         * @param params - Object containing the pathway ID
         * @param params.id - The ID of the pathway to retrieve
         * @returns {Promise<Pathway>} The found pathway
         * @throws {APIError} If the pathway is not found
         */
        public async getPathway(id: number): Promise<pathways.Pathway> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/pathways/${encodeURIComponent(id)}`)
            return await resp.json() as pathways.Pathway
        }

        /**
         * Retrieves a population by its ID with related cities information.
         * @param params - Object containing the population ID
         * @param params.id - The ID of the population to retrieve
         * @returns {Promise<PopulationWithRelations>} The found population with related cities
         * @throws {APIError} If the population is not found or retrieval fails
         */
        public async getPopulation(id: number): Promise<populations.PopulationWithRelations> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/populations/${encodeURIComponent(id)}`)
            return await resp.json() as populations.PopulationWithRelations
        }

        /**
         * Retrieves cities assigned to a specific population.
         * @param params - Object containing the population ID
         * @param params.id - The ID of the population to get cities for
         * @returns {Promise<ListCitiesResult>} Unified response with data property containing array of cities assigned to the population
         * @throws {APIError} If the population is not found or retrieval fails
         */
        public async getPopulationCities(id: number): Promise<cities.ListCitiesResult> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/populations/${encodeURIComponent(id)}/cities`)
            return await resp.json() as cities.ListCitiesResult
        }

        /**
         * Retrieves a route by its ID.
         * @param params - Object containing the route ID
         * @param params.id - The ID of the route to retrieve
         * @returns {Promise<Route>} The found route
         * @throws {APIError} If the route is not found or retrieval fails
         */
        public async getRoute(id: number): Promise<routes.Route> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/routes/${encodeURIComponent(id)}`)
            return await resp.json() as routes.Route
        }

        /**
         * Retrieves a route by its ID with all related details.
         * @param params - Object containing the route ID
         * @param params.id - The ID of the route to retrieve
         * @returns {Promise<RouteWithFullDetails>} The found route with full details
         * @throws {APIError} If the route is not found or retrieval fails
         */
        public async getRouteWithFullDetails(id: number): Promise<routes.RouteWithFullDetails> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/routes/${encodeURIComponent(id)}/details`)
            return await resp.json() as routes.RouteWithFullDetails
        }

        /**
         * Retrieves a seat diagram by its ID.
         * @param params - Object containing the seat diagram ID
         * @param params.id - The ID of the seat diagram to retrieve
         * @returns {Promise<SeatDiagram>} The requested seat diagram
         * @throws {APIError} If retrieval fails or the seat diagram doesn't exist
         */
        public async getSeatDiagram(id: number): Promise<seat_diagrams.SeatDiagram> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/seat-diagrams/${encodeURIComponent(id)}`)
            return await resp.json() as seat_diagrams.SeatDiagram
        }

        /**
         * Retrieves all seats for a specific seat diagram.
         * @param params - Object containing the seat diagram ID
         * @param params.id - The ID of the seat diagram to get seats for
         * @returns {Promise<BusSeats>} Object containing array of bus seats
         * @throws {APIError} If retrieval fails or the seat diagram doesn't exist
         */
        public async getSeatDiagramSeats(id: number): Promise<bus_seats.BusSeats> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/seat-diagrams/${encodeURIComponent(id)}/seats`)
            return await resp.json() as bus_seats.BusSeats
        }

        /**
         * Retrieves a seat diagram zone by its ID.
         * @param params - Object containing the zone ID and diagram ID
         * @param params.id - The ID of the zone to retrieve
         * @param params.seatDiagramId - The ID of the diagram the zone belongs to
         * @returns {Promise<SeatDiagramZone>} The requested zone
         * @throws {APIError} If retrieval fails or zone doesn't exist
         */
        public async getSeatDiagramZone(seatDiagramId: number, id: number): Promise<seat_diagram_zones.SeatDiagramZone> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/seat-diagrams/${encodeURIComponent(seatDiagramId)}/zones/${encodeURIComponent(id)}`)
            return await resp.json() as seat_diagram_zones.SeatDiagramZone
        }

        /**
         * Retrieves a service type by its ID with assigned amenities.
         * @param params - Object containing the service type ID
         * @returns The requested service type with amenities
         */
        public async getServiceType(id: number): Promise<service_types.ServiceTypeWithAmenities> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/service-types/${encodeURIComponent(id)}`)
            return await resp.json() as service_types.ServiceTypeWithAmenities
        }

        /**
         * Retrieves a state by its ID.
         */
        public async getState(id: number): Promise<states.State> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/states/${encodeURIComponent(id)}`)
            return await resp.json() as states.State
        }

        /**
         * Retrieves a timezone by its ID.
         * @param params - Object containing the timezone ID
         * @param params.id - The ID of the timezone to retrieve
         * @returns {Timezone} The found timezone
         * @throws {Error} If the timezone is not found
         */
        public async getTimezone(id: string): Promise<timezones.Timezone> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/timezones/${encodeURIComponent(id)}`)
            return await resp.json() as timezones.Timezone
        }

        /**
         * Retrieves a transporter by its ID.
         * @param params - Object containing the transporter ID
         * @param params.id - The ID of the transporter to retrieve
         * @returns {Promise<TransporterWithCity>} The found transporter with city info
         * @throws {APIError} If the transporter is not found or retrieval fails
         */
        public async getTransporter(id: number): Promise<transporters.TransporterWithCity> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/transporters/${encodeURIComponent(id)}`)
            return await resp.json() as transporters.TransporterWithCity
        }

        /**
         * Retrieves all amenities without pagination (useful for dropdowns).
         * @param params - Query parameters including orderBy, filters, and searchTerm
         * @returns {Promise<ListAmenitiesResult>} Unified response with data property containing array of amenities
         * @throws {APIError} If retrieval fails
         */
        public async listAmenities(params: amenities.ListAmenitiesQueryParams): Promise<amenities.ListAmenitiesResult> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/amenities/list/all`, JSON.stringify(params))
            return await resp.json() as amenities.ListAmenitiesResult
        }

        /**
         * Retrieves amenities with pagination (useful for tables).
         * @param params - Pagination and query parameters including page, pageSize, orderBy, filters, and searchTerm
         * @returns {Promise<PaginatedListAmenitiesResult>} Unified paginated response with data and pagination properties
         * @throws {APIError} If retrieval fails
         */
        public async listAmenitiesPaginated(params: amenities.PaginatedListAmenitiesQueryParams): Promise<amenities.PaginatedListAmenitiesResult> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/amenities/list`, JSON.stringify(params))
            return await resp.json() as amenities.PaginatedListAmenitiesResult
        }

        /**
         * Retrieves available cities for assignment to a population.
         * Returns cities not assigned to any population, or if populationId is provided,
         * includes cities assigned to that specific population.
         * @param params - Object with optional populationId query parameter
         * @param params.populationId - Optional population ID query parameter to include its assigned cities
         * @returns {Promise<ListAvailableCitiesResult>} Unified response with data property containing array of cities with state and country information
         * @throws {APIError} If retrieval fails
         */
        public async listAvailableCities(params: {
    populationId?: number
}): Promise<populations.ListAvailableCitiesResult> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                populationId: params.populationId === undefined ? undefined : String(params.populationId),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/populations/cities`, undefined, {query})
            return await resp.json() as populations.ListAvailableCitiesResult
        }

        /**
         * Retrieves all bus diagram models without pagination (useful for dropdowns).
         * @returns {Promise<ListBusDiagramModelsResult>} An object with a data array of bus diagram models
         * @throws {APIError} If retrieval fails
         */
        public async listBusDiagramModels(params: bus_diagram_models.ListBusDiagramModelsQueryParams): Promise<bus_diagram_models.ListBusDiagramModelsResult> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/bus-diagram-models/list/all`, JSON.stringify(params))
            return await resp.json() as bus_diagram_models.ListBusDiagramModelsResult
        }

        /**
         * Retrieves bus diagram models with pagination (useful for tables).
         * @param params - Pagination parameters
         * @returns {Promise<PaginatedBusDiagramModels>} Paginated list of bus diagram models
         * @throws {APIError} If retrieval fails
         */
        public async listBusDiagramModelsPaginated(params: shared.PaginationParams): Promise<bus_diagram_models.PaginatedBusDiagramModels> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/get-bus-diagram-models/paginated`, JSON.stringify(params))
            return await resp.json() as bus_diagram_models.PaginatedBusDiagramModels
        }

        /**
         * Retrieves all bus lines without pagination (useful for dropdowns).
         * @param params - Query parameters including orderBy, filters, and searchTerm
         * @returns {Promise<ListBusLinesResult>} Unified response with data property containing array of bus lines
         * @throws {APIError} If retrieval fails
         */
        public async listBusLines(params: bus_lines.ListBusLinesQueryParams): Promise<bus_lines.ListBusLinesResult> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/bus-lines/list/all`, JSON.stringify(params))
            return await resp.json() as bus_lines.ListBusLinesResult
        }

        /**
         * Retrieves bus lines with pagination (useful for tables).
         * @param params - Pagination and query parameters including page, pageSize, orderBy, filters, and searchTerm
         * @returns {Promise<PaginatedListBusLinesResult>} Unified paginated response with data and pagination properties
         * @throws {APIError} If retrieval fails
         */
        public async listBusLinesPaginated(params: bus_lines.PaginatedListBusLinesQueryParams): Promise<bus_lines.PaginatedListBusLinesResult> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/bus-lines/list`, JSON.stringify(params))
            return await resp.json() as bus_lines.PaginatedListBusLinesResult
        }

        /**
         * Retrieves all bus models without pagination (useful for dropdowns).
         * @returns {Promise<BusModels>} An object containing an array of bus models
         * @throws {APIError} If retrieval fails
         */
        public async listBusModels(params: bus_models.ListBusModelsQueryParams): Promise<bus_models.ListBusModelsResult> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/bus-models/list/all`, JSON.stringify(params))
            return await resp.json() as bus_models.ListBusModelsResult
        }

        /**
         * Retrieves bus models with pagination (useful for tables).
         * @param params - Pagination parameters
         * @returns {Promise<PaginatedBusModels>} Paginated list of bus models
         * @throws {APIError} If retrieval fails
         */
        public async listBusModelsPaginated(params: bus_models.PaginatedListBusModelsQueryParams): Promise<bus_models.PaginatedListBusModelsResult> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/bus-models/list`, JSON.stringify(params))
            return await resp.json() as bus_models.PaginatedListBusModelsResult
        }

        /**
         * Gets all valid next statuses for a bus.
         * @param params - Object containing the bus ID
         * @param params.id - The ID of the bus
         * @returns {Promise<ListBusStatusesResult>} An object containing allowed transitions
         * @throws {APIError} If retrieval fails
         */
        public async listBusValidNextStatuses(id: number): Promise<buses.ListBusStatusesResult> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/buses/${encodeURIComponent(id)}/valid-next-statuses`)
            return await resp.json() as buses.ListBusStatusesResult
        }

        /**
         * Retrieves all buses without pagination (useful for dropdowns).
         * @param params - Query options for ordering and filtering
         * @returns {Promise<ListBusesResult>} An object containing an array of buses
         * @throws {APIError} If retrieval fails
         */
        public async listBuses(params: buses.ListBusesQueryParams): Promise<buses.ListBusesResult> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/buses/list/all`, JSON.stringify(params))
            return await resp.json() as buses.ListBusesResult
        }

        /**
         * Retrieves buses with pagination (useful for tables).
         * @param params - Pagination parameters with query options
         * @returns {Promise<PaginatedListBusesResult>} Paginated list of buses
         * @throws {APIError} If retrieval fails
         */
        public async listBusesPaginated(params: buses.PaginatedListBusesQueryParams): Promise<buses.PaginatedListBusesResult> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/buses/list`, JSON.stringify(params))
            return await resp.json() as buses.PaginatedListBusesResult
        }

        /**
         * Retrieves all cities without pagination (useful for dropdowns).
         * @param params - Query parameters including orderBy, filters, and searchTerm
         * @returns {Promise<ListCitiesResult>} Unified response with data property containing array of cities
         * @throws {APIError} If retrieval fails
         */
        public async listCities(params: cities.ListCitiesQueryParams): Promise<cities.ListCitiesResult> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/cities/list/all`, JSON.stringify(params))
            return await resp.json() as cities.ListCitiesResult
        }

        /**
         * Retrieves cities with pagination and includes state and country information.
         * @param params - Pagination and query parameters including page, pageSize, orderBy, filters, and searchTerm
         * @returns {Promise<PaginatedListCitiesResult>} Unified paginated response with data and pagination properties including related state and country information
         * @throws {APIError} If retrieval fails
         */
        public async listCitiesPaginated(params: cities.PaginatedListCitiesQueryParams): Promise<cities.PaginatedListCitiesResult> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/cities/list`, JSON.stringify(params))
            return await resp.json() as cities.PaginatedListCitiesResult
        }

        /**
         * Retrieves all countries without pagination (useful for dropdowns).
         * @param params - Query parameters including orderBy, filters, and searchTerm
         * @returns {Promise<ListCountriesResult>} Unified response with data property containing array of countries
         * @throws {APIError} If retrieval fails
         */
        public async listCountries(params: countries.ListCountriesQueryParams): Promise<countries.ListCountriesResult> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/countries/list/all`, JSON.stringify(params))
            return await resp.json() as countries.ListCountriesResult
        }

        /**
         * Retrieves countries with pagination (useful for tables).
         * @param params - Pagination and query parameters including page, pageSize, orderBy, filters, and searchTerm
         * @returns {Promise<PaginatedListCountriesResult>} Unified paginated response with data and pagination properties
         * @throws {APIError} If retrieval fails
         */
        public async listCountriesPaginated(params: countries.PaginatedListCountriesQueryParams): Promise<countries.PaginatedListCountriesResult> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/countries/list`, JSON.stringify(params))
            return await resp.json() as countries.PaginatedListCountriesResult
        }

        /**
         * Gets all valid next statuses for a driver
         * @throws {APIError} If the driver is not found
         */
        public async listDriverValidNextStatuses(id: number): Promise<drivers.ListStatusesResult> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/drivers/${encodeURIComponent(id)}/valid-next-statuses`)
            return await resp.json() as drivers.ListStatusesResult
        }

        /**
         * Retrieves all drivers without pagination (useful for dropdowns).
         * @throws {APIError} If retrieval fails
         */
        public async listDrivers(params: drivers.ListDriversQueryParams): Promise<drivers.ListDriversResult> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/drivers/list`, JSON.stringify(params))
            return await resp.json() as drivers.ListDriversResult
        }

        /**
         * Retrieves drivers with pagination (useful for tables).
         * @throws {APIError} If retrieval fails
         */
        public async listDriversPaginated(params: drivers.PaginatedListDriversQueryParams): Promise<drivers.PaginatedListDriversResult> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/drivers/list/paginated`, JSON.stringify(params))
            return await resp.json() as drivers.PaginatedListDriversResult
        }

        /**
         * Retrieves all event types without pagination (useful for dropdowns).
         * @param params - Query parameters including orderBy, filters, and searchTerm
         * @returns {Promise<ListEventTypesResult>} Unified response with data property containing array of event types
         * @throws {APIError} If retrieval fails
         */
        public async listEventTypes(params: event_types.ListEventTypesQueryParams): Promise<event_types.ListEventTypesResult> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/event-types/list/all`, JSON.stringify(params))
            return await resp.json() as event_types.ListEventTypesResult
        }

        /**
         * Retrieves event types with pagination (useful for tables).
         * @param params - Pagination and query parameters including page, pageSize, orderBy, filters, and searchTerm
         * @returns {Promise<PaginatedListEventTypesResult>} Unified paginated response with data and pagination properties
         * @throws {APIError} If retrieval fails
         */
        public async listEventTypesPaginated(params: event_types.PaginatedListEventTypesQueryParams): Promise<event_types.PaginatedListEventTypesResult> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/event-types/list`, JSON.stringify(params))
            return await resp.json() as event_types.PaginatedListEventTypesResult
        }

        /**
         * Retrieves all installation schemas without pagination (useful for dropdowns).
         * @param params - Query parameters including orderBy, filters, and searchTerm
         * @returns {Promise<ListInstallationSchemasResult>} Unified response with data property containing array of installation schemas
         * @throws {APIError} If retrieval fails
         */
        public async listInstallationSchemas(params: installation_schemas.ListInstallationSchemasQueryParams): Promise<installation_schemas.ListInstallationSchemasResult> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/installation/schemas/list/all`, JSON.stringify(params))
            return await resp.json() as installation_schemas.ListInstallationSchemasResult
        }

        /**
         * Retrieves installation schemas with pagination and includes related information.
         * @param params - Pagination and query parameters including page, pageSize, orderBy, filters, and searchTerm
         * @returns {Promise<PaginatedListInstallationSchemasResult>} Unified paginated response with data and pagination properties including related information
         * @throws {APIError} If retrieval fails
         */
        public async listInstallationSchemasPaginated(params: installation_schemas.PaginatedListInstallationSchemasQueryParams): Promise<installation_schemas.PaginatedListInstallationSchemasResult> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/installation/schemas/list`, JSON.stringify(params))
            return await resp.json() as installation_schemas.PaginatedListInstallationSchemasResult
        }

        /**
         * Retrieves all installation types without pagination (useful for dropdowns).
         * @param params - Query parameters including orderBy, filters, and searchTerm
         * @returns {Promise<ListInstallationTypesResult>} Unified response with data property containing array of installation types
         * @throws {APIError} If retrieval fails
         */
        public async listInstallationTypes(params: installation_types.ListInstallationTypesQueryParams): Promise<installation_types.ListInstallationTypesResult> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/installation/types/list/all`, JSON.stringify(params))
            return await resp.json() as installation_types.ListInstallationTypesResult
        }

        /**
         * Retrieves installation types with pagination (useful for tables).
         * @param params - Pagination and query parameters including page, pageSize, orderBy, filters, and searchTerm
         * @returns {Promise<PaginatedListInstallationTypesResult>} Unified paginated response with data and pagination properties
         * @throws {APIError} If retrieval fails
         */
        public async listInstallationTypesPaginated(params: installation_types.PaginatedListInstallationTypesQueryParams): Promise<installation_types.PaginatedListInstallationTypesResult> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/installation/types/list`, JSON.stringify(params))
            return await resp.json() as installation_types.PaginatedListInstallationTypesResult
        }

        /**
         * Retrieves all installations without pagination (useful for dropdowns).
         * @param params - Query parameters including orderBy, filters, and searchTerm
         * @returns {Promise<ListInstallationsResult>} Unified response with data property containing array of installations
         * @throws {APIError} If retrieval fails
         */
        public async listInstallations(params: installations.ListInstallationsQueryParams): Promise<installations.ListInstallationsResult> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/installations/list/all`, JSON.stringify(params))
            return await resp.json() as installations.ListInstallationsResult
        }

        /**
         * Retrieves installations with pagination and includes location information.
         * @param params - Pagination and query parameters including page, pageSize, orderBy, filters, and searchTerm
         * @returns {Promise<PaginatedListInstallationsResult>} Unified paginated response with data and pagination properties
         * @throws {APIError} If retrieval fails
         */
        public async listInstallationsPaginated(params: installations.PaginatedListInstallationsQueryParams): Promise<installations.PaginatedListInstallationsResult> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/installations/list`, JSON.stringify(params))
            return await resp.json() as installations.PaginatedListInstallationsResult
        }

        /**
         * Lists all labels with optional filtering, searching, and ordering (non-paginated).
         * @param params - Query parameters for filtering, searching, and ordering
         * @returns {Promise<ListLabelsResult>} List of all labels with node count
         */
        public async listLabels(params: labels.ListLabelsQueryParams): Promise<labels.ListLabelsResult> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/labels/list/all`, JSON.stringify(params))
            return await resp.json() as labels.ListLabelsResult
        }

        /**
         * Lists all labels with optional filtering, searching, and ordering (paginated).
         * @param params - Query parameters for filtering, searching, and pagination
         * @returns {Promise<PaginatedListLabelsResult>} Paginated list of labels with node count
         */
        public async listLabelsPaginated(params: labels.PaginatedListLabelsQueryParams): Promise<labels.PaginatedListLabelsResult> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/labels/list`, JSON.stringify(params))
            return await resp.json() as labels.PaginatedListLabelsResult
        }

        /**
         * Retrieves all nodes without pagination (useful for dropdowns).
         * @param params - Query parameters including orderBy, filters, and searchTerm
         * @returns {Promise<ListNodesResult>} Unified response with data property containing array of nodes
         * @throws {APIError} If retrieval fails
         */
        public async listNodes(params: nodes.ListNodesQueryParams): Promise<nodes.ListNodesResult> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/nodes/list/all`, JSON.stringify(params))
            return await resp.json() as nodes.ListNodesResult
        }

        /**
         * Retrieves nodes with pagination and includes related information.
         * @param params - Pagination and query parameters including page, pageSize, orderBy, filters, and searchTerm
         * @returns {Promise<PaginatedListNodesResult>} Unified paginated response with data and pagination properties including related information
         * @throws {APIError} If retrieval fails
         */
        public async listNodesPaginated(params: nodes.PaginatedListNodesQueryParams): Promise<nodes.PaginatedListNodesResult> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/nodes/list`, JSON.stringify(params))
            return await resp.json() as nodes.PaginatedListNodesResult
        }

        /**
         * Retrieves all pathways
         * @returns {Promise<Pathways>} All pathways
         * @throws {APIError} If the operation fails
         */
        public async listPathways(): Promise<pathways.Pathways> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/pathways`)
            return await resp.json() as pathways.Pathways
        }

        /**
         * Retrieves all pathways with pagination
         * @param params - Pagination parameters
         * @returns {Promise<PaginatedPathways>} Paginated pathways
         * @throws {APIError} If the operation fails
         */
        public async listPathwaysPaginated(params: shared.PaginationParams): Promise<pathways.PaginatedPathways> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                page:     params.page === undefined ? undefined : String(params.page),
                pageSize: params.pageSize === undefined ? undefined : String(params.pageSize),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/pathways/paginated`, undefined, {query})
            return await resp.json() as pathways.PaginatedPathways
        }

        /**
         * Retrieves all populations without pagination (useful for dropdowns).
         * @param params - Query parameters including orderBy, filters, and searchTerm
         * @returns {Promise<ListPopulationsResult>} Unified response with data property containing array of populations
         * @throws {APIError} If retrieval fails
         */
        public async listPopulations(params: populations.ListPopulationsQueryParams): Promise<populations.ListPopulationsResult> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/populations/list/all`, JSON.stringify(params))
            return await resp.json() as populations.ListPopulationsResult
        }

        /**
         * Retrieves populations with pagination (useful for tables).
         * @param params - Pagination and query parameters including page, pageSize, orderBy, filters, and searchTerm
         * @returns {Promise<PaginatedListPopulationsResult>} Unified paginated response with data and pagination properties
         * @throws {APIError} If retrieval fails
         */
        public async listPopulationsPaginated(params: populations.PaginatedListPopulationsQueryParams): Promise<populations.PaginatedListPopulationsResult> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/populations/list`, JSON.stringify(params))
            return await resp.json() as populations.PaginatedListPopulationsResult
        }

        /**
         * Retrieves all routes without pagination (useful for dropdowns).
         * @returns {Promise<Routes>} An object containing an array of routes
         * @throws {APIError} If retrieval fails
         */
        public async listRoutes(params: routes.RoutesQueryOptions): Promise<routes.Routes> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/get-routes`, JSON.stringify(params))
            return await resp.json() as routes.Routes
        }

        /**
         * Retrieves routes with pagination (useful for tables).
         * @param params - Pagination parameters
         * @returns {Promise<PaginatedRoutes>} Paginated list of routes
         * @throws {APIError} If retrieval fails
         */
        public async listRoutesPaginated(params: routes.PaginationParamsRoutes): Promise<routes.PaginatedRoutes> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/get-routes/paginated`, JSON.stringify(params))
            return await resp.json() as routes.PaginatedRoutes
        }

        /**
         * Retrieves all service types without pagination (useful for dropdowns).
         * @param params - Query options for filtering and sorting
         * @returns List of service types
         */
        public async listServiceTypes(params: service_types.ListServiceTypesQueryParams): Promise<service_types.ListServiceTypesResult> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/service-types/list/all`, JSON.stringify(params))
            return await resp.json() as service_types.ListServiceTypesResult
        }

        /**
         * Retrieves service types with pagination (useful for tables).
         * @param params - Pagination and query parameters
         * @returns Paginated list of service types
         */
        public async listServiceTypesPaginated(params: service_types.PaginatedListServiceTypesQueryParams): Promise<service_types.PaginatedListServiceTypesResult> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/service-types/list`, JSON.stringify(params))
            return await resp.json() as service_types.PaginatedListServiceTypesResult
        }

        /**
         * Retrieves all states without pagination (useful for dropdowns).
         */
        public async listStates(params: states.ListStatesQueryParams): Promise<states.ListStatesResult> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/states/list/all`, JSON.stringify(params))
            return await resp.json() as states.ListStatesResult
        }

        /**
         * Retrieves states with pagination (useful for tables).
         */
        public async listStatesPaginated(params: states.PaginatedListStatesQueryParams): Promise<states.PaginatedListStatesResult> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/states/list`, JSON.stringify(params))
            return await resp.json() as states.PaginatedListStatesResult
        }

        /**
         * Retrieves all timezones.
         * @returns {Timezones} An object containing an array of timezones
         */
        public async listTimezones(): Promise<timezones.Timezones> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/timezones`)
            return await resp.json() as timezones.Timezones
        }

        /**
         * Retrieves all transporters without pagination (useful for dropdowns).
         * @returns {Promise<Transporters>} An object containing an array of transporters with city info
         * @throws {APIError} If retrieval fails
         */
        public async listTransporters(params: transporters.ListTransportersQueryParams): Promise<transporters.ListTransportersResult> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/transporters/list/all`, JSON.stringify(params))
            return await resp.json() as transporters.ListTransportersResult
        }

        /**
         * Retrieves transporters with pagination and includes headquarter city information.
         * @param params - Pagination parameters
         * @returns {Promise<PaginatedListTransportersResult>} Paginated list of transporters with city info
         * @throws {APIError} If retrieval fails
         */
        public async listTransportersPaginated(params: transporters.PaginatedListTransportersQueryParams): Promise<transporters.PaginatedListTransportersResult> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/transporters/list`, JSON.stringify(params))
            return await resp.json() as transporters.PaginatedListTransportersResult
        }

        /**
         * Gets all valid initial statuses for a driver
         */
        public async listValidInitialStatuses(): Promise<drivers.ListStatusesResult> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/drivers/valid-initial-statuses/list`)
            return await resp.json() as drivers.ListStatusesResult
        }

        /**
         * Retrieves all zones for a specific seat diagram without pagination.
         * @param params - Object containing the seat diagram ID
         * @param params.seatDiagramId - The ID of the seat diagram
         * @returns {Promise<SeatDiagramZones>} List of zones for the seat diagram
         * @throws {APIError} If retrieval fails
         */
        public async listZonesByDiagram(seatDiagramId: number, params: {
    orderBy?: {
        field: "id" | "seatDiagramId" | "name" | "rowNumbers" | "priceMultiplier" | "createdAt" | "updatedAt"
        direction: "asc" | "desc"
    }[]
    filters?: {
        id?: number
        seatDiagramId?: number
        name?: string
        rowNumbers?: number[]
        priceMultiplier?: number
        createdAt?: string | string | null
        updatedAt?: string | string | null
    }
}): Promise<seat_diagram_zones.SeatDiagramZones> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/seat-diagrams/${encodeURIComponent(seatDiagramId)}/get-zones`, JSON.stringify(params))
            return await resp.json() as seat_diagram_zones.SeatDiagramZones
        }

        /**
         * Retrieves all zones for a specific bus diagram model without pagination.
         * @param params - Object containing the bus diagram model ID
         * @param params.busDiagramModelId - The ID of the bus diagram model
         * @returns {Promise<BusDiagramModelZones>} List of zones for the bus diagram model
         * @throws {APIError} If retrieval fails
         */
        public async listZonesByDiagramModel(busDiagramModelId: number, params: {
    orderBy?: {
        field: "id" | "busDiagramModelId" | "name" | "rowNumbers" | "priceMultiplier" | "createdAt" | "updatedAt"
        direction: "asc" | "desc"
    }[]
    filters?: {
        id?: number
        busDiagramModelId?: number
        name?: string
        rowNumbers?: number[]
        priceMultiplier?: number
        createdAt?: string | string | null
        updatedAt?: string | string | null
    }
}): Promise<bus_diagram_model_zones.BusDiagramModelZones> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/bus-diagram-models/${encodeURIComponent(busDiagramModelId)}/get-zones`, JSON.stringify(params))
            return await resp.json() as bus_diagram_model_zones.BusDiagramModelZones
        }

        /**
         * Retrieves zones for a specific bus diagram model with pagination.
         * @param params - Object containing the bus diagram model ID and pagination parameters
         * @param params.busDiagramModelId - The ID of the bus diagram model
         * @returns {Promise<PaginatedBusDiagramModelZones>} Paginated list of zones for the bus diagram model
         * @throws {APIError} If retrieval fails
         */
        public async listZonesByDiagramModelPaginated(busDiagramModelId: number, params: {
    page?: number
    pageSize?: number
    orderBy?: {
        field: "id" | "busDiagramModelId" | "name" | "rowNumbers" | "priceMultiplier" | "createdAt" | "updatedAt"
        direction: "asc" | "desc"
    }[]
    filters?: {
        id?: number
        busDiagramModelId?: number
        name?: string
        rowNumbers?: number[]
        priceMultiplier?: number
        createdAt?: string | string | null
        updatedAt?: string | string | null
    }
}): Promise<bus_diagram_model_zones.PaginatedBusDiagramModelZones> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/bus-diagram-models/${encodeURIComponent(busDiagramModelId)}/get-zones/paginated`, JSON.stringify(params))
            return await resp.json() as bus_diagram_model_zones.PaginatedBusDiagramModelZones
        }

        /**
         * Retrieves zones for a specific seat diagram with pagination.
         * @param params - Object containing the seat diagram ID and pagination parameters
         * @param params.seatDiagramId - The ID of the seat diagram
         * @returns {Promise<PaginatedSeatDiagramZones>} Paginated list of zones for the seat diagram
         * @throws {APIError} If retrieval fails
         */
        public async listZonesByDiagramPaginated(seatDiagramId: number, params: {
    page?: number
    pageSize?: number
    orderBy?: {
        field: "id" | "seatDiagramId" | "name" | "rowNumbers" | "priceMultiplier" | "createdAt" | "updatedAt"
        direction: "asc" | "desc"
    }[]
    filters?: {
        id?: number
        seatDiagramId?: number
        name?: string
        rowNumbers?: number[]
        priceMultiplier?: number
        createdAt?: string | string | null
        updatedAt?: string | string | null
    }
}): Promise<seat_diagram_zones.PaginatedSeatDiagramZones> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/seat-diagrams/${encodeURIComponent(seatDiagramId)}/get-zones/paginated`, JSON.stringify(params))
            return await resp.json() as seat_diagram_zones.PaginatedSeatDiagramZones
        }

        /**
         * Synchronizes seats from bus diagram model to all non-modified operational diagrams.
         * Finds all seat diagrams that reference this model and haven't been manually modified,
         * then updates their seats to match the current model configuration.
         * @param params - Object containing the bus diagram model ID
         * @param params.id - The ID of the bus diagram model to sync seats from
         * @returns {Promise<RegenerateSeatsResponse>} Summary of changes for each diagram that was synced
         * @throws {APIError} If the sync fails or the bus diagram model doesn't exist
         */
        public async regenerateSeats(id: number): Promise<bus_diagram_models.RegenerateSeatsResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/bus-diagram-models/${encodeURIComponent(id)}/regenerate-seats`)
            return await resp.json() as bus_diagram_models.RegenerateSeatsResponse
        }

        /**
         * Searches for routes by matching a search term against name and description.
         * @param params - Search parameters
         * @param params.term - The search term to match against route name and description
         * @returns {Promise<Routes>} List of matching routes
         * @throws {APIError} If search fails or no searchable fields are configured
         */
        public async searchRoutes(params: {
    term: string
}): Promise<routes.Routes> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                term: params.term,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/routes/search`, undefined, {query})
            return await resp.json() as routes.Routes
        }

        /**
         * Searches for routes with pagination by matching a search term against name and description.
         * @param params - Search and pagination parameters
         * @param params.term - The search term to match against route name and description
         * @param params.page - Page number for pagination (optional, default: 1)
         * @param params.pageSize - Number of items per page (optional, default: 10)
         * @param params.orderBy - Sorting criteria (optional)
         * @param params.filters - Additional filters to apply (optional)
         * @returns {Promise<PaginatedRoutes>} Paginated list of matching routes
         * @throws {APIError} If search fails or no searchable fields are configured
         */
        public async searchRoutesPaginated(params: {
    page?: number
    pageSize?: number
    orderBy?: {
        field: "id" | "name" | "description" | "originCityId" | "destinationCityId" | "pathwayId" | "distance" | "baseTime" | "isCompound" | "connectionCount" | "totalTravelTime" | "totalDistance" | "createdAt" | "updatedAt"
        direction: "asc" | "desc"
    }[]
    filters?: {
        id?: number
        name?: string
        description?: string | null
        originCityId?: number
        destinationCityId?: number
        pathwayId?: number | null
        distance?: number
        baseTime?: number
        isCompound?: boolean
        connectionCount?: number
        totalTravelTime?: number
        totalDistance?: number
        createdAt?: string | string | null
        updatedAt?: string | string | null
    }
    term: string
}): Promise<routes.PaginatedRoutes> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/routes/search/paginated`, JSON.stringify(params))
            return await resp.json() as routes.PaginatedRoutes
        }

        /**
         * Synchronizes installation schemas for a specific installation type.
         * Creates, updates, or deletes schemas based on the provided data.
         * @param params - Object containing the installation type ID and schemas to sync
         * @param params.id - The ID of the installation type to sync schemas for
         * @param params.schemas - Array of schema definitions to synchronize
         * @returns {Promise<ListInstallationSchemasResult>} Object containing array of synchronized installation schemas
         * @throws {APIError} If the installation type is not found or synchronization fails
         */
        public async syncInstallationSchemas(id: number, params: {
    schemas: installation_types.SyncInstallationSchemaPayload[]
}): Promise<installation_schemas.ListInstallationSchemasResult> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/installation/types/${encodeURIComponent(id)}/schemas`, JSON.stringify(params))
            return await resp.json() as installation_schemas.ListInstallationSchemasResult
        }

        /**
         * Updates an existing amenity.
         * @param params - Object containing the amenity ID and update data
         * @param params.id - The ID of the amenity to update
         * @returns {Promise<Amenity>} The updated amenity
         * @throws {APIError} If the amenity is not found or update fails
         */
        public async updateAmenity(id: number, params: {
    /**
     * Name of the amenity
     * Must have at least 1 non-whitespace character
     */
    name?: string

    /**
     * Category of the amenity
     * Must be one of the allowed categories
     */
    category?: amenities.AmenityCategory

    /**
     * Type of amenity within the category
     * Must be one of: 'bus', 'installation', 'service_type'
     */
    amenityType?: amenities.AmenityType

    /**
     * Optional description of the amenity
     */
    description?: string | null

    /**
     * Optional icon name for UI display
     */
    iconName?: string | null

    /**
     * Whether the amenity is active/available
     */
    active?: boolean
}): Promise<amenities.Amenity> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/amenities/${encodeURIComponent(id)}/update`, JSON.stringify(params))
            return await resp.json() as amenities.Amenity
        }

        /**
         * Updates an existing bus.
         * @param params - Object containing the bus ID and update data
         * @param params.id - The ID of the bus to update
         * @param params.data - The bus data to update
         * @returns {Promise<Bus>} The updated bus
         * @throws {APIError} If the bus is not found or update fails
         */
        public async updateBus(id: number, params: {
    economicNumber?: string
    registrationNumber?: string
    licensePlateType?: buses.BusLicensePlateType
    licensePlateNumber?: string
    circulationCard?: string | null
    availableForTourismOnly?: boolean
    status?: buses.BusStatus
    transporterId?: number | null
    alternateTransporterId?: number | null
    busLineId?: number | null
    baseId?: number | null
    /**
     * Model and manufacturer information
     */
    purchaseDate?: string | string | null

    expirationDate?: string | string | null
    erpClientNumber?: string | null
    modelId?: number
    /**
     * Technical information
     */
    vehicleId?: string | null

    serialNumber?: string
    engineNumber?: string | null
    chassisNumber?: string
    grossVehicleWeight?: number
    sctPermit?: string | null
    /**
     * Maintenance information
     */
    currentKilometer?: number | null

    gpsId?: string | null
    lastMaintenanceDate?: string | string | null
    nextMaintenanceDate?: string | string | null
    /**
     * Seat Diagram
     */
    seatDiagramId?: number

    /**
     * System information
     */
    active?: boolean
}): Promise<buses.Bus> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/buses/${encodeURIComponent(id)}/update`, JSON.stringify(params))
            return await resp.json() as buses.Bus
        }

        /**
         * Updates an existing bus diagram model and optionally regenerates seat models.
         * @param params - Object containing the bus diagram model ID and update data
         * @param params.id - The ID of the bus diagram model to update
         * @param params.regenerateSeats - Whether to regenerate seat models after update (default: false)
         * @returns {Promise<BusDiagramModel>} The updated bus diagram model
         * @throws {APIError} If update fails, validation fails, or the bus diagram model doesn't exist
         */
        public async updateBusDiagramModel(id: number, params: {
    /**
     * Name of the bus diagram model
     * Must have at least 1 character
     */
    name?: string

    /**
     * Description of the bus diagram model
     */
    description?: string

    /**
     * Maximum capacity
     * Must be a positive number
     */
    maxCapacity?: number

    /**
     * Number of floors in the bus diagram model
     * Must be a positive number
     */
    numFloors?: number

    /**
     * Configuration of seats per floor
     */
    seatsPerFloor?: shared.FloorSeats[]

    /**
     * Total number of seats
     */
    totalSeats?: number

    /**
     * Indicates if this is a factory default model
     */
    isFactoryDefault?: boolean

    /**
     * Whether the bus diagram model is active
     */
    active?: boolean

    regenerateSeats?: boolean
}): Promise<bus_diagram_models.BusDiagramModel> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PATCH", `/bus-diagram-models/${encodeURIComponent(id)}`, JSON.stringify(params))
            return await resp.json() as bus_diagram_models.BusDiagramModel
        }

        /**
         * Updates an existing bus diagram model zone.
         * @param params - Object containing the zone ID, model ID and update data
         * @param params.id - The ID of the zone to update
         * @param params.busDiagramModelId - The ID of the model the zone belongs to
         * @returns {Promise<BusDiagramModelZone>} The updated zone
         * @throws {APIError} If update fails or zone doesn't exist
         */
        public async updateBusDiagramModelZone(busDiagramModelId: number, id: number, params: {
    /**
     * Name of the zone
     * Must have at least 1 character
     */
    name?: string

    /**
     * Array of row numbers that belong to this zone
     */
    rowNumbers?: number[]

    /**
     * Price multiplier for seats in this zone
     */
    priceMultiplier?: number
}): Promise<bus_diagram_model_zones.BusDiagramModelZone> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PATCH", `/bus-diagram-models/${encodeURIComponent(busDiagramModelId)}/zones/${encodeURIComponent(id)}`, JSON.stringify(params))
            return await resp.json() as bus_diagram_model_zones.BusDiagramModelZone
        }

        /**
         * Updates an existing bus line.
         * @param params - Object containing the bus line ID and update data
         * @param params.id - The ID of the bus line to update
         * @returns {Promise<BusLine>} The updated bus line
         * @throws {APIError} If the bus line is not found or update fails
         */
        public async updateBusLine(id: number, params: {
    /**
     * The name of the bus line
     * Must have at least 1 non-whitespace character
     */
    name?: string

    /**
     * Unique business code for the bus line (1-20 characters)
     * Must contain only uppercase letters, numbers, and hyphens
     */
    code?: string

    /**
     * ID of the transporter that operates this bus line
     * Must be a positive number
     */
    transporterId?: number

    /**
     * ID of the service type of this bus line
     * Must be a positive number
     */
    serviceTypeId?: number

    /**
     * Multiplier for price per kilometer
     * Must be a positive number
     */
    pricePerKilometer?: number

    /**
     * Description of the bus line
     */
    description?: string

    /**
     * Number of vehicles in the fleet
     */
    fleetSize?: number | null

    /**
     * Website
     */
    website?: string

    /**
     * Email
     */
    email?: string

    /**
     * Phone
     */
    phone?: string

    /**
     * Whether the bus line is active
     */
    active?: boolean
}): Promise<bus_lines.BusLine> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/bus-lines/${encodeURIComponent(id)}/update`, JSON.stringify(params))
            return await resp.json() as bus_lines.BusLine
        }

        /**
         * Updates an existing bus model.
         * @param params - Object containing the bus model ID and update data
         * @param params.id - The ID of the bus model to update
         * @param params.data - The bus model data to update
         * @returns {Promise<BusModel>} The updated bus model
         * @throws {APIError} If the bus model is not found or update fails
         */
        public async updateBusModel(id: number, params: {
    /**
     * Default bus diagram model ID
     */
    defaultBusDiagramModelId?: number | null

    /**
     * Manufacturer of the bus
     * Must have at least 1 character
     */
    manufacturer?: string

    /**
     * Model name/number
     * Must have at least 1 character
     */
    model?: string

    /**
     * Year the bus model was released
     * Must be a positive number
     */
    year?: number

    /**
     * Total seating capacity
     * Must be a positive number
     */
    seatingCapacity?: number

    /**
     * Trunk capacity
     * Must be a positive number
     * Optional trunk capacity in liters (null if not specified)
     */
    trunkCapacity?: number | null

    /**
     * Fuel efficiency
     * Must be a positive number
     * Optional fuel efficiency in liters per kilometers (null if not specified)
     */
    fuelEfficiency?: number | null

    /**
     * Max capacity
     * Must be a positive number
     * Optional max capacity in liters (null if not specified)
     */
    maxCapacity?: number | null

    /**
     * Number of floors/decks in the bus
     */
    numFloors?: number

    /**
     * Available amenities
     */
    amenities?: string[]

    /**
     * Type of engine (e.g., diesel, electric)
     */
    engineType?: bus_models.EngineType

    /**
     * Whether the bus model is active
     */
    active?: boolean
}): Promise<bus_models.BusModel> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/bus-models/${encodeURIComponent(id)}/update`, JSON.stringify(params))
            return await resp.json() as bus_models.BusModel
        }

        /**
         * Updates an existing city.
         * @param params - Object containing the city ID and update data
         * @param params.id - The ID of the city to update
         * @returns {Promise<City>} The updated city
         * @throws {APIError} If the city is not found or update fails
         */
        public async updateCity(id: number, params: {
    /**
     * Name of the city
     * Must contain only letters (with or without accents) and spaces
     */
    name?: string

    /**
     * ID of the state this city belongs to
     * Must be a positive number
     */
    stateId?: number

    /**
     * Latitude of the city
     * Must be a number between -90 and 90
     */
    latitude?: number

    /**
     * Longitude of the city
     * Must be a number between -180 and 180
     */
    longitude?: number

    /**
     * Timezone of the city (e.g., "America/Mexico_City")
     * Must have at least 1 non-whitespace character
     */
    timezone?: string

    /**
     * Whether the city is active
     */
    active?: boolean
}): Promise<cities.City> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/cities/${encodeURIComponent(id)}/update`, JSON.stringify(params))
            return await resp.json() as cities.City
        }

        /**
         * Updates the segments of an existing compound route.
         * @param params - Data for updating compound route segments
         * @param params.compoundRouteId - ID of the compound route to update
         * @param params.routeIds - Array of route IDs to connect in sequence
         * @returns {Promise<RouteWithFullDetails>} The updated compound route with full details
         * @throws {APIError} If update fails, routes don't exist, or connections are invalid
         */
        public async updateCompoundRouteSegments(compoundRouteId: number, params: {
    routeIds: number[]
}): Promise<routes.RouteWithFullDetails> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/routes/compound/${encodeURIComponent(compoundRouteId)}/segments`, JSON.stringify(params))
            return await resp.json() as routes.RouteWithFullDetails
        }

        /**
         * Updates an existing country.
         * @param params - Object containing the country ID and update data
         * @param params.id - The ID of the country to update
         * @returns {Promise<Country>} The updated country
         * @throws {APIError} If the country is not found or update fails
         */
        public async updateCountry(id: number, params: {
    /**
     * Name of the country
     * Must have at least 1 non-whitespace character
     */
    name?: string

    /**
     * ISO country code (e.g., "US", "CA", "MX")
     * Must have at least 1 non-whitespace character
     */
    code?: string

    /**
     * Whether the country is active
     */
    active?: boolean
}): Promise<countries.Country> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/countries/${encodeURIComponent(id)}/update`, JSON.stringify(params))
            return await resp.json() as countries.Country
        }

        /**
         * Updates an existing driver.
         * @throws {APIError} If the driver is not found or update fails
         */
        public async updateDriver(id: number, params: {
    /**
     * Employee ID (Clave)
     * Must have at least 1 non-whitespace character
     */
    driverKey?: string

    /**
     * Full name of the driver
     * Must have at least 1 non-whitespace character
     */
    fullName?: string

    /**
     * Mexican tax ID (RFC)
     * Must have at least 1 non-whitespace character
     */
    rfc?: string

    /**
     * CURP Mexican national ID
     * Must have at least 1 non-whitespace character
     */
    curp?: string

    /**
     * Social security number (IMSS)
     */
    imss?: string

    /**
     * Civil status (Estado Civil)
     */
    civilStatus?: string

    /**
     * Number of dependents (Escolaridad)
     */
    dependents?: number

    /**
     * Street address (Calle)
     */
    addressStreet?: string

    /**
     * Neighborhood (Colonia)
     */
    addressNeighborhood?: string

    /**
     * City (Ciudad)
     */
    addressCity?: string

    /**
     * State (Estado)
     */
    addressState?: string

    /**
     * Postal code (Cdigo Postal)
     */
    postalCode?: string

    /**
     * Phone number (Telfono)
     * Must have at least 1 non-whitespace character
     */
    phoneNumber?: string

    /**
     * Email address (E-Mail)
     * Must be a valid email format
     */
    email?: string

    /**
     * Type of operator (Tipo Operador)
     * Must have at least 1 non-whitespace character
     */
    driverType?: drivers.DriverType

    /**
     * Department (Departamento)
     */
    department?: string

    /**
     * Position (Clave Puesto)
     */
    position?: drivers.DriverPosition

    /**
     * Office code (Clave Oficina)
     */
    officeCode?: string

    /**
     * Office location
     */
    officeLocation?: string

    /**
     * Date of hiring (Fec. Ingreso)
     */
    hireDate?: string

    /**
     * Current status (Estado Actual)
     */
    status?: drivers.DriverStatus

    /**
     * Status date (Fecha Estado)
     */
    statusDate?: string

    /**
     * Federal license (Licencia Federal)
     */
    federalLicense?: string

    /**
     * Federal license expiry (Fecha Lic. Fed)
     */
    federalLicenseExpiry?: string

    /**
     * State license (Licencia Estatal)
     */
    stateLicense?: string

    /**
     * State license expiry (Fecha Lic. Est)
     */
    stateLicenseExpiry?: string

    /**
     * Credit card info (Tarjeta Crdito)
     */
    creditCard?: string

    /**
     * Credit card expiry (Fecha T. Crdito)
     */
    creditCardExpiry?: string

    /**
     * Company (Empresa Alterna)
     */
    company?: string

    /**
     * Whether the driver is active
     */
    active?: boolean

    /**
     * The transporter this driver is associated with
     */
    transporterId?: number | null

    /**
     * The bus line this driver is associated with
     */
    busLineId?: number | null

    /**
     * The bus this driver is assigned to
     */
    busId?: number | null
}): Promise<drivers.Driver> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/drivers/${encodeURIComponent(id)}`, JSON.stringify(params))
            return await resp.json() as drivers.Driver
        }

        /**
         * Updates an existing event type.
         * @param params - Object containing the event type ID and update data
         * @param params.id - The ID of the event type to update
         * @returns {Promise<EventType>} The updated event type
         * @throws {APIError} If the event type is not found or update fails
         */
        public async updateEventType(id: number, params: {
    /**
     * Name of the event type (optional, but if provided must be non-empty)
     * Must have at least 1 non-whitespace character
     */
    name?: string

    /**
     * Unique code for the event type (optional, but if provided must be non-empty)
     * Must have at least 1 non-whitespace character
     */
    code?: string

    /**
     * Optional description of the event type
     */
    description?: string

    /**
     * Base time in minutes (optional, but if provided must be positive integer)
     * @minimum 1
     */
    baseTime?: number

    /**
     * Whether this event type requires cost tracking
     */
    needsCost?: boolean

    /**
     * Whether this event type requires quantity tracking
     */
    needsQuantity?: boolean

    /**
     * Whether this event type is part of system integration
     */
    integration?: boolean

    /**
     * Whether this event type is active
     */
    active?: boolean
}): Promise<event_types.EventType> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/event-types/${encodeURIComponent(id)}/update`, JSON.stringify(params))
            return await resp.json() as event_types.EventType
        }

        /**
         * Updates an existing installation.
         * @param params - Object containing the installation ID and update data
         * @param params.id - The ID of the installation to update
         * @returns {Promise<InstallationWithDetails>} The updated installation with location information
         * @throws {APIError} If the installation is not found or update fails
         */
        public async updateInstallation(id: number, params: {
    /**
     * Name of the installation
     * Must have at least 1 non-whitespace character
     */
    name?: string

    /**
     * Physical address of the installation
     * Must have at least 1 non-whitespace character
     */
    address?: string

    /**
     * Optional description of the installation
     */
    description?: string | null

    /**
     * Optional contact phone number for the installation
     * Must match phone number format if provided
     */
    contactPhone?: string | null

    /**
     * Optional contact email address for the installation
     * Must be a valid email format if provided
     */
    contactEmail?: string | null

    /**
     * Optional website URL for the installation
     * Must be a valid URL starting with http:// or https:// if provided
     */
    website?: string | null

    /**
     * ID of the installation type this installation belongs to
     * Must be a positive number
     */
    installationTypeId?: number | null

    /**
     * Operating hours of the installation
     */
    operatingHours?: installations.OperatingHours | null
}): Promise<installations.InstallationWithDetails> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/installations/${encodeURIComponent(id)}/update`, JSON.stringify(params))
            return await resp.json() as installations.InstallationWithDetails
        }

        /**
         * Updates installation properties by validating and upserting them
         * @param id - The ID of the installation to update properties for
         * @param properties - Array of property name/value pairs to validate and upsert
         * @returns The installation with updated properties
         */
        public async updateInstallationProperties(id: number, params: {
    properties: installation_properties.PropertyInput[]
}): Promise<installations.InstallationWithDetails> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/installations/${encodeURIComponent(id)}/properties/update`, JSON.stringify(params))
            return await resp.json() as installations.InstallationWithDetails
        }

        /**
         * Updates an existing installation schema.
         * @param params - Object containing the installation schema ID and update data
         * @param params.id - The ID of the installation schema to update
         * @returns {Promise<InstallationSchema>} The updated installation schema
         * @throws {APIError} If the installation schema is not found or update fails
         */
        public async updateInstallationSchema(id: number, params: {
    /**
     * Name of the schema field
     * Must have at least 1 non-whitespace character
     */
    name?: string

    /**
     * Optional description of the schema field
     */
    description?: string

    /**
     * Type of the field
     */
    type?: installation_schemas.InstallationSchemaFieldType

    /**
     * Configuration options for the field (only required for enum type)
     */
    options?: installation_schemas.InstallationSchemaOptions

    /**
     * Whether the field is required
     */
    required?: boolean

    /**
     * ID of the installation type this schema belongs to
     */
    installationTypeId?: number
}): Promise<installation_schemas.InstallationSchema> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/installation/schemas/${encodeURIComponent(id)}/update`, JSON.stringify(params))
            return await resp.json() as installation_schemas.InstallationSchema
        }

        /**
         * Updates an existing installation type.
         * @param params - Object containing the installation type ID and update data
         * @param params.id - The ID of the installation type to update
         * @returns {Promise<InstallationType>} The updated installation type
         * @throws {APIError} If the installation type is not found or update fails
         */
        public async updateInstallationType(id: number, params: {
    /**
     * Name of the installation type
     * Must have at least 1 non-whitespace character
     */
    name?: string

    /**
     * Code of the installation type
     * Must have at least 1 non-whitespace character
     */
    code?: string

    /**
     * Optional description of the installation type
     */
    description?: string | null

    /**
     * Whether the installation type is active
     * @default true
     */
    active?: boolean
}): Promise<installation_types.InstallationType> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/installation/types/${encodeURIComponent(id)}/update`, JSON.stringify(params))
            return await resp.json() as installation_types.InstallationType
        }

        /**
         * Updates an existing label.
         * @param params - The label ID and data to update
         * @returns {Promise<Label>} The updated label
         * @throws {APIError} If the label update fails or label is not found
         */
        public async updateLabel(id: number, params: {
    /**
     * Name of the label
     * Must have at least 1 non-whitespace character
     */
    name?: string

    /**
     * Optional description of the label
     */
    description?: string

    /**
     * Color of the label in hexadecimal format (#RRGGBB or #RGB)
     * Must be a valid hexadecimal color code
     */
    color?: string

    /**
     * Whether the label is active
     */
    active?: boolean
}): Promise<labels.Label> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/labels/${encodeURIComponent(id)}/update`, JSON.stringify(params))
            return await resp.json() as labels.Label
        }

        /**
         * Updates an existing node.
         * @param params - Object containing the node ID and update data
         * @param params.id - The ID of the node to update
         * @returns {Promise<Node>} The updated node
         * @throws {APIError} If the node is not found or update fails
         */
        public async updateNode(id: number, params: {
    /**
     * Unique code identifier for the node
     * Must have at least 1 non-whitespace character
     */
    code?: string

    /**
     * Name of the node
     * Must have at least 1 non-whitespace character
     */
    name?: string

    /**
     * Latitude coordinate of the node
     * Must be a number between -90 and 90
     */
    latitude?: number

    /**
     * Longitude coordinate of the node
     * Must be a number between -180 and 180
     */
    longitude?: number

    /**
     * Radius of coverage for the node in meters
     * Must be a positive number
     */
    radius?: number

    /**
     * Whether passengers can board at this node
     */
    allowsBoarding?: boolean

    /**
     * Whether passengers can alight at this node
     */
    allowsAlighting?: boolean

    /**
     * Whether the node is active or not
     */
    active?: boolean

    /**
     * ID of the city this node belongs to
     * Must be a positive number
     */
    cityId?: number

    /**
     * ID of the population this node belongs to
     * Must be a positive number
     */
    populationId?: number

    /**
     * Optional ID of the installation associated with this node
     * Must be a positive number if provided
     */
    installationId?: number
}): Promise<nodes.Node> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/nodes/${encodeURIComponent(id)}/update`, JSON.stringify(params))
            return await resp.json() as nodes.Node
        }

        /**
         * Updates an existing pathway
         * @param params - Object containing the pathway ID and update data
         * @param params.id - The ID of the pathway to update
         * @returns {Promise<Pathway>} The updated pathway
         * @throws {APIError} If the pathway is not found or update fails
         */
        public async updatePathway(id: number, params: {
    /**
     * Name of the pathway
     */
    name?: string

    /**
     * Distance of the pathway
     */
    distance?: number

    /**
     * Typical time to travel the pathway
     */
    typicalTime?: number

    /**
     * Metadata about the pathway
     */
    meta?: { [key: string]: string | number | boolean | null }

    /**
     * Whether the pathway is a toll road
     */
    tollRoad?: boolean

    /**
     * Whether the pathway is active
     */
    active?: boolean
}): Promise<pathways.Pathway> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/pathways/${encodeURIComponent(id)}`, JSON.stringify(params))
            return await resp.json() as pathways.Pathway
        }

        /**
         * Updates an existing population.
         * @param params - Object containing the population ID and update data
         * @param params.id - The ID of the population to update
         * @returns {Promise<Population>} The updated population
         * @throws {APIError} If the population is not found or update fails
         */
        public async updatePopulation(id: number, params: {
    /**
     * Unique code for the population
     * Must have at least 1 non-whitespace character
     */
    code?: string

    /**
     * Name of the population
     * Must have at least 1 non-whitespace character
     */
    name?: string

    /**
     * Description of the population
     */
    description?: string

    /**
     * Whether the population is active
     */
    active?: boolean
}): Promise<populations.Population> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/populations/${encodeURIComponent(id)}/update`, JSON.stringify(params))
            return await resp.json() as populations.Population
        }

        /**
         * Updates the seat configuration of a template seat layout in a single batch operation.
         * @param params - Object containing the bus diagram model ID and seat configurations
         * @param params.id - The ID of the bus diagram model to update
         * @param params.seats - Array of seat configurations to update/create/deactivate
         * @returns {Promise<UpdatedSeatConfiguration>} Statistics about the update operation and updated seat models
         * @throws {APIError} If the update fails, validation fails, or the bus diagram model doesn't exist
         */
        public async updateSeatConfiguration(id: number, params: {
    /**
     * Array of space configurations to update/create/deactivate
     */
    seats: bus_seat_models.SeatConfigurationInput[]
}): Promise<bus_seat_models.UpdatedSeatConfiguration> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/bus-diagram-models/${encodeURIComponent(id)}/update-seats`, JSON.stringify(params))
            return await resp.json() as bus_seat_models.UpdatedSeatConfiguration
        }

        /**
         * Updates an existing seat diagram.
         * @param params - Object containing the seat diagram ID and update data
         * @param params.id - The ID of the seat diagram to update
         * @param params.data - The seat diagram data to update
         * @returns {Promise<SeatDiagram>} The updated seat diagram
         * @throws {APIError} If update fails, validation fails, or the seat diagram doesn't exist
         */
        public async updateSeatDiagram(id: number, params: {
    /**
     * Name of the seat diagram
     * Must have at least 1 character
     */
    name?: string

    /**
     * Description of the seat diagram
     */
    description?: string

    /**
     * Maximum capacity
     * Must be a positive number
     */
    maxCapacity?: number

    /**
     * Number of floors in the seat diagram
     * Must be a positive number
     */
    numFloors?: number

    /**
     * Configuration of seats per floor
     */
    seatsPerFloor?: shared.FloorSeats[]

    /**
     * Total number of seats
     */
    totalSeats?: number

    /**
     * Indicates if this is a factory default diagram
     */
    isFactoryDefault?: boolean

    /**
     * Whether the seat diagram is active
     */
    active?: boolean
}): Promise<seat_diagrams.SeatDiagram> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PATCH", `/seat-diagrams/${encodeURIComponent(id)}`, JSON.stringify(params))
            return await resp.json() as seat_diagrams.SeatDiagram
        }

        /**
         * Updates the seat configuration of an operational seat layout in a single batch operation.
         * @param params - Object containing the seat diagram ID and seat configurations
         * @param params.id - The ID of the seat diagram to update
         * @param params.seats - Array of seat configurations to update/create/deactivate
         * @returns {Promise<UpdatedSeatConfiguration>} Statistics about the update operation and updated bus seats
         * @throws {APIError} If the update fails, validation fails, or the seat diagram doesn't exist
         */
        public async updateSeatDiagramConfiguration(id: number, params: {
    /**
     * Array of space configurations to update/create/deactivate
     */
    seats: bus_seats.SeatConfigurationInput[]
}): Promise<bus_seats.UpdatedSeatConfiguration> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/seat-diagrams/${encodeURIComponent(id)}/update-seats`, JSON.stringify(params))
            return await resp.json() as bus_seats.UpdatedSeatConfiguration
        }

        /**
         * Updates an existing seat diagram zone.
         * @param params - The zone data to update with ID
         * @returns {Promise<SeatDiagramZone>} The updated zone
         * @throws {APIError} If update fails or zone doesn't exist
         */
        public async updateSeatDiagramZone(seatDiagramId: number, id: number, params: {
    /**
     * Name of the zone
     * Must have at least 1 character
     */
    name?: string

    /**
     * Array of row numbers that belong to this zone
     */
    rowNumbers?: number[]

    /**
     * Price multiplier for seats in this zone
     */
    priceMultiplier?: number
}): Promise<seat_diagram_zones.SeatDiagramZone> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PATCH", `/seat-diagrams/${encodeURIComponent(seatDiagramId)}/zones/${encodeURIComponent(id)}`, JSON.stringify(params))
            return await resp.json() as seat_diagram_zones.SeatDiagramZone
        }

        /**
         * Updates an existing service type.
         * @param params - Object containing ID and update data
         * @returns The updated service type
         */
        public async updateServiceType(id: number, params: {
    /**
     * Name of the service type
     * Must have at least 1 non-whitespace character
     */
    name?: string

    /**
     * Unique business code for the service type
     * Must have at least 1 non-whitespace character
     */
    code?: string

    /**
     * Category for the service type
     * Must be one of the allowed categories
     */
    category?: service_types.ServiceTypeCategory

    /**
     * Description of the service type
     */
    description?: string

    /**
     * Whether the service type is active
     */
    active?: boolean
}): Promise<service_types.ServiceType> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/service-types/${encodeURIComponent(id)}/update`, JSON.stringify(params))
            return await resp.json() as service_types.ServiceType
        }

        /**
         * Updates an existing state.
         */
        public async updateState(id: number, params: {
    /**
     * Name of the state
     * Must have at least 1 non-whitespace character
     */
    name?: string

    /**
     * State code (e.g., "TX", "CA", "NY")
     * Must have at least 1 non-whitespace character
     */
    code?: string

    /**
     * ID of the country this state belongs to
     * Must be a positive number
     */
    countryId?: number

    /**
     * Whether the state is active
     */
    active?: boolean
}): Promise<states.State> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/states/${encodeURIComponent(id)}/update`, JSON.stringify(params))
            return await resp.json() as states.State
        }

        /**
         * Updates an existing transporter.
         * @param params - Object containing the transporter ID and update data
         * @param params.id - The ID of the transporter to update
         * @returns {Promise<Transporter>} The updated transporter
         * @throws {APIError} If the transporter is not found or update fails
         */
        public async updateTransporter(id: number, params: {
    /**
     * The name of the transportation company
     * Must have at least 1 non-whitespace character
     */
    name?: string

    /**
     * Unique business code for the transporter (1-10 characters)
     * Must contain only uppercase letters, numbers, and hyphens
     */
    code?: string

    /**
     * Description of the transporter
     */
    description?: string | null

    /**
     * Legal name (Razn Social) of the company
     */
    legalName?: string | null

    /**
     * Physical address of the headquarter/company
     */
    address?: string | null

    /**
     * Website URL of the transporter
     */
    website?: string | null

    /**
     * Contact email of the transporter
     */
    email?: string | null

    /**
     * Contact phone number of the transporter
     */
    phone?: string | null

    /**
     * ID of the city where the transporter is headquartered
     * Must be a positive number
     */
    headquarterCityId?: number | null

    /**
     * URL to the transporter's logo
     */
    logoUrl?: string | null

    /**
     * Additional contact information
     */
    contactInfo?: string | null

    /**
     * Regulatory license number
     */
    licenseNumber?: string | null

    /**
     * Whether the transporter is active
     */
    active?: boolean
}): Promise<transporters.Transporter> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/transporters/${encodeURIComponent(id)}/update`, JSON.stringify(params))
            return await resp.json() as transporters.Transporter
        }
    }
}

export namespace users {
    export interface AuthParams {
        authorization: string
    }

    export interface CreateUserPayload {
        /**
         * ID of the tenant this user belongs to
         */
        tenantId: number

        /**
         * ID of the department this user belongs to
         */
        departmentId: number

        /**
         * Username for login
         * Must have at least 3 non-whitespace characters
         */
        username: string

        /**
         * Email address of the user
         * Must be a valid email format
         */
        email: string

        /**
         * Password for the user
         * Will be hashed before storage
         * Must have at least 8 characters
         */
        password: string

        /**
         * First name of the user
         * Must have at least 1 non-whitespace character
         */
        firstName: string

        /**
         * Last name of the user
         * Must have at least 1 non-whitespace character
         */
        lastName: string

        /**
         * Phone number of the user
         */
        phone?: string

        /**
         * Job title/position of the user
         */
        position?: string

        /**
         * Internal employee ID
         */
        employeeId?: string

        /**
         * Whether the user is currently active
         * @default true
         */
        isActive?: boolean

        /**
         * Whether the user is a system-wide admin
         * @default false
         */
        isSystemAdmin?: boolean
    }

    export interface PaginatedUsers {
        pagination: shared.PaginationMeta
        data: SafeUser[]
    }

    export interface PaginationParamsUsers {
        page?: number
        pageSize?: number
        orderBy?: {
            field: "id" | "tenantId" | "departmentId" | "username" | "email" | "passwordHash" | "firstName" | "lastName" | "phone" | "position" | "employeeId" | "mfaSettings" | "lastLogin" | "isActive" | "isSystemAdmin" | "createdAt" | "updatedAt"
            direction: "asc" | "desc"
        }[]
        filters?: {
            id?: number
            tenantId?: number
            departmentId?: number
            username?: string
            email?: string
            firstName?: string
            lastName?: string
            phone?: string | null
            position?: string | null
            employeeId?: string | null
            mfaSettings?: { [key: string]: any } | null
            lastLogin?: string | string | null
            isActive?: boolean
            isSystemAdmin?: boolean
            createdAt?: string | string | null
            updatedAt?: string | string | null
        }
    }

    export interface SafeUser {
        id: number
        tenantId: number
        departmentId: number
        username: string
        email: string
        firstName: string
        lastName: string
        phone: string | null
        position: string | null
        employeeId: string | null
        mfaSettings: { [key: string]: any } | null
        lastLogin: string | string | null
        isActive: boolean
        isSystemAdmin: boolean
        createdAt: string | string | null
        updatedAt: string | string | null
    }

    export interface Users {
        /**
         * List of users (without sensitive data)
         */
        users: SafeUser[]
    }

    export interface UsersQueryOptions {
        orderBy?: {
            field: "id" | "tenantId" | "departmentId" | "username" | "email" | "passwordHash" | "firstName" | "lastName" | "phone" | "position" | "employeeId" | "mfaSettings" | "lastLogin" | "isActive" | "isSystemAdmin" | "createdAt" | "updatedAt"
            direction: "asc" | "desc"
        }[]
        filters?: {
            id?: number
            tenantId?: number
            departmentId?: number
            username?: string
            email?: string
            firstName?: string
            lastName?: string
            phone?: string | null
            position?: string | null
            employeeId?: string | null
            mfaSettings?: { [key: string]: any } | null
            lastLogin?: string | string | null
            isActive?: boolean
            isSystemAdmin?: boolean
            createdAt?: string | string | null
            updatedAt?: string | string | null
        }
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.assignPermissionsToRole = this.assignPermissionsToRole.bind(this)
            this.assignPermissionsToUser = this.assignPermissionsToUser.bind(this)
            this.assignRolesToUser = this.assignRolesToUser.bind(this)
            this.changePassword = this.changePassword.bind(this)
            this.checkUserPermission = this.checkUserPermission.bind(this)
            this.checkUserRole = this.checkUserRole.bind(this)
            this.createDepartment = this.createDepartment.bind(this)
            this.createPermission = this.createPermission.bind(this)
            this.createPermissionGroup = this.createPermissionGroup.bind(this)
            this.createRole = this.createRole.bind(this)
            this.createTenant = this.createTenant.bind(this)
            this.createUser = this.createUser.bind(this)
            this.deleteDepartment = this.deleteDepartment.bind(this)
            this.deletePermission = this.deletePermission.bind(this)
            this.deletePermissionGroup = this.deletePermissionGroup.bind(this)
            this.deleteRole = this.deleteRole.bind(this)
            this.deleteTenant = this.deleteTenant.bind(this)
            this.deleteUser = this.deleteUser.bind(this)
            this.getDepartment = this.getDepartment.bind(this)
            this.getPermission = this.getPermission.bind(this)
            this.getRole = this.getRole.bind(this)
            this.getRoleWithPermissions = this.getRoleWithPermissions.bind(this)
            this.getTenant = this.getTenant.bind(this)
            this.getUser = this.getUser.bind(this)
            this.getUserPermissions = this.getUserPermissions.bind(this)
            this.getUserRoles = this.getUserRoles.bind(this)
            this.getUserWithPermissions = this.getUserWithPermissions.bind(this)
            this.getUserWithRoles = this.getUserWithRoles.bind(this)
            this.listAuditsPaginated = this.listAuditsPaginated.bind(this)
            this.listDepartmentUsers = this.listDepartmentUsers.bind(this)
            this.listDepartmentUsersPaginated = this.listDepartmentUsersPaginated.bind(this)
            this.listDepartments = this.listDepartments.bind(this)
            this.listDepartmentsPaginated = this.listDepartmentsPaginated.bind(this)
            this.listPermissionGroups = this.listPermissionGroups.bind(this)
            this.listPermissions = this.listPermissions.bind(this)
            this.listPermissionsWithPagination = this.listPermissionsWithPagination.bind(this)
            this.listRoles = this.listRoles.bind(this)
            this.listRolesByTenant = this.listRolesByTenant.bind(this)
            this.listRolesByTenantWithPagination = this.listRolesByTenantWithPagination.bind(this)
            this.listRolesByTenantWithPermissions = this.listRolesByTenantWithPermissions.bind(this)
            this.listRolesWithPagination = this.listRolesWithPagination.bind(this)
            this.listRolesWithPermissions = this.listRolesWithPermissions.bind(this)
            this.listRolesWithPermissionsAndPagination = this.listRolesWithPermissionsAndPagination.bind(this)
            this.listTenantDepartments = this.listTenantDepartments.bind(this)
            this.listTenantDepartmentsPaginated = this.listTenantDepartmentsPaginated.bind(this)
            this.listTenantRoles = this.listTenantRoles.bind(this)
            this.listTenantRolesWithPagination = this.listTenantRolesWithPagination.bind(this)
            this.listTenantUsers = this.listTenantUsers.bind(this)
            this.listTenantUsersPaginated = this.listTenantUsersPaginated.bind(this)
            this.listTenants = this.listTenants.bind(this)
            this.listTenantsWithPagination = this.listTenantsWithPagination.bind(this)
            this.listUsers = this.listUsers.bind(this)
            this.listUsersPaginated = this.listUsersPaginated.bind(this)
            this.login = this.login.bind(this)
            this.logout = this.logout.bind(this)
            this.refreshToken = this.refreshToken.bind(this)
            this.revokeAllTokens = this.revokeAllTokens.bind(this)
            this.searchDepartments = this.searchDepartments.bind(this)
            this.searchDepartmentsPaginated = this.searchDepartmentsPaginated.bind(this)
            this.searchPermissions = this.searchPermissions.bind(this)
            this.searchPermissionsPaginated = this.searchPermissionsPaginated.bind(this)
            this.searchRoles = this.searchRoles.bind(this)
            this.searchRolesPaginated = this.searchRolesPaginated.bind(this)
            this.searchTenants = this.searchTenants.bind(this)
            this.searchTenantsPaginated = this.searchTenantsPaginated.bind(this)
            this.searchUsers = this.searchUsers.bind(this)
            this.searchUsersPaginated = this.searchUsersPaginated.bind(this)
            this.updateDepartment = this.updateDepartment.bind(this)
            this.updatePermission = this.updatePermission.bind(this)
            this.updatePermissionGroup = this.updatePermissionGroup.bind(this)
            this.updateRole = this.updateRole.bind(this)
            this.updateTenant = this.updateTenant.bind(this)
            this.updateUser = this.updateUser.bind(this)
        }

        /**
         * Assigns permissions to a role.
         * @param params - Object containing the role ID and permission IDs
         * @param params.id - The ID of the role
         * @param params.permissionIds - The IDs of the permissions to assign
         * @returns {Promise<RoleWithPermissions>} The role with updated permissions
         * @throws {APIError} If the role is not found or assignment fails
         */
        public async assignPermissionsToRole(id: number, params: {
    /**
     * IDs of permissions to assign to the role
     */
    permissionIds: number[]
}): Promise<roles.RoleWithPermissions> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/roles/${encodeURIComponent(id)}/permissions`, JSON.stringify(params))
            return await resp.json() as roles.RoleWithPermissions
        }

        /**
         * Assigns permissions directly to a user.
         * @param params - Object containing the user ID and permission IDs
         * @param params.userId - The ID of the user
         * @param params.permissionIds - The IDs of the permissions to assign
         * @returns {Promise<UserWithPermissions>} The user with updated permissions
         * @throws {APIError} If the user is not found or assignment fails
         */
        public async assignPermissionsToUser(userId: number, params: {
    /**
     * IDs of permissions to assign to the user
     */
    permissionIds: number[]
}): Promise<user_permissions.UserWithPermissions> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/users/${encodeURIComponent(userId)}/permissions`, JSON.stringify(params))
            return await resp.json() as user_permissions.UserWithPermissions
        }

        /**
         * Assigns roles to a user.
         * @param params - Object containing the user ID and role IDs
         * @param params.userId - The ID of the user
         * @param params.roleIds - The IDs of the roles to assign
         * @returns {Promise<UserWithRoles>} The user with updated roles
         * @throws {APIError} If the user is not found or assignment fails
         */
        public async assignRolesToUser(userId: number, params: {
    /**
     * IDs of roles to assign to the user
     */
    roleIds: number[]
}): Promise<user_permissions.UserWithRoles> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/users/${encodeURIComponent(userId)}/roles`, JSON.stringify(params))
            return await resp.json() as user_permissions.UserWithRoles
        }

        /**
         * Changes a user's password
         * @param params - Object containing the user ID and password data
         * @param params.id - The ID of the user to update
         * @returns {Promise<SafeUser>} The updated user (without password hash)
         * @throws {APIError} If the user is not found, current password is invalid, or update fails
         */
        public async changePassword(id: number, params: {
    /**
     * Current password for verification
     */
    currentPassword: string

    /**
     * New password to set
     * Must have at least 8 characters
     */
    newPassword: string
}): Promise<SafeUser> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/users/${encodeURIComponent(id)}/password`, JSON.stringify(params))
            return await resp.json() as SafeUser
        }

        /**
         * Checks if a user has a specific permission.
         * @param params - Object containing the user ID and permission code
         * @param params.userId - The ID of the user
         * @param params.permissionCode - The code of the permission to check
         * @returns {Promise<{hasPermission: boolean}>} Whether the user has the permission
         * @throws {APIError} If permission check fails or the user is unauthorized
         */
        public async checkUserPermission(userId: number, permissionCode: string): Promise<{
    hasPermission: boolean
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/users/${encodeURIComponent(userId)}/permissions/${encodeURIComponent(permissionCode)}/check`)
            return await resp.json() as {
    hasPermission: boolean
}
        }

        /**
         * Checks if a user has a specific role.
         * @param params - Object containing the user ID and role ID
         * @param params.userId - The ID of the user
         * @param params.roleId - The ID of the role to check
         * @returns {Promise<{hasRole: boolean}>} Whether the user has the role
         * @throws {APIError} If role check fails or the user is unauthorized
         */
        public async checkUserRole(userId: number, roleId: number): Promise<{
    hasRole: boolean
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/users/${encodeURIComponent(userId)}/roles/${encodeURIComponent(roleId)}/check`)
            return await resp.json() as {
    hasRole: boolean
}
        }

        /**
         * Creates a new department.
         * @param params - The department data to create
         * @returns {Promise<Department>} The created department
         * @throws {APIError} If the department creation fails
         */
        public async createDepartment(params: departments.CreateDepartmentPayload): Promise<departments.Department> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/departments`, JSON.stringify(params))
            return await resp.json() as departments.Department
        }

        /**
         * Creates a new permission.
         * @param params - The permission data to create
         * @returns {Promise<Permission>} The created permission
         * @throws {APIError} If the permission creation fails
         */
        public async createPermission(params: permissions.CreatePermissionPayload): Promise<permissions.Permission> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/permissions`, JSON.stringify(params))
            return await resp.json() as permissions.Permission
        }

        /**
         * Creates a new permission group.
         * @param params - The permission group data to create
         * @returns {Promise<PermissionGroup>} The created permission group
         * @throws {APIError} If the permission group creation fails
         */
        public async createPermissionGroup(params: permission_groups.CreatePermissionGroupPayload): Promise<permission_groups.PermissionGroup> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/permission-groups`, JSON.stringify(params))
            return await resp.json() as permission_groups.PermissionGroup
        }

        /**
         * Creates a new role.
         * @param params - The role data to create
         * @returns {Promise<RoleWithPermissions>} The created role with permissions
         * @throws {APIError} If the role creation fails
         */
        public async createRole(params: roles.CreateRolePayload): Promise<roles.RoleWithPermissions> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/roles`, JSON.stringify(params))
            return await resp.json() as roles.RoleWithPermissions
        }

        /**
         * Creates a new tenant.
         * @param params - The tenant data to create
         * @returns {Promise<Tenant>} The created tenant
         * @throws {APIError} If the tenant creation fails
         */
        public async createTenant(params: tenants.CreateTenantPayload): Promise<tenants.Tenant> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/tenants`, JSON.stringify(params))
            return await resp.json() as tenants.Tenant
        }

        /**
         * Creates a new user
         * @param params - The user data to create
         * @returns {Promise<SafeUser>} The created user (without password hash)
         * @throws {APIError} If the user creation fails
         */
        public async createUser(params: CreateUserPayload): Promise<SafeUser> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/users`, JSON.stringify(params))
            return await resp.json() as SafeUser
        }

        /**
         * Deletes a department by ID.
         * @param params - Object containing the department ID
         * @param params.id - The ID of the department to delete
         * @returns {Promise<Department>} The deleted department
         * @throws {APIError} If the department is not found or deletion fails
         */
        public async deleteDepartment(id: number): Promise<departments.Department> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/departments/${encodeURIComponent(id)}`)
            return await resp.json() as departments.Department
        }

        /**
         * Deletes a permission by ID.
         * @param params - Object containing the permission ID
         * @param params.id - The ID of the permission to delete
         * @returns {Promise<Permission>} The deleted permission
         * @throws {APIError} If the permission is not found or deletion fails
         */
        public async deletePermission(id: number): Promise<permissions.Permission> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/permissions/${encodeURIComponent(id)}`)
            return await resp.json() as permissions.Permission
        }

        /**
         * Deletes a permission group by its ID.
         * @param id - The ID of the permission group to delete
         * @returns {Promise<PermissionGroup>} The deleted permission group
         * @throws {APIError} If the permission group is not found or deletion fails
         */
        public async deletePermissionGroup(id: number): Promise<permission_groups.PermissionGroup> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/permission-groups/${encodeURIComponent(id)}`)
            return await resp.json() as permission_groups.PermissionGroup
        }

        /**
         * Deletes a role by ID.
         * @param params - Object containing the role ID
         * @param params.id - The ID of the role to delete
         * @returns {Promise<Role>} The deleted role
         * @throws {APIError} If the role is not found or deletion fails
         */
        public async deleteRole(id: number): Promise<roles.Role> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/roles/${encodeURIComponent(id)}`)
            return await resp.json() as roles.Role
        }

        /**
         * Deletes a tenant by ID.
         * @param params - Object containing the tenant ID
         * @param params.id - The ID of the tenant to delete
         * @returns {Promise<Tenant>} The deleted tenant
         * @throws {APIError} If the tenant is not found or deletion fails
         */
        public async deleteTenant(id: number): Promise<tenants.Tenant> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/tenants/${encodeURIComponent(id)}`)
            return await resp.json() as tenants.Tenant
        }

        /**
         * Deletes a user by ID
         * @param params - Object containing the user ID
         * @param params.id - The ID of the user to delete
         * @returns {Promise<SafeUser>} The deleted user (without password hash)
         * @throws {APIError} If the user is not found or deletion fails
         */
        public async deleteUser(id: number): Promise<SafeUser> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/users/${encodeURIComponent(id)}`)
            return await resp.json() as SafeUser
        }

        /**
         * Retrieves a department by ID.
         * @param params - Object containing the department ID
         * @param params.id - The ID of the department to retrieve
         * @returns {Promise<Department>} The found department
         * @throws {APIError} If the department is not found or retrieval fails
         */
        public async getDepartment(id: number): Promise<departments.Department> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/departments/${encodeURIComponent(id)}`)
            return await resp.json() as departments.Department
        }

        /**
         * Retrieves a permission by ID.
         * @param params - Object containing the permission ID
         * @param params.id - The ID of the permission to retrieve
         * @returns {Promise<Permission>} The found permission
         * @throws {APIError} If the permission is not found or retrieval fails
         */
        public async getPermission(id: number): Promise<permissions.Permission> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/permissions/${encodeURIComponent(id)}`)
            return await resp.json() as permissions.Permission
        }

        /**
         * Retrieves a role by ID.
         * @param params - Object containing the role ID
         * @param params.id - The ID of the role to retrieve
         * @returns {Promise<Role>} The found role
         * @throws {APIError} If the role is not found or retrieval fails
         */
        public async getRole(id: number): Promise<roles.Role> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/roles/${encodeURIComponent(id)}`)
            return await resp.json() as roles.Role
        }

        /**
         * Retrieves a role by ID with its permissions.
         * @param params - Object containing the role ID
         * @param params.id - The ID of the role to retrieve
         * @returns {Promise<RoleWithPermissions>} The found role with permissions
         * @throws {APIError} If the role is not found or retrieval fails
         */
        public async getRoleWithPermissions(id: number): Promise<roles.RoleWithPermissions> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/roles/${encodeURIComponent(id)}/with-permissions`)
            return await resp.json() as roles.RoleWithPermissions
        }

        /**
         * Retrieves a tenant by ID.
         * @param params - Object containing the tenant ID
         * @param params.id - The ID of the tenant to retrieve
         * @returns {Promise<Tenant>} The found tenant
         * @throws {APIError} If the tenant is not found or retrieval fails
         */
        public async getTenant(id: number): Promise<tenants.Tenant> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/tenants/${encodeURIComponent(id)}`)
            return await resp.json() as tenants.Tenant
        }

        /**
         * Retrieves a user by ID
         * @param params - Object containing the user ID
         * @param params.id - The ID of the user to retrieve
         * @returns {Promise<SafeUser>} The found user (without password hash)
         * @throws {APIError} If the user is not found
         */
        public async getUser(id: number): Promise<SafeUser> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/users/${encodeURIComponent(id)}`)
            return await resp.json() as SafeUser
        }

        /**
         * Retrieves a user with their effective permissions (combined from direct assignments and roles).
         * @param params - Object containing the user ID
         * @param params.userId - The ID of the user to retrieve
         * @returns {Promise<UserWithPermissions>} The user with their effective permissions
         * @throws {APIError} If the user is not found or retrieval fails
         */
        public async getUserPermissions(userId: number): Promise<user_permissions.UserWithPermissions> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/users/${encodeURIComponent(userId)}/effective-permissions`)
            return await resp.json() as user_permissions.UserWithPermissions
        }

        /**
         * Retrieves a user with their roles.
         * @param params - Object containing the user ID
         * @param params.userId - The ID of the user to retrieve
         * @returns {Promise<UserWithRoles>} The user with their roles
         * @throws {APIError} If the user is not found or retrieval fails
         */
        public async getUserRoles(userId: number): Promise<user_permissions.UserWithRoles> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/users/${encodeURIComponent(userId)}/assigned-roles`)
            return await resp.json() as user_permissions.UserWithRoles
        }

        /**
         * Retrieves a user with their assigned permissions.
         * @param params - Object containing the user ID
         * @param params.userId - The ID of the user to retrieve
         * @returns {Promise<UserWithPermissions>} The user with their permissions
         * @throws {APIError} If the user is not found or retrieval fails
         */
        public async getUserWithPermissions(userId: number): Promise<user_permissions.UserWithPermissions> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/users/${encodeURIComponent(userId)}/permissions`)
            return await resp.json() as user_permissions.UserWithPermissions
        }

        /**
         * Retrieves a user with their assigned roles.
         * @param params - Object containing the user ID
         * @param params.userId - The ID of the user to retrieve
         * @returns {Promise<UserWithRoles>} The user with their roles
         * @throws {APIError} If the user is not found or retrieval fails
         */
        public async getUserWithRoles(userId: number): Promise<user_permissions.UserWithRoles> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/users/${encodeURIComponent(userId)}/roles`)
            return await resp.json() as user_permissions.UserWithRoles
        }

        /**
         * Retrieves paginated audit entries with optional filtering
         * @param params - Pagination parameters with optional filtering (by service, userId, etc.)
         * @returns {Promise<PaginatedAudits>} Paginated list of audit entries
         */
        public async listAuditsPaginated(params: audits.PaginationParamsAudits): Promise<audits.PaginatedAudits> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/audits/paginated`, JSON.stringify(params))
            return await resp.json() as audits.PaginatedAudits
        }

        /**
         * Retrieves users for a specific department with optional filtering and ordering
         * @param params - Object containing the department ID and query options
         * @param params.departmentId - The ID of the department to get users for
         * @returns {Promise<Users>} List of users for the department (without password hashes)
         * @throws {APIError} If retrieval fails
         */
        public async listDepartmentUsers(departmentId: number, params: {
    orderBy?: {
        field: "id" | "tenantId" | "departmentId" | "username" | "email" | "passwordHash" | "firstName" | "lastName" | "phone" | "position" | "employeeId" | "mfaSettings" | "lastLogin" | "isActive" | "isSystemAdmin" | "createdAt" | "updatedAt"
        direction: "asc" | "desc"
    }[]
    filters?: {
        id?: number
        tenantId?: number
        departmentId?: number
        username?: string
        email?: string
        firstName?: string
        lastName?: string
        phone?: string | null
        position?: string | null
        employeeId?: string | null
        mfaSettings?: { [key: string]: any } | null
        lastLogin?: string | string | null
        isActive?: boolean
        isSystemAdmin?: boolean
        createdAt?: string | string | null
        updatedAt?: string | string | null
    }
}): Promise<Users> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/departments/${encodeURIComponent(departmentId)}/users`, JSON.stringify(params))
            return await resp.json() as Users
        }

        /**
         * Retrieves paginated users for a specific department with filtering and ordering
         * @param params - Object containing the department ID and pagination/query parameters
         * @param params.departmentId - The ID of the department to get users for
         * @returns {Promise<PaginatedUsers>} Paginated list of users for the department
         * @throws {APIError} If retrieval fails
         */
        public async listDepartmentUsersPaginated(departmentId: number, params: {
    page?: number
    pageSize?: number
    orderBy?: {
        field: "id" | "tenantId" | "departmentId" | "username" | "email" | "passwordHash" | "firstName" | "lastName" | "phone" | "position" | "employeeId" | "mfaSettings" | "lastLogin" | "isActive" | "isSystemAdmin" | "createdAt" | "updatedAt"
        direction: "asc" | "desc"
    }[]
    filters?: {
        id?: number
        tenantId?: number
        departmentId?: number
        username?: string
        email?: string
        firstName?: string
        lastName?: string
        phone?: string | null
        position?: string | null
        employeeId?: string | null
        mfaSettings?: { [key: string]: any } | null
        lastLogin?: string | string | null
        isActive?: boolean
        isSystemAdmin?: boolean
        createdAt?: string | string | null
        updatedAt?: string | string | null
    }
}): Promise<PaginatedUsers> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/departments/${encodeURIComponent(departmentId)}/users/paginated`, JSON.stringify(params))
            return await resp.json() as PaginatedUsers
        }

        /**
         * Retrieves all departments with optional filtering and ordering (useful for dropdowns).
         * @param params - Query options for filtering and ordering
         * @returns {Promise<Departments>} List of all departments
         * @throws {APIError} If retrieval fails
         */
        public async listDepartments(params: departments.DepartmentsQueryOptions): Promise<departments.Departments> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/get-departments`, JSON.stringify(params))
            return await resp.json() as departments.Departments
        }

        /**
         * Retrieves departments with pagination, filtering, and ordering (useful for tables).
         * @param params - Pagination, filtering, and ordering parameters
         * @returns {Promise<PaginatedDepartments>} Paginated list of departments
         * @throws {APIError} If retrieval fails
         */
        public async listDepartmentsPaginated(params: departments.PaginationParamsDepartments): Promise<departments.PaginatedDepartments> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/get-departments/paginated`, JSON.stringify(params))
            return await resp.json() as departments.PaginatedDepartments
        }

        /**
         * Retrieves all permission groups.
         * @returns {Promise<PermissionGroups>} An object containing an array of permission groups
         * @throws {APIError} If the retrieval fails
         */
        public async listPermissionGroups(): Promise<permission_groups.PermissionGroups> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/permission-groups`)
            return await resp.json() as permission_groups.PermissionGroups
        }

        /**
         * Retrieves all permissions with optional filtering and ordering.
         * @param params - Query options for filtering and ordering
         * @returns {Promise<Permissions>} List of all permissions
         * @throws {APIError} If the retrieval fails
         */
        public async listPermissions(params: permissions.PermissionsQueryOptions): Promise<permissions.Permissions> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/get-permissions`, JSON.stringify(params))
            return await resp.json() as permissions.Permissions
        }

        /**
         * Retrieves permissions with pagination, filtering, and ordering.
         * @param params - Pagination, filtering, and ordering parameters
         * @returns {Promise<PaginatedPermissions>} Paginated list of permissions
         * @throws {APIError} If retrieval fails
         */
        public async listPermissionsWithPagination(params: permissions.PaginationParamsPermissions): Promise<permissions.PaginatedPermissions> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/get-permissions/paginated`, JSON.stringify(params))
            return await resp.json() as permissions.PaginatedPermissions
        }

        /**
         * Retrieves all roles with optional filtering, ordering, and permissions.
         * @param params - Query options for filtering, ordering, and including permissions
         * @returns {Promise<Roles>} List of roles
         * @throws {APIError} If the retrieval fails
         */
        public async listRoles(params: roles.RolesQueryOptions): Promise<roles.Roles> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/get-roles`, JSON.stringify(params))
            return await resp.json() as roles.Roles
        }

        /**
         * Retrieves all roles for a tenant with optional filtering and ordering.
         * @param params - Object containing the tenant ID and query options
         * @param params.tenantId - The ID of the tenant
         * @returns {Promise<Roles>} List of roles for the tenant
         * @throws {APIError} If the retrieval fails
         */
        public async listRolesByTenant(tenantId: number, params: {
    orderBy?: {
        field: "id" | "name" | "description" | "tenantId" | "createdAt" | "updatedAt"
        direction: "asc" | "desc"
    }[]
    filters?: {
        id?: number
        name?: string
        description?: string | null
        tenantId?: number
        createdAt?: string | string | null
        updatedAt?: string | string | null
    }
    includePermissions?: boolean
}): Promise<roles.Roles> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/tenants/${encodeURIComponent(tenantId)}/get-roles`, JSON.stringify(params))
            return await resp.json() as roles.Roles
        }

        /**
         * Retrieves roles for a tenant with pagination, filtering, and ordering.
         * @param params - Object containing the tenant ID and pagination parameters
         * @param params.tenantId - The ID of the tenant
         * @returns {Promise<PaginatedRoles>} Paginated list of roles for the tenant
         * @throws {APIError} If retrieval fails
         */
        public async listRolesByTenantWithPagination(tenantId: number, params: {
    page?: number
    pageSize?: number
    orderBy?: {
        field: "id" | "name" | "description" | "tenantId" | "createdAt" | "updatedAt"
        direction: "asc" | "desc"
    }[]
    filters?: {
        id?: number
        name?: string
        description?: string | null
        tenantId?: number
        createdAt?: string | string | null
        updatedAt?: string | string | null
    }
    includePermissions?: boolean
}): Promise<roles.PaginatedRoles> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/tenants/${encodeURIComponent(tenantId)}/get-roles/paginated`, JSON.stringify(params))
            return await resp.json() as roles.PaginatedRoles
        }

        /**
         * Retrieves all roles for a tenant with permissions (maintains backward compatibility).
         * @param params - Object containing the tenant ID
         * @param params.tenantId - The ID of the tenant
         * @returns {Promise<RolesWithPermissions>} List of roles for the tenant with permissions
         * @throws {APIError} If the retrieval fails
         */
        public async listRolesByTenantWithPermissions(tenantId: number): Promise<roles.RolesWithPermissions> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/tenants/${encodeURIComponent(tenantId)}/roles/with-permissions`)
            return await resp.json() as roles.RolesWithPermissions
        }

        /**
         * Retrieves roles with pagination, filtering, and ordering.
         * @param params - Pagination, filtering, and ordering parameters
         * @returns {Promise<PaginatedRoles>} Paginated list of roles
         * @throws {APIError} If retrieval fails
         */
        public async listRolesWithPagination(params: roles.PaginationParamsRoles): Promise<roles.PaginatedRoles> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/get-roles/paginated`, JSON.stringify(params))
            return await resp.json() as roles.PaginatedRoles
        }

        /**
         * Retrieves all roles with their permissions (maintains backward compatibility).
         * @returns {Promise<RolesWithPermissions>} List of all roles with permissions
         * @throws {APIError} If the retrieval fails
         */
        public async listRolesWithPermissions(): Promise<roles.RolesWithPermissions> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/roles/with-permissions`)
            return await resp.json() as roles.RolesWithPermissions
        }

        /**
         * Retrieves roles with permissions and pagination (maintains backward compatibility).
         * @param params - Pagination parameters
         * @returns {Promise<PaginatedRolesWithPermissions>} Paginated list of roles with permissions
         * @throws {APIError} If retrieval fails
         */
        public async listRolesWithPermissionsAndPagination(params: roles.PaginationParamsRoles): Promise<roles.PaginatedRolesWithPermissions> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/roles/with-permissions/paginated`, JSON.stringify(params))
            return await resp.json() as roles.PaginatedRolesWithPermissions
        }

        /**
         * Retrieves departments for a specific tenant with optional filtering and ordering.
         * @param params - Object containing the tenant ID and query options
         * @param params.tenantId - The ID of the tenant to get departments for
         * @returns {Promise<Departments>} List of departments for the tenant
         * @throws {APIError} If retrieval fails
         */
        public async listTenantDepartments(tenantId: number, params: {
    orderBy?: {
        field: "id" | "tenantId" | "name" | "code" | "description" | "isActive" | "createdAt" | "updatedAt"
        direction: "asc" | "desc"
    }[]
    filters?: {
        id?: number
        tenantId?: number
        name?: string
        code?: string
        description?: string | null
        isActive?: boolean
        createdAt?: string | string | null
        updatedAt?: string | string | null
    }
}): Promise<departments.Departments> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/tenants/${encodeURIComponent(tenantId)}/departments`, JSON.stringify(params))
            return await resp.json() as departments.Departments
        }

        /**
         * Retrieves paginated departments for a specific tenant with filtering and ordering.
         * @param params - Object containing the tenant ID and pagination/query parameters
         * @param params.tenantId - The ID of the tenant to get departments for
         * @returns {Promise<PaginatedDepartments>} Paginated list of departments for the tenant
         * @throws {APIError} If retrieval fails
         */
        public async listTenantDepartmentsPaginated(tenantId: number, params: {
    page?: number
    pageSize?: number
    orderBy?: {
        field: "id" | "tenantId" | "name" | "code" | "description" | "isActive" | "createdAt" | "updatedAt"
        direction: "asc" | "desc"
    }[]
    filters?: {
        id?: number
        tenantId?: number
        name?: string
        code?: string
        description?: string | null
        isActive?: boolean
        createdAt?: string | string | null
        updatedAt?: string | string | null
    }
}): Promise<departments.PaginatedDepartments> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/tenants/${encodeURIComponent(tenantId)}/departments/paginated`, JSON.stringify(params))
            return await resp.json() as departments.PaginatedDepartments
        }

        /**
         * Alias for listRolesByTenant to match test case naming.
         * @param params - Object containing the tenant ID
         * @param params.tenantId - The ID of the tenant
         * @returns {Promise<Roles>} List of all roles for the tenant
         * @throws {APIError} If the retrieval fails
         */
        public async listTenantRoles(tenantId: number): Promise<roles.Roles> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/tenants/${encodeURIComponent(tenantId)}/roles-alias`)
            return await resp.json() as roles.Roles
        }

        /**
         * Alias for listRolesByTenantWithPagination to match test case naming.
         * @param params - Object containing pagination parameters and tenant ID
         * @param params.tenantId - The ID of the tenant
         * @returns {Promise<PaginatedRoles>} Paginated list of tenant roles
         * @throws {APIError} If retrieval fails
         */
        public async listTenantRolesWithPagination(tenantId: number, params: {
    page?: number
    pageSize?: number
    orderBy?: {
        field: "id" | "name" | "description" | "tenantId" | "createdAt" | "updatedAt"
        direction: "asc" | "desc"
    }[]
    filters?: {
        id?: number
        name?: string
        description?: string | null
        tenantId?: number
        createdAt?: string | string | null
        updatedAt?: string | string | null
    }
    includePermissions?: boolean
}): Promise<roles.PaginatedRoles> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/tenants/${encodeURIComponent(tenantId)}/roles-paginated`, JSON.stringify(params))
            return await resp.json() as roles.PaginatedRoles
        }

        /**
         * Retrieves users for a specific tenant with optional filtering and ordering
         * @param params - Object containing the tenant ID and query options
         * @param params.tenantId - The ID of the tenant to get users for
         * @returns {Promise<Users>} List of users for the tenant (without password hashes)
         * @throws {APIError} If retrieval fails
         */
        public async listTenantUsers(tenantId: number, params: {
    orderBy?: {
        field: "id" | "tenantId" | "departmentId" | "username" | "email" | "passwordHash" | "firstName" | "lastName" | "phone" | "position" | "employeeId" | "mfaSettings" | "lastLogin" | "isActive" | "isSystemAdmin" | "createdAt" | "updatedAt"
        direction: "asc" | "desc"
    }[]
    filters?: {
        id?: number
        tenantId?: number
        departmentId?: number
        username?: string
        email?: string
        firstName?: string
        lastName?: string
        phone?: string | null
        position?: string | null
        employeeId?: string | null
        mfaSettings?: { [key: string]: any } | null
        lastLogin?: string | string | null
        isActive?: boolean
        isSystemAdmin?: boolean
        createdAt?: string | string | null
        updatedAt?: string | string | null
    }
}): Promise<Users> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/tenants/${encodeURIComponent(tenantId)}/users`, JSON.stringify(params))
            return await resp.json() as Users
        }

        /**
         * Retrieves paginated users for a specific tenant with filtering and ordering
         * @param params - Object containing the tenant ID and pagination/query parameters
         * @param params.tenantId - The ID of the tenant to get users for
         * @returns {Promise<PaginatedUsers>} Paginated list of users for the tenant
         * @throws {APIError} If retrieval fails
         */
        public async listTenantUsersPaginated(tenantId: number, params: {
    page?: number
    pageSize?: number
    orderBy?: {
        field: "id" | "tenantId" | "departmentId" | "username" | "email" | "passwordHash" | "firstName" | "lastName" | "phone" | "position" | "employeeId" | "mfaSettings" | "lastLogin" | "isActive" | "isSystemAdmin" | "createdAt" | "updatedAt"
        direction: "asc" | "desc"
    }[]
    filters?: {
        id?: number
        tenantId?: number
        departmentId?: number
        username?: string
        email?: string
        firstName?: string
        lastName?: string
        phone?: string | null
        position?: string | null
        employeeId?: string | null
        mfaSettings?: { [key: string]: any } | null
        lastLogin?: string | string | null
        isActive?: boolean
        isSystemAdmin?: boolean
        createdAt?: string | string | null
        updatedAt?: string | string | null
    }
}): Promise<PaginatedUsers> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/tenants/${encodeURIComponent(tenantId)}/users/paginated`, JSON.stringify(params))
            return await resp.json() as PaginatedUsers
        }

        /**
         * Retrieves all tenants with optional filtering and ordering.
         * @param params - Query options for filtering and ordering
         * @returns {Promise<Tenants>} List of tenants
         * @throws {APIError} If the retrieval fails
         */
        public async listTenants(params: tenants.TenantsQueryOptions): Promise<tenants.Tenants> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/get-tenants`, JSON.stringify(params))
            return await resp.json() as tenants.Tenants
        }

        /**
         * Retrieves tenants with pagination, filtering, and ordering.
         * @param params - Pagination, filtering, and ordering parameters
         * @returns {Promise<PaginatedTenants>} Paginated list of tenants
         * @throws {APIError} If retrieval fails
         */
        public async listTenantsWithPagination(params: tenants.PaginationParamsTenants): Promise<tenants.PaginatedTenants> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/get-tenants/paginated`, JSON.stringify(params))
            return await resp.json() as tenants.PaginatedTenants
        }

        /**
         * Retrieves all users with optional filtering and ordering (useful for dropdowns)
         * @param params - Query options for filtering and ordering
         * @returns {Promise<Users>} List of all users (without password hashes)
         * @throws {APIError} If retrieval fails
         */
        public async listUsers(params: UsersQueryOptions): Promise<Users> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/get-users`, JSON.stringify(params))
            return await resp.json() as Users
        }

        /**
         * Retrieves users with pagination, filtering, and ordering (useful for tables)
         * @param params - Pagination, filtering, and ordering parameters
         * @returns {Promise<PaginatedUsers>} Paginated list of users (without password hashes)
         * @throws {APIError} If retrieval fails
         */
        public async listUsersPaginated(params: PaginationParamsUsers): Promise<PaginatedUsers> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/get-users/paginated`, JSON.stringify(params))
            return await resp.json() as PaginatedUsers
        }

        /**
         * Authenticates a user and generates JWT tokens
         * @param params Login credentials
         * @returns User data and authentication tokens
         * @throws {APIError} If authentication fails
         */
        public async login(params: auth.LoginPayload): Promise<auth.LoginResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/auth/login`, JSON.stringify(params))
            return await resp.json() as auth.LoginResponse
        }

        /**
         * Logs out a user by revoking their refresh token
         * @param params Refresh token to revoke
         * @returns Success message
         * @throws {APIError} If logout fails
         */
        public async logout(params: auth.LogoutPayload): Promise<{
    message: string
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/auth/logout`, JSON.stringify(params))
            return await resp.json() as {
    message: string
}
        }

        /**
         * Refreshes an access token using a valid refresh token
         * @param params Refresh token
         * @returns New access and refresh tokens
         * @throws {APIError} If refresh token is invalid
         */
        public async refreshToken(params: auth.RefreshTokenPayload): Promise<{
    accessToken: string
    refreshToken: string
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/auth/refresh-token`, JSON.stringify(params))
            return await resp.json() as {
    accessToken: string
    refreshToken: string
}
        }

        /**
         * Revokes all refresh tokens for a user
         * @param params User ID
         * @returns Number of tokens revoked
         * @throws {APIError} If operation fails
         */
        public async revokeAllTokens(userId: number): Promise<{
    count: number
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/auth/revoke-all/${encodeURIComponent(userId)}`)
            return await resp.json() as {
    count: number
}
        }

        /**
         * Searches for departments by matching a search term against name, code, and description.
         * @param params - Search parameters
         * @param params.term - The search term to match against department fields
         * @returns {Promise<Departments>} List of matching departments
         * @throws {APIError} If search fails or no searchable fields are configured
         */
        public async searchDepartments(params: {
    term: string
}): Promise<departments.Departments> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                term: params.term,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/departments/search`, undefined, {query})
            return await resp.json() as departments.Departments
        }

        /**
         * Searches for departments with pagination by matching a search term against name, code, and description.
         * @param params - Search and pagination parameters
         * @param params.term - The search term to match against department fields
         * @returns {Promise<PaginatedDepartments>} Paginated list of matching departments
         * @throws {APIError} If search fails or no searchable fields are configured
         */
        public async searchDepartmentsPaginated(params: {
    page?: number
    pageSize?: number
    orderBy?: {
        field: "id" | "tenantId" | "name" | "code" | "description" | "isActive" | "createdAt" | "updatedAt"
        direction: "asc" | "desc"
    }[]
    filters?: {
        id?: number
        tenantId?: number
        name?: string
        code?: string
        description?: string | null
        isActive?: boolean
        createdAt?: string | string | null
        updatedAt?: string | string | null
    }
    term: string
}): Promise<departments.PaginatedDepartments> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/departments/search/paginated`, JSON.stringify(params))
            return await resp.json() as departments.PaginatedDepartments
        }

        /**
         * Searches for permissions by matching a search term against name, code, and description.
         * @param params - Search parameters
         * @param params.term - The search term to match against permission fields
         * @returns {Promise<Permissions>} List of matching permissions
         * @throws {APIError} If search fails or no searchable fields are configured
         */
        public async searchPermissions(params: {
    term: string
}): Promise<permissions.Permissions> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                term: params.term,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/permissions/search`, undefined, {query})
            return await resp.json() as permissions.Permissions
        }

        /**
         * Searches for permissions with pagination by matching a search term against name, code, and description.
         * @param params - Search and pagination parameters
         * @param params.term - The search term to match against permission fields
         * @param params.page - Page number for pagination (optional, default: 1)
         * @param params.pageSize - Number of items per page (optional, default: 10)
         * @param params.orderBy - Sorting criteria (optional)
         * @param params.filters - Additional filters to apply (optional)
         * @returns {Promise<PaginatedPermissions>} Paginated list of matching permissions
         * @throws {APIError} If search fails or no searchable fields are configured
         */
        public async searchPermissionsPaginated(params: {
    page?: number
    pageSize?: number
    orderBy?: {
        field: "id" | "code" | "name" | "description" | "permissionGroupId" | "createdAt" | "updatedAt"
        direction: "asc" | "desc"
    }[]
    filters?: {
        id?: number
        code?: string
        name?: string
        description?: string | null
        permissionGroupId?: number | null
        createdAt?: string | string | null
        updatedAt?: string | string | null
    }
    term: string
}): Promise<permissions.PaginatedPermissions> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/permissions/search/paginated`, JSON.stringify(params))
            return await resp.json() as permissions.PaginatedPermissions
        }

        /**
         * Searches for roles by matching a search term against name and description.
         * @param params - Search parameters
         * @param params.term - The search term to match against role fields
         * @returns {Promise<Roles>} List of matching roles
         * @throws {APIError} If search fails or no searchable fields are configured
         */
        public async searchRoles(params: {
    term: string
    orderBy?: {
        field: "id" | "name" | "description" | "tenantId" | "createdAt" | "updatedAt"
        direction: "asc" | "desc"
    }[]
    filters?: {
        id?: number
        name?: string
        description?: string | null
        tenantId?: number
        createdAt?: string | string | null
        updatedAt?: string | string | null
    }
    includePermissions?: boolean
}): Promise<roles.Roles> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/roles/search`, JSON.stringify(params))
            return await resp.json() as roles.Roles
        }

        /**
         * Searches for roles with pagination by matching a search term.
         * @param params - Search and pagination parameters
         * @param params.term - The search term to match against role fields
         * @returns {Promise<PaginatedRoles>} Paginated list of matching roles
         * @throws {APIError} If search fails or no searchable fields are configured
         */
        public async searchRolesPaginated(params: {
    page?: number
    pageSize?: number
    orderBy?: {
        field: "id" | "name" | "description" | "tenantId" | "createdAt" | "updatedAt"
        direction: "asc" | "desc"
    }[]
    filters?: {
        id?: number
        name?: string
        description?: string | null
        tenantId?: number
        createdAt?: string | string | null
        updatedAt?: string | string | null
    }
    includePermissions?: boolean
    term: string
}): Promise<roles.PaginatedRoles> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/roles/search/paginated`, JSON.stringify(params))
            return await resp.json() as roles.PaginatedRoles
        }

        /**
         * Searches for tenants by matching a search term against name, code, and description.
         * @param params - Search parameters
         * @param params.term - The search term to match against tenant fields
         * @returns {Promise<Tenants>} List of matching tenants
         * @throws {APIError} If search fails or no searchable fields are configured
         */
        public async searchTenants(params: {
    term: string
}): Promise<tenants.Tenants> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                term: params.term,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/tenants/search`, undefined, {query})
            return await resp.json() as tenants.Tenants
        }

        /**
         * Searches for tenants with pagination by matching a search term.
         * @param params - Search and pagination parameters
         * @param params.term - The search term to match against tenant fields
         * @returns {Promise<PaginatedTenants>} Paginated list of matching tenants
         * @throws {APIError} If search fails or no searchable fields are configured
         */
        public async searchTenantsPaginated(params: {
    page?: number
    pageSize?: number
    orderBy?: {
        field: "id" | "name" | "code" | "description" | "isActive" | "createdAt" | "updatedAt"
        direction: "asc" | "desc"
    }[]
    filters?: {
        id?: number
        name?: string
        code?: string
        description?: string | null
        isActive?: boolean
        createdAt?: string | string | null
        updatedAt?: string | string | null
    }
    term: string
}): Promise<tenants.PaginatedTenants> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/tenants/search/paginated`, JSON.stringify(params))
            return await resp.json() as tenants.PaginatedTenants
        }

        /**
         * Searches for users by matching a search term against name, email, and username
         * @param params - Search parameters
         * @param params.term - The search term to match against user fields
         * @returns {Promise<Users>} List of matching users (without password hashes)
         * @throws {APIError} If search fails or no searchable fields are configured
         */
        public async searchUsers(params: {
    term: string
}): Promise<Users> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                term: params.term,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/users/search`, undefined, {query})
            return await resp.json() as Users
        }

        /**
         * Searches for users with pagination by matching a search term against name, email, and username
         * @param params - Search and pagination parameters
         * @param params.term - The search term to match against user fields
         * @returns {Promise<PaginatedUsers>} Paginated list of matching users (without password hashes)
         * @throws {APIError} If search fails or no searchable fields are configured
         */
        public async searchUsersPaginated(params: {
    page?: number
    pageSize?: number
    orderBy?: {
        field: "id" | "tenantId" | "departmentId" | "username" | "email" | "passwordHash" | "firstName" | "lastName" | "phone" | "position" | "employeeId" | "mfaSettings" | "lastLogin" | "isActive" | "isSystemAdmin" | "createdAt" | "updatedAt"
        direction: "asc" | "desc"
    }[]
    filters?: {
        id?: number
        tenantId?: number
        departmentId?: number
        username?: string
        email?: string
        firstName?: string
        lastName?: string
        phone?: string | null
        position?: string | null
        employeeId?: string | null
        mfaSettings?: { [key: string]: any } | null
        lastLogin?: string | string | null
        isActive?: boolean
        isSystemAdmin?: boolean
        createdAt?: string | string | null
        updatedAt?: string | string | null
    }
    term: string
}): Promise<PaginatedUsers> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/users/search/paginated`, JSON.stringify(params))
            return await resp.json() as PaginatedUsers
        }

        /**
         * Updates an existing department.
         * @param params - Object containing the department ID and update data
         * @param params.id - The ID of the department to update
         * @returns {Promise<Department>} The updated department
         * @throws {APIError} If the department is not found or update fails
         */
        public async updateDepartment(id: number, params: {
    /**
     * Updated name of the department
     * @minLength 2
     */
    name?: string

    /**
     * Updated code for the department (alphanumeric with no spaces)
     * @minLength 2
     * @pattern ^[a-zA-Z0-9-]+$
     */
    code?: string

    /**
     * Updated description of the department
     */
    description?: string

    /**
     * Updated active status of the department
     */
    isActive?: boolean
}): Promise<departments.Department> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/departments/${encodeURIComponent(id)}`, JSON.stringify(params))
            return await resp.json() as departments.Department
        }

        /**
         * Updates an existing permission.
         * @param params - Object containing the permission ID and update data
         * @param params.id - The ID of the permission to update
         * @returns {Promise<Permission>} The updated permission
         * @throws {APIError} If the permission is not found or update fails
         */
        public async updatePermission(id: number, params: {
    /**
     * Human-readable name of the permission
     * Must have at least 3 non-whitespace characters
     */
    name?: string

    /**
     * Description of what the permission allows
     */
    description?: string

    /**
     * ID of the permission group this permission belongs to
     */
    permissionGroupId?: number | null
}): Promise<permissions.Permission> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/permissions/${encodeURIComponent(id)}`, JSON.stringify(params))
            return await resp.json() as permissions.Permission
        }

        /**
         * Updates an existing permission group.
         * @param id - The ID of the permission group to update
         * @param data - The permission group data to update
         * @returns {Promise<PermissionGroup>} The updated permission group
         * @throws {APIError} If the permission group is not found or update fails
         */
        public async updatePermissionGroup(id: number, params: {
    /**
     * Name of the permission group
     * Must have at least 1 non-whitespace character
     */
    name?: string

    /**
     * Optional description for the permission group
     */
    description?: string | null

    /**
     * Optional array of permission IDs to associate with the group
     */
    permissionIds?: number[]
}): Promise<permission_groups.PermissionGroup> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/permission-groups/${encodeURIComponent(id)}`, JSON.stringify(params))
            return await resp.json() as permission_groups.PermissionGroup
        }

        /**
         * Updates an existing role.
         * @param params - Object containing the role ID and update data
         * @param params.id - The ID of the role to update
         * @returns {Promise<RoleWithPermissions>} The updated role with permissions
         * @throws {APIError} If the role is not found or update fails
         */
        public async updateRole(id: number, params: {
    /**
     * Human-readable name of the role
     * Must have at least 3 non-whitespace characters
     */
    name?: string

    /**
     * Description of what the role represents
     */
    description?: string
}): Promise<roles.RoleWithPermissions> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/roles/${encodeURIComponent(id)}`, JSON.stringify(params))
            return await resp.json() as roles.RoleWithPermissions
        }

        /**
         * Updates an existing tenant.
         * @param params - Object containing the tenant ID and update data
         * @param params.id - The ID of the tenant to update
         * @returns {Promise<Tenant>} The updated tenant
         * @throws {APIError} If the tenant is not found or update fails
         */
        public async updateTenant(id: number, params: {
    /**
     * Updated name of the tenant
     * @minLength 2
     */
    name?: string

    /**
     * Updated code for the tenant (alphanumeric with no spaces)
     * @minLength 2
     * @pattern ^[a-zA-Z0-9-]+$
     */
    code?: string

    /**
     * Updated description of the tenant
     */
    description?: string

    /**
     * Updated active status of the tenant
     */
    isActive?: boolean
}): Promise<tenants.Tenant> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/tenants/${encodeURIComponent(id)}`, JSON.stringify(params))
            return await resp.json() as tenants.Tenant
        }

        /**
         * Updates an existing user
         * @param params - Object containing the user ID and update data
         * @param params.id - The ID of the user to update
         * @returns {Promise<SafeUser>} The updated user (without password hash)
         * @throws {APIError} If the user is not found or update fails
         */
        public async updateUser(id: number, params: {
    /**
     * ID of the department this user belongs to
     */
    departmentId?: number

    /**
     * Email address of the user
     * Must be a valid email format
     */
    email?: string

    /**
     * First name of the user
     * Must have at least 1 non-whitespace character
     */
    firstName?: string

    /**
     * Last name of the user
     * Must have at least 1 non-whitespace character
     */
    lastName?: string

    /**
     * Phone number of the user
     */
    phone?: string

    /**
     * Job title/position of the user
     */
    position?: string

    /**
     * Internal employee ID
     */
    employeeId?: string

    /**
     * Whether the user is currently active
     */
    isActive?: boolean

    /**
     * Whether the user is a system-wide admin
     */
    isSystemAdmin?: boolean
}): Promise<SafeUser> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/users/${encodeURIComponent(id)}`, JSON.stringify(params))
            return await resp.json() as SafeUser
        }
    }
}

export namespace amenities {
    export interface Amenity {
        /**
         * Unique identifier for the amenity
         */
        id: number

        /**
         * Name of the amenity
         */
        name: string

        /**
         * Category of the amenity
         */
        category: AmenityCategory

        /**
         * Type of amenity within the category
         */
        amenityType: AmenityType

        /**
         * Optional description of the amenity
         */
        description: string | null

        /**
         * Optional icon name for UI display
         */
        iconName: string | null

        /**
         * Whether the amenity is active/available
         */
        active: boolean

        /**
         * Timestamp when the amenity record was created
         */
        createdAt: string | string | null

        /**
         * Timestamp when the amenity record was last updated
         */
        updatedAt: string | string | null

        /**
         * Timestamp when the amenity was soft deleted
         */
        deletedAt: string | string | null
    }

    export type AmenityCategory = "basic" | "comfort" | "technology" | "security" | "accessibility" | "services"

    export type AmenityType = "bus" | "installation" | "service_type"

    export interface CreateAmenityPayload {
        /**
         * Name of the amenity
         * Must have at least 1 non-whitespace character
         */
        name: string

        /**
         * Category of the amenity
         * Must be one of the allowed categories
         */
        category: AmenityCategory

        /**
         * Type of amenity within the category
         * Must be one of: 'bus', 'installation', 'service_type'
         */
        amenityType: AmenityType

        /**
         * Optional description of the amenity
         */
        description?: string | null

        /**
         * Optional icon name for UI display
         */
        iconName?: string | null

        /**
         * Whether the amenity is active/available
         * @default true
         */
        active?: boolean
    }

    export interface ListAmenitiesQueryParams {
        orderBy?: {
            field: "id" | "name" | "category" | "amenityType" | "description" | "iconName" | "active" | "createdAt" | "updatedAt" | "deletedAt"
            direction: "asc" | "desc"
        }[]
        filters?: {
            id?: number
            name?: string
            category?: AmenityCategory
            amenityType?: AmenityType
            description?: string | null
            iconName?: string | null
            active?: boolean
            createdAt?: string | string | null
            updatedAt?: string | string | null
            deletedAt?: string | string | null
        }
        searchTerm?: string
    }

    export interface ListAmenitiesResult {
        data: Amenity[]
    }

    export interface PaginatedListAmenitiesQueryParams {
        page?: number
        pageSize?: number
        orderBy?: {
            field: "id" | "name" | "category" | "amenityType" | "description" | "iconName" | "active" | "createdAt" | "updatedAt" | "deletedAt"
            direction: "asc" | "desc"
        }[]
        filters?: {
            id?: number
            name?: string
            category?: AmenityCategory
            amenityType?: AmenityType
            description?: string | null
            iconName?: string | null
            active?: boolean
            createdAt?: string | string | null
            updatedAt?: string | string | null
            deletedAt?: string | string | null
        }
        searchTerm?: string
    }

    export interface PaginatedListAmenitiesResult {
        pagination: shared.PaginationMeta
        data: Amenity[]
    }
}

export namespace audits {
    export interface Audit {
        /**
         * Unique identifier for the audit record
         */
        id: number

        /**
         * ID of the user this audit is for
         */
        userId: number

        /**
         * The service or module that initiated the audit entry
         */
        service: string

        /**
         * The specific API endpoint accessed
         */
        endpoint: string | null

        /**
         * Content of the audit entry with detailed information
         */
        details: { [key: string]: any } | null

        /**
         * IP address from which the audit was performed
         */
        ipAddress: string | null

        /**
         * User agent of the browser/application that performed the audit
         */
        userAgent: string | null

        /**
         * Timestamp when the audit record was created
         */
        createdAt: string | string | null
    }

    export interface PaginatedAudits {
        pagination: shared.PaginationMeta
        data: Audit[]
    }

    export interface PaginationParamsAudits {
        page?: number
        pageSize?: number
        orderBy?: {
            field: "id" | "userId" | "service" | "endpoint" | "details" | "ipAddress" | "userAgent" | "createdAt"
            direction: "asc" | "desc"
        }[]
        filters?: {
            id?: number
            userId?: number
            service?: string
            endpoint?: string | null
            details?: { [key: string]: any } | null
            ipAddress?: string | null
            userAgent?: string | null
            createdAt?: string | string | null
        }
    }
}

export namespace auth {
    export interface LoginPayload {
        /**
         * Username for login
         */
        username: string

        /**
         * Password for authentication
         */
        password: string
    }

    export interface LoginResponse {
        /**
         * User data without sensitive information
         */
        user: users.SafeUser

        /**
         * JWT access token
         */
        accessToken: string

        /**
         * JWT refresh token
         */
        refreshToken: string
    }

    export interface LogoutPayload {
        /**
         * Refresh token to invalidate
         */
        refreshToken: string
    }

    export interface RefreshTokenPayload {
        /**
         * Refresh token
         */
        refreshToken: string
    }
}

export namespace bus_diagram_model_zones {
    export interface BusDiagramModelZone {
        /**
         * Unique identifier for the zone
         */
        id: number

        /**
         * Reference to the bus diagram model
         */
        busDiagramModelId: number

        /**
         * Name of the zone
         */
        name: string

        /**
         * Array of row numbers that belong to this zone
         */
        rowNumbers: number[]

        /**
         * Price multiplier for seats in this zone
         */
        priceMultiplier: number

        /**
         * Timestamp when the zone was created
         */
        createdAt: string | string | null

        /**
         * Timestamp when the zone was last updated
         */
        updatedAt: string | string | null
    }

    export interface BusDiagramModelZones {
        /**
         * List of bus diagram model zones
         */
        busDiagramModelZones: BusDiagramModelZone[]
    }

    export interface PaginatedBusDiagramModelZones {
        pagination: shared.PaginationMeta
        data: BusDiagramModelZone[]
    }
}

export namespace bus_diagram_models {
    export interface BusDiagramModel {
        /**
         * Unique identifier for the bus diagram model
         */
        id: number

        /**
         * Name of the bus diagram model
         */
        name: string

        /**
         * Description of the bus diagram model
         */
        description: string | null

        /**
         * Maximum capacity
         */
        maxCapacity: number

        /**
         * Number of floors in the bus diagram model
         */
        numFloors: number

        /**
         * Configuration of seats per floor
         */
        seatsPerFloor: shared.FloorSeats[]

        /**
         * Total number of seats
         */
        totalSeats: number

        /**
         * Indicates if this is a factory default model
         */
        isFactoryDefault: boolean

        /**
         * Whether the bus diagram model is active
         */
        active: boolean

        /**
         * Timestamp when the bus diagram model was created
         */
        createdAt: string | string | null

        /**
         * Timestamp when the bus diagram model was last updated
         */
        updatedAt: string | string | null
    }

    export interface CreateBusDiagramModelPayload {
        /**
         * Name of the bus diagram model
         * Must have at least 1 character
         */
        name: string

        /**
         * Description of the bus diagram model
         */
        description?: string

        /**
         * Maximum capacity
         * Must be a positive number
         */
        maxCapacity: number

        /**
         * Number of floors in the bus diagram model
         * Must be a positive number
         */
        numFloors: number

        /**
         * Configuration of seats per floor
         */
        seatsPerFloor: shared.FloorSeats[]

        /**
         * Total number of seats
         */
        totalSeats: number

        /**
         * Indicates if this is a factory default model
         * @default true
         */
        isFactoryDefault?: boolean

        /**
         * Whether the bus diagram model is active
         * @default true
         */
        active?: boolean
    }

    export interface ListBusDiagramModelsQueryParams {
        orderBy?: {
            field: "id" | "name" | "description" | "maxCapacity" | "numFloors" | "seatsPerFloor" | "totalSeats" | "isFactoryDefault" | "active" | "createdAt" | "updatedAt"
            direction: "asc" | "desc"
        }[]
        filters?: {
            id?: number
            name?: string
            description?: string | null
            maxCapacity?: number
            numFloors?: number
            seatsPerFloor?: shared.FloorSeats[]
            totalSeats?: number
            isFactoryDefault?: boolean
            active?: boolean
            createdAt?: string | string | null
            updatedAt?: string | string | null
        }
        searchTerm?: string
    }

    export interface ListBusDiagramModelsResult {
        data: BusDiagramModel[]
    }

    export interface PaginatedBusDiagramModels {
        pagination: shared.PaginationMeta
        data: BusDiagramModel[]
    }

    export interface RegenerateSeatsResponse {
        /**
         * Array of sync summaries, one for each diagram that was synced
         */
        summaries: SeatDiagramSyncSummary[]
    }

    export interface SeatDiagramSyncSummary {
        /**
         * ID of the seat diagram that was synced
         */
        seatDiagramId: number

        /**
         * Number of seats created during sync
         */
        created: number

        /**
         * Number of seats updated during sync
         */
        updated: number

        /**
         * Number of seats deleted during sync
         */
        deleted: number
    }
}

export namespace bus_lines {
    export interface BusLine {
        /**
         * Unique identifier for the bus line
         */
        id: number

        /**
         * Name of the bus line
         */
        name: string

        /**
         * Unique business code for the bus line
         */
        code: string

        /**
         * ID of the transporter that operates this bus line
         */
        transporterId: number

        /**
         * ID of the service type of this bus line
         */
        serviceTypeId: number

        /**
         * Multiplier for price per kilometer
         */
        pricePerKilometer: number

        /**
         * Description of the bus line
         */
        description: string | null

        /**
         * Number of vehicles in the fleet
         */
        fleetSize: number | null

        /**
         * Website
         */
        website: string | null

        /**
         * Email
         */
        email: string | null

        /**
         * Phone
         */
        phone: string | null

        /**
         * Whether the bus line is currently active in the system
         */
        active: boolean

        /**
         * Timestamp when the bus line record was created
         */
        createdAt: string | string | null

        /**
         * Timestamp when the bus line record was last updated
         */
        updatedAt: string | string | null
    }

    export interface BusLineWithTransporterAndServiceType {
        transporter: transporters.Transporter
        serviceType: service_types.ServiceType
        /**
         * Unique identifier for the bus line
         */
        id: number

        /**
         * Name of the bus line
         */
        name: string

        /**
         * Unique business code for the bus line
         */
        code: string

        /**
         * ID of the transporter that operates this bus line
         */
        transporterId: number

        /**
         * ID of the service type of this bus line
         */
        serviceTypeId: number

        /**
         * Multiplier for price per kilometer
         */
        pricePerKilometer: number

        /**
         * Description of the bus line
         */
        description: string | null

        /**
         * Number of vehicles in the fleet
         */
        fleetSize: number | null

        /**
         * Website
         */
        website: string | null

        /**
         * Email
         */
        email: string | null

        /**
         * Phone
         */
        phone: string | null

        /**
         * Whether the bus line is currently active in the system
         */
        active: boolean

        /**
         * Timestamp when the bus line record was created
         */
        createdAt: string | string | null

        /**
         * Timestamp when the bus line record was last updated
         */
        updatedAt: string | string | null
    }

    export interface CreateBusLinePayload {
        /**
         * The name of the bus line
         * Must have at least 1 non-whitespace character
         */
        name: string

        /**
         * Unique business code for the bus line (1-20 characters)
         * Must contain only uppercase letters, numbers, and hyphens
         */
        code: string

        /**
         * ID of the transporter that operates this bus line
         * Must be a positive number
         */
        transporterId: number

        /**
         * ID of the service type of this bus line
         * Must be a positive number
         */
        serviceTypeId: number

        /**
         * Multiplier for price per kilometer
         * Must be a positive number
         * @default 1
         */
        pricePerKilometer?: number

        /**
         * Description of the bus line
         */
        description?: string

        /**
         * Number of vehicles in the fleet
         */
        fleetSize?: number | null

        /**
         * Website
         */
        website?: string

        /**
         * Email
         */
        email?: string

        /**
         * Phone
         */
        phone?: string

        /**
         * Whether the bus line is active
         * @default true
         */
        active?: boolean
    }

    export interface ListBusLinesQueryParams {
        orderBy?: {
            field: "id" | "name" | "code" | "transporterId" | "serviceTypeId" | "pricePerKilometer" | "description" | "fleetSize" | "website" | "email" | "phone" | "active" | "createdAt" | "updatedAt"
            direction: "asc" | "desc"
        }[]
        filters?: {
            id?: number
            name?: string
            code?: string
            transporterId?: number
            serviceTypeId?: number
            pricePerKilometer?: number
            description?: string | null
            fleetSize?: number | null
            website?: string | null
            email?: string | null
            phone?: string | null
            active?: boolean
            createdAt?: string | string | null
            updatedAt?: string | string | null
        }
        searchTerm?: string
    }

    export interface ListBusLinesResult {
        data: BusLine[]
    }

    export interface PaginatedListBusLinesQueryParams {
        page?: number
        pageSize?: number
        orderBy?: {
            field: "id" | "name" | "code" | "transporterId" | "serviceTypeId" | "pricePerKilometer" | "description" | "fleetSize" | "website" | "email" | "phone" | "active" | "createdAt" | "updatedAt"
            direction: "asc" | "desc"
        }[]
        filters?: {
            id?: number
            name?: string
            code?: string
            transporterId?: number
            serviceTypeId?: number
            pricePerKilometer?: number
            description?: string | null
            fleetSize?: number | null
            website?: string | null
            email?: string | null
            phone?: string | null
            active?: boolean
            createdAt?: string | string | null
            updatedAt?: string | string | null
        }
        searchTerm?: string
    }

    export interface PaginatedListBusLinesResult {
        pagination: shared.PaginationMeta
        data: BusLineWithTransporterAndServiceType[]
    }
}

export namespace bus_models {
    export interface BusModel {
        /**
         * Unique identifier for the bus model
         */
        id: number

        /**
         * Default bus diagram model ID
         */
        defaultBusDiagramModelId: number

        /**
         * Manufacturer of the bus
         */
        manufacturer: string

        /**
         * Model name/number
         */
        model: string

        /**
         * Year the bus model was released
         */
        year: number

        /**
         * Total seating capacity
         */
        seatingCapacity: number

        /**
         * Trunk capacity
         */
        trunkCapacity: number | null

        /**
         * Fuel efficiency
         */
        fuelEfficiency: number | null

        /**
         * Max capacity
         */
        maxCapacity: number | null

        /**
         * Number of floors/decks in the bus
         */
        numFloors: number

        /**
         * Available amenities
         */
        amenities: string[]

        /**
         * Type of engine (e.g., diesel, electric)
         */
        engineType: EngineType

        /**
         * Whether the bus model is active
         */
        active: boolean

        /**
         * Timestamp when the bus model was created
         */
        createdAt: string | string | null

        /**
         * Timestamp when the bus model was last updated
         */
        updatedAt: string | string | null
    }

    export interface CreateBusModelPayload {
        /**
         * Default bus diagram model ID
         * Must be a positive number
         */
        defaultBusDiagramModelId: number | null

        /**
         * Manufacturer of the bus
         * Must have at least 1 character
         */
        manufacturer: string

        /**
         * Model name/number
         * Must have at least 1 character
         */
        model: string

        /**
         * Year the bus model was released
         * Must be a positive number
         */
        year: number

        /**
         * Total seating capacity
         * Must be a positive number
         */
        seatingCapacity: number

        /**
         * Trunk capacity
         * Must be a positive number
         * Optional trunk capacity in kilograms (null if not specified)
         */
        trunkCapacity?: number | null

        /**
         * Fuel efficiency
         * Must be a positive number
         * Optional fuel efficiency in km/L (null if not specified)
         */
        fuelEfficiency?: number | null

        /**
         * Max capacity
         * Must be a positive number
         * Optional max capacity in passengers (null if not specified)
         */
        maxCapacity?: number | null

        /**
         * Number of floors/decks in the bus
         * @default 1
         */
        numFloors: number

        /**
         * Available amenities
         * @default []
         */
        amenities?: string[]

        /**
         * Type of engine (e.g., diesel, electric)
         */
        engineType: EngineType

        /**
         * Whether the bus model is active
         * @default true
         */
        active?: boolean
    }

    export type EngineType = "DIESEL" | "ELECTRIC" | "HYBRID" | "GASOLINE" | "NATURAL_GAS" | "LPG" | "OTHER"

    export interface ListBusModelsQueryParams {
        orderBy?: {
            field: "id" | "defaultBusDiagramModelId" | "manufacturer" | "model" | "year" | "seatingCapacity" | "trunkCapacity" | "fuelEfficiency" | "maxCapacity" | "numFloors" | "amenities" | "engineType" | "active" | "createdAt" | "updatedAt"
            direction: "asc" | "desc"
        }[]
        filters?: {
            id?: number
            defaultBusDiagramModelId?: number
            manufacturer?: string
            model?: string
            year?: number
            seatingCapacity?: number
            trunkCapacity?: number | null
            fuelEfficiency?: number | null
            maxCapacity?: number | null
            numFloors?: number
            amenities?: string[]
            engineType?: EngineType
            active?: boolean
            createdAt?: string | string | null
            updatedAt?: string | string | null
        }
        searchTerm?: string
    }

    export interface ListBusModelsResult {
        data: BusModel[]
    }

    export interface PaginatedListBusModelsQueryParams {
        page?: number
        pageSize?: number
        orderBy?: {
            field: "id" | "defaultBusDiagramModelId" | "manufacturer" | "model" | "year" | "seatingCapacity" | "trunkCapacity" | "fuelEfficiency" | "maxCapacity" | "numFloors" | "amenities" | "engineType" | "active" | "createdAt" | "updatedAt"
            direction: "asc" | "desc"
        }[]
        filters?: {
            id?: number
            defaultBusDiagramModelId?: number
            manufacturer?: string
            model?: string
            year?: number
            seatingCapacity?: number
            trunkCapacity?: number | null
            fuelEfficiency?: number | null
            maxCapacity?: number | null
            numFloors?: number
            amenities?: string[]
            engineType?: EngineType
            active?: boolean
            createdAt?: string | string | null
            updatedAt?: string | string | null
        }
        searchTerm?: string
    }

    export interface PaginatedListBusModelsResult {
        pagination: shared.PaginationMeta
        data: BusModel[]
    }
}

export namespace bus_seat_models {
    export interface BathroomBusSeatModel {
        /**
         * Type of space
         */
        spaceType: "bathroom"

        /**
         * Unique identifier for the bus seat model
         */
        id: number

        /**
         * Bus diagram model ID (reference to bus_diagram_models)
         */
        busDiagramModelId: number

        /**
         * Floor number
         */
        floorNumber: number

        /**
         * Seat amenities (primarily for SEAT space types)
         */
        amenities: string[]

        /**
         * Position coordinates in the bus layout
         */
        position: shared.SeatPosition

        /**
         * Additional metadata for the space (flexible JSON structure)
         */
        meta: { [key: string]: any }

        /**
         * Whether the space model is active
         */
        active: boolean

        /**
         * Timestamp when the space model was created
         */
        createdAt: string | string | null

        /**
         * Timestamp when the space model was last updated
         */
        updatedAt: string | string | null
    }

    export type BusSeatModel = SeatBusSeatModel | HallwayBusSeatModel | BathroomBusSeatModel | EmptyBusSeatModel | StairsBusSeatModel

    export interface BusSeatModels {
        /**
         * List of bus seat models
         */
        busSeatModels: BusSeatModel[]
    }

    export interface EmptyBusSeatModel {
        /**
         * Type of space
         */
        spaceType: "empty"

        /**
         * Unique identifier for the bus seat model
         */
        id: number

        /**
         * Bus diagram model ID (reference to bus_diagram_models)
         */
        busDiagramModelId: number

        /**
         * Floor number
         */
        floorNumber: number

        /**
         * Seat amenities (primarily for SEAT space types)
         */
        amenities: string[]

        /**
         * Position coordinates in the bus layout
         */
        position: shared.SeatPosition

        /**
         * Additional metadata for the space (flexible JSON structure)
         */
        meta: { [key: string]: any }

        /**
         * Whether the space model is active
         */
        active: boolean

        /**
         * Timestamp when the space model was created
         */
        createdAt: string | string | null

        /**
         * Timestamp when the space model was last updated
         */
        updatedAt: string | string | null
    }

    export interface HallwayBusSeatModel {
        /**
         * Type of space
         */
        spaceType: "hallway"

        /**
         * Unique identifier for the bus seat model
         */
        id: number

        /**
         * Bus diagram model ID (reference to bus_diagram_models)
         */
        busDiagramModelId: number

        /**
         * Floor number
         */
        floorNumber: number

        /**
         * Seat amenities (primarily for SEAT space types)
         */
        amenities: string[]

        /**
         * Position coordinates in the bus layout
         */
        position: shared.SeatPosition

        /**
         * Additional metadata for the space (flexible JSON structure)
         */
        meta: { [key: string]: any }

        /**
         * Whether the space model is active
         */
        active: boolean

        /**
         * Timestamp when the space model was created
         */
        createdAt: string | string | null

        /**
         * Timestamp when the space model was last updated
         */
        updatedAt: string | string | null
    }

    export interface SeatBusSeatModel {
        /**
         * Type of space
         */
        spaceType: "seat"

        /**
         * Seat number (required for SEAT space types)
         */
        seatNumber: string

        /**
         * Type of seat (required for SEAT space types)
         */
        seatType: shared.SeatType

        /**
         * Angle of reclinement in degrees (only for SEAT space types)
         */
        reclinementAngle?: number

        /**
         * Unique identifier for the bus seat model
         */
        id: number

        /**
         * Bus diagram model ID (reference to bus_diagram_models)
         */
        busDiagramModelId: number

        /**
         * Floor number
         */
        floorNumber: number

        /**
         * Seat amenities (primarily for SEAT space types)
         */
        amenities: string[]

        /**
         * Position coordinates in the bus layout
         */
        position: shared.SeatPosition

        /**
         * Additional metadata for the space (flexible JSON structure)
         */
        meta: { [key: string]: any }

        /**
         * Whether the space model is active
         */
        active: boolean

        /**
         * Timestamp when the space model was created
         */
        createdAt: string | string | null

        /**
         * Timestamp when the space model was last updated
         */
        updatedAt: string | string | null
    }

    export interface SeatConfigurationInput {
        /**
         * Type of space (seat, stairs, hallway, etc.)
         * @default SpaceType.SEAT
         */
        spaceType?: shared.SpaceType

        /**
         * Seat number (e.g., "1A", "2B") - required only for SEAT space types
         */
        seatNumber?: string

        /**
         * Floor number (required for space identification)
         * @default 1
         */
        floorNumber: number

        /**
         * Type of seat (only applicable for SEAT space types)
         * @default SeatType.REGULAR
         */
        seatType?: shared.SeatType

        /**
         * Space amenities
         * @default []
         */
        amenities?: string[]

        /**
         * Angle of reclinement in degrees (only for SEAT space types)
         */
        reclinementAngle?: number

        /**
         * Position coordinates in the bus layout (required for space identification)
         */
        position: shared.SeatPosition

        /**
         * Whether the space is active
         * @default true
         */
        active?: boolean
    }

    export interface StairsBusSeatModel {
        /**
         * Type of space
         */
        spaceType: "stairs"

        /**
         * Unique identifier for the bus seat model
         */
        id: number

        /**
         * Bus diagram model ID (reference to bus_diagram_models)
         */
        busDiagramModelId: number

        /**
         * Floor number
         */
        floorNumber: number

        /**
         * Seat amenities (primarily for SEAT space types)
         */
        amenities: string[]

        /**
         * Position coordinates in the bus layout
         */
        position: shared.SeatPosition

        /**
         * Additional metadata for the space (flexible JSON structure)
         */
        meta: { [key: string]: any }

        /**
         * Whether the space model is active
         */
        active: boolean

        /**
         * Timestamp when the space model was created
         */
        createdAt: string | string | null

        /**
         * Timestamp when the space model was last updated
         */
        updatedAt: string | string | null
    }

    export interface UpdatedSeatConfiguration {
        /**
         * Number of spaces created
         */
        seatsCreated: number

        /**
         * Number of spaces updated
         */
        seatsUpdated: number

        /**
         * Number of spaces deactivated
         */
        seatsDeactivated: number

        /**
         * Total number of active seats (SEAT space types only)
         */
        totalActiveSeats: number
    }
}

export namespace bus_seats {
    export interface BathroomBusSeat {
        /**
         * Type of space
         */
        spaceType: "bathroom"

        /**
         * Unique identifier for the bus seat
         */
        id: number

        /**
         * Seat diagram ID (reference to seat_diagrams)
         */
        seatDiagramId: number

        /**
         * Floor number
         */
        floorNumber: number

        /**
         * Seat amenities (primarily for SEAT space types)
         */
        amenities: string[]

        /**
         * Position coordinates in the bus layout
         */
        position: shared.SeatPosition

        /**
         * Additional metadata for the space (flexible JSON structure)
         */
        meta: { [key: string]: any }

        /**
         * Whether the space is active
         */
        active: boolean

        /**
         * Timestamp when the space was created
         */
        createdAt: string | string | null

        /**
         * Timestamp when the space was last updated
         */
        updatedAt: string | string | null
    }

    export type BusSeat = SeatBusSeat | HallwayBusSeat | BathroomBusSeat | EmptyBusSeat | StairsBusSeat

    export interface BusSeats {
        /**
         * List of bus seats
         */
        busSeats: BusSeat[]
    }

    export interface EmptyBusSeat {
        /**
         * Type of space
         */
        spaceType: "empty"

        /**
         * Unique identifier for the bus seat
         */
        id: number

        /**
         * Seat diagram ID (reference to seat_diagrams)
         */
        seatDiagramId: number

        /**
         * Floor number
         */
        floorNumber: number

        /**
         * Seat amenities (primarily for SEAT space types)
         */
        amenities: string[]

        /**
         * Position coordinates in the bus layout
         */
        position: shared.SeatPosition

        /**
         * Additional metadata for the space (flexible JSON structure)
         */
        meta: { [key: string]: any }

        /**
         * Whether the space is active
         */
        active: boolean

        /**
         * Timestamp when the space was created
         */
        createdAt: string | string | null

        /**
         * Timestamp when the space was last updated
         */
        updatedAt: string | string | null
    }

    export interface HallwayBusSeat {
        /**
         * Type of space
         */
        spaceType: "hallway"

        /**
         * Unique identifier for the bus seat
         */
        id: number

        /**
         * Seat diagram ID (reference to seat_diagrams)
         */
        seatDiagramId: number

        /**
         * Floor number
         */
        floorNumber: number

        /**
         * Seat amenities (primarily for SEAT space types)
         */
        amenities: string[]

        /**
         * Position coordinates in the bus layout
         */
        position: shared.SeatPosition

        /**
         * Additional metadata for the space (flexible JSON structure)
         */
        meta: { [key: string]: any }

        /**
         * Whether the space is active
         */
        active: boolean

        /**
         * Timestamp when the space was created
         */
        createdAt: string | string | null

        /**
         * Timestamp when the space was last updated
         */
        updatedAt: string | string | null
    }

    export interface SeatBusSeat {
        /**
         * Type of space
         */
        spaceType: "seat"

        /**
         * Seat number (required for SEAT space types)
         */
        seatNumber: string

        /**
         * Type of seat (required for SEAT space types)
         */
        seatType: shared.SeatType

        /**
         * Angle of reclinement in degrees (only for SEAT space types)
         */
        reclinementAngle?: number

        /**
         * Unique identifier for the bus seat
         */
        id: number

        /**
         * Seat diagram ID (reference to seat_diagrams)
         */
        seatDiagramId: number

        /**
         * Floor number
         */
        floorNumber: number

        /**
         * Seat amenities (primarily for SEAT space types)
         */
        amenities: string[]

        /**
         * Position coordinates in the bus layout
         */
        position: shared.SeatPosition

        /**
         * Additional metadata for the space (flexible JSON structure)
         */
        meta: { [key: string]: any }

        /**
         * Whether the space is active
         */
        active: boolean

        /**
         * Timestamp when the space was created
         */
        createdAt: string | string | null

        /**
         * Timestamp when the space was last updated
         */
        updatedAt: string | string | null
    }

    export interface SeatConfigurationInput {
        /**
         * Type of space (seat, stairs, hallway, etc.)
         * @default SpaceType.SEAT
         */
        spaceType?: shared.SpaceType

        /**
         * Seat number (e.g., "1A", "2B") - required only for SEAT space types
         */
        seatNumber?: string

        /**
         * Floor number (required for space identification)
         * @default 1
         */
        floorNumber: number

        /**
         * Type of seat (only applicable for SEAT space types)
         * @default SeatType.REGULAR
         */
        seatType?: shared.SeatType

        /**
         * Space amenities
         * @default []
         */
        amenities?: string[]

        /**
         * Angle of reclinement in degrees (only for SEAT space types)
         */
        reclinementAngle?: number

        /**
         * Position coordinates in the bus layout (required for space identification)
         */
        position: shared.SeatPosition

        /**
         * Whether the space is active
         * @default true
         */
        active?: boolean
    }

    export interface StairsBusSeat {
        /**
         * Type of space
         */
        spaceType: "stairs"

        /**
         * Unique identifier for the bus seat
         */
        id: number

        /**
         * Seat diagram ID (reference to seat_diagrams)
         */
        seatDiagramId: number

        /**
         * Floor number
         */
        floorNumber: number

        /**
         * Seat amenities (primarily for SEAT space types)
         */
        amenities: string[]

        /**
         * Position coordinates in the bus layout
         */
        position: shared.SeatPosition

        /**
         * Additional metadata for the space (flexible JSON structure)
         */
        meta: { [key: string]: any }

        /**
         * Whether the space is active
         */
        active: boolean

        /**
         * Timestamp when the space was created
         */
        createdAt: string | string | null

        /**
         * Timestamp when the space was last updated
         */
        updatedAt: string | string | null
    }

    export interface UpdatedSeatConfiguration {
        /**
         * Number of spaces created
         */
        seatsCreated: number

        /**
         * Number of spaces updated
         */
        seatsUpdated: number

        /**
         * Number of spaces deactivated
         */
        seatsDeactivated: number

        /**
         * Total number of active seats (SEAT space types only)
         */
        totalActiveSeats: number
    }
}

export namespace buses {
    export interface Bus {
        /**
         * Basic information
         */
        id: number

        economicNumber: string
        registrationNumber: string
        licensePlateType: BusLicensePlateType
        licensePlateNumber: string
        circulationCard: string | null
        availableForTourismOnly: boolean
        status: BusStatus
        transporterId: number | null
        alternateTransporterId: number | null
        busLineId: number | null
        baseId: number | null
        /**
         * Model and manufacturer information
         */
        purchaseDate: string

        expirationDate: string
        erpClientNumber: string | null
        modelId: number
        /**
         * Technical information
         */
        vehicleId: string | null

        serialNumber: string
        engineNumber: string | null
        chassisNumber: string
        grossVehicleWeight: number
        sctPermit: string | null
        /**
         * Maintenance information
         */
        currentKilometer: number | null

        gpsId: string | null
        lastMaintenanceDate: string | null
        nextMaintenanceDate: string | null
        /**
         * Seat Diagram
         */
        seatDiagramId: number

        /**
         * System information
         */
        active: boolean

        createdAt: string | string
        updatedAt: string | string
        deletedAt: string | string | null
    }

    export type BusLicensePlateType = "NATIONAL" | "INTERNATIONAL" | "TOURISM"

    export type BusStatus = "ACTIVE" | "MAINTENANCE" | "REPAIR" | "OUT_OF_SERVICE" | "RESERVED" | "IN_TRANSIT" | "RETIRED"

    export interface CreateBusPayload {
        economicNumber: string
        registrationNumber: string
        licensePlateType: BusLicensePlateType
        licensePlateNumber: string
        circulationCard: string | null
        availableForTourismOnly: boolean
        status: BusStatus
        transporterId?: number | null
        alternateTransporterId?: number | null
        busLineId?: number | null
        baseId?: number | null
        /**
         * Model and manufacturer information
         */
        purchaseDate: string | string

        expirationDate: string | string
        erpClientNumber?: string | null
        modelId: number
        /**
         * Technical information
         */
        vehicleId?: string | null

        serialNumber: string
        engineNumber?: string | null
        chassisNumber: string
        grossVehicleWeight: number
        sctPermit?: string | null
        /**
         * Maintenance information
         */
        currentKilometer?: number | null

        gpsId?: string | null
        lastMaintenanceDate?: string | string | null
        nextMaintenanceDate?: string | string | null
        /**
         * Seat Diagram
         */
        seatDiagramId: number

        /**
         * System information
         */
        active: boolean
    }

    export interface ExtendedBusData {
        manufacturer: string
        model: string
        year: number
        seatingCapacity: number
        numFloors: number
        engineType?: string | null
        /**
         * Basic information
         */
        id: number

        economicNumber: string
        registrationNumber: string
        licensePlateType: BusLicensePlateType
        licensePlateNumber: string
        circulationCard: string | null
        availableForTourismOnly: boolean
        status: BusStatus
        transporterId: number | null
        alternateTransporterId: number | null
        busLineId: number | null
        baseId: number | null
        /**
         * Model and manufacturer information
         */
        purchaseDate: string

        expirationDate: string
        erpClientNumber: string | null
        modelId: number
        /**
         * Technical information
         */
        vehicleId: string | null

        serialNumber: string
        engineNumber: string | null
        chassisNumber: string
        grossVehicleWeight: number
        sctPermit: string | null
        /**
         * Maintenance information
         */
        currentKilometer: number | null

        gpsId: string | null
        lastMaintenanceDate: string | null
        nextMaintenanceDate: string | null
        /**
         * Seat Diagram
         */
        seatDiagramId: number

        /**
         * System information
         */
        active: boolean

        createdAt: string | string
        updatedAt: string | string
        deletedAt: string | string | null
    }

    export interface ListBusStatusesResult {
        data: BusStatus[]
    }

    export interface ListBusesQueryParams {
        orderBy?: {
            field: "id" | "economicNumber" | "registrationNumber" | "licensePlateType" | "licensePlateNumber" | "circulationCard" | "availableForTourismOnly" | "status" | "transporterId" | "alternateTransporterId" | "busLineId" | "baseId" | "purchaseDate" | "expirationDate" | "erpClientNumber" | "modelId" | "vehicleId" | "serialNumber" | "engineNumber" | "chassisNumber" | "grossVehicleWeight" | "sctPermit" | "currentKilometer" | "gpsId" | "lastMaintenanceDate" | "nextMaintenanceDate" | "seatDiagramId" | "active" | "createdAt" | "updatedAt" | "deletedAt"
            direction: "asc" | "desc"
        }[]
        filters?: {
            id?: number
            economicNumber?: string
            registrationNumber?: string
            licensePlateType?: BusLicensePlateType
            licensePlateNumber?: string
            circulationCard?: string | null
            availableForTourismOnly?: boolean
            status?: BusStatus
            transporterId?: number | null
            alternateTransporterId?: number | null
            busLineId?: number | null
            baseId?: number | null
            purchaseDate?: string
            expirationDate?: string
            erpClientNumber?: string | null
            modelId?: number
            vehicleId?: string | null
            serialNumber?: string
            engineNumber?: string | null
            chassisNumber?: string
            grossVehicleWeight?: number
            sctPermit?: string | null
            currentKilometer?: number | null
            gpsId?: string | null
            lastMaintenanceDate?: string | null
            nextMaintenanceDate?: string | null
            seatDiagramId?: number
            active?: boolean
            createdAt?: string | string
            updatedAt?: string | string
            deletedAt?: string | string | null
        }
        searchTerm?: string
    }

    export interface ListBusesResult {
        data: Bus[]
    }

    export interface PaginatedListBusesQueryParams {
        page?: number
        pageSize?: number
        orderBy?: {
            field: "id" | "economicNumber" | "registrationNumber" | "licensePlateType" | "licensePlateNumber" | "circulationCard" | "availableForTourismOnly" | "status" | "transporterId" | "alternateTransporterId" | "busLineId" | "baseId" | "purchaseDate" | "expirationDate" | "erpClientNumber" | "modelId" | "vehicleId" | "serialNumber" | "engineNumber" | "chassisNumber" | "grossVehicleWeight" | "sctPermit" | "currentKilometer" | "gpsId" | "lastMaintenanceDate" | "nextMaintenanceDate" | "seatDiagramId" | "active" | "createdAt" | "updatedAt" | "deletedAt"
            direction: "asc" | "desc"
        }[]
        filters?: {
            id?: number
            economicNumber?: string
            registrationNumber?: string
            licensePlateType?: BusLicensePlateType
            licensePlateNumber?: string
            circulationCard?: string | null
            availableForTourismOnly?: boolean
            status?: BusStatus
            transporterId?: number | null
            alternateTransporterId?: number | null
            busLineId?: number | null
            baseId?: number | null
            purchaseDate?: string
            expirationDate?: string
            erpClientNumber?: string | null
            modelId?: number
            vehicleId?: string | null
            serialNumber?: string
            engineNumber?: string | null
            chassisNumber?: string
            grossVehicleWeight?: number
            sctPermit?: string | null
            currentKilometer?: number | null
            gpsId?: string | null
            lastMaintenanceDate?: string | null
            nextMaintenanceDate?: string | null
            seatDiagramId?: number
            active?: boolean
            createdAt?: string | string
            updatedAt?: string | string
            deletedAt?: string | string | null
        }
        searchTerm?: string
    }

    export interface PaginatedListBusesResult {
        pagination: shared.PaginationMeta
        data: Bus[]
    }
}

export namespace cities {
    export interface City {
        /**
         * Unique identifier for the city
         */
        id: number

        /**
         * Name of the city
         */
        name: string

        /**
         * ID of the state this city belongs to
         */
        stateId: number

        /**
         * Latitude of the city
         */
        latitude: number

        /**
         * Longitude of the city
         */
        longitude: number

        /**
         * Timezone of the city (e.g., "America/Mexico_City")
         */
        timezone: string

        /**
         * Whether the city is currently active in the system
         */
        active: boolean

        /**
         * Timestamp when the city record was created
         */
        createdAt: string | string | null

        /**
         * Timestamp when the city record was last updated
         */
        updatedAt: string | string | null

        /**
         * URL-friendly identifier for the city
         */
        slug: string
    }

    export interface CityWithRelations {
        state: {
            /**
             * Unique identifier for the state
             */
            id: number

            /**
             * Name of the state
             */
            name: string

            /**
             * State code (e.g., "TX", "CA", "NY")
             */
            code: string

            /**
             * ID of the country this state belongs to
             */
            countryId: number

            /**
             * Whether the state is currently active in the system
             */
            active: boolean

            /**
             * Timestamp when the state record was created
             */
            createdAt: string | string | null

            /**
             * Timestamp when the state record was last updated
             */
            updatedAt: string | string | null

            country: countries.Country
        }
        populations: populations.Population[]
        /**
         * Unique identifier for the city
         */
        id: number

        /**
         * Name of the city
         */
        name: string

        /**
         * ID of the state this city belongs to
         */
        stateId: number

        /**
         * Latitude of the city
         */
        latitude: number

        /**
         * Longitude of the city
         */
        longitude: number

        /**
         * Timezone of the city (e.g., "America/Mexico_City")
         */
        timezone: string

        /**
         * Whether the city is currently active in the system
         */
        active: boolean

        /**
         * Timestamp when the city record was created
         */
        createdAt: string | string | null

        /**
         * Timestamp when the city record was last updated
         */
        updatedAt: string | string | null

        /**
         * URL-friendly identifier for the city
         */
        slug: string
    }

    export interface CityWithStateAndCountry {
        state: {
            /**
             * Unique identifier for the state
             */
            id: number

            /**
             * Name of the state
             */
            name: string

            /**
             * State code (e.g., "TX", "CA", "NY")
             */
            code: string

            /**
             * ID of the country this state belongs to
             */
            countryId: number

            /**
             * Whether the state is currently active in the system
             */
            active: boolean

            /**
             * Timestamp when the state record was created
             */
            createdAt: string | string | null

            /**
             * Timestamp when the state record was last updated
             */
            updatedAt: string | string | null

            country: countries.Country
        }
        /**
         * Unique identifier for the city
         */
        id: number

        /**
         * Name of the city
         */
        name: string

        /**
         * ID of the state this city belongs to
         */
        stateId: number

        /**
         * Latitude of the city
         */
        latitude: number

        /**
         * Longitude of the city
         */
        longitude: number

        /**
         * Timezone of the city (e.g., "America/Mexico_City")
         */
        timezone: string

        /**
         * Whether the city is currently active in the system
         */
        active: boolean

        /**
         * Timestamp when the city record was created
         */
        createdAt: string | string | null

        /**
         * Timestamp when the city record was last updated
         */
        updatedAt: string | string | null

        /**
         * URL-friendly identifier for the city
         */
        slug: string
    }

    export interface CreateCityPayload {
        /**
         * Name of the city
         * Must contain only letters (with or without accents) and spaces
         */
        name: string

        /**
         * ID of the state this city belongs to
         * Must be a positive number
         */
        stateId: number

        /**
         * Latitude of the city
         * Must be a number between -90 and 90
         */
        latitude: number

        /**
         * Longitude of the city
         * Must be a number between -180 and 180
         */
        longitude: number

        /**
         * Timezone of the city (e.g., "America/Mexico_City")
         * Must have at least 1 non-whitespace character
         */
        timezone: string

        /**
         * Whether the city is active
         * @default true
         */
        active?: boolean
    }

    export interface ListCitiesQueryParams {
        orderBy?: {
            field: "id" | "name" | "stateId" | "latitude" | "longitude" | "timezone" | "active" | "createdAt" | "updatedAt" | "slug"
            direction: "asc" | "desc"
        }[]
        filters?: {
            id?: number
            name?: string
            stateId?: number
            latitude?: number
            longitude?: number
            timezone?: string
            active?: boolean
            createdAt?: string | string | null
            updatedAt?: string | string | null
            slug?: string
        }
        searchTerm?: string
    }

    export interface ListCitiesResult {
        data: City[]
    }

    export interface PaginatedListCitiesQueryParams {
        page?: number
        pageSize?: number
        orderBy?: {
            field: "id" | "name" | "stateId" | "latitude" | "longitude" | "timezone" | "active" | "createdAt" | "updatedAt" | "slug"
            direction: "asc" | "desc"
        }[]
        filters?: {
            id?: number
            name?: string
            stateId?: number
            latitude?: number
            longitude?: number
            timezone?: string
            active?: boolean
            createdAt?: string | string | null
            updatedAt?: string | string | null
            slug?: string
        }
        searchTerm?: string
    }

    export interface PaginatedListCitiesResult {
        pagination: shared.PaginationMeta
        data: CityWithStateAndCountry[]
    }
}

export namespace countries {
    export interface Country {
        /**
         * Unique identifier for the country
         */
        id: number

        /**
         * Name of the country
         */
        name: string

        /**
         * Whether the country is currently active in the system
         */
        active: boolean

        /**
         * ISO country code (e.g., "US", "CA", "MX")
         */
        code: string

        /**
         * Timestamp when the country record was created
         */
        createdAt: string | string | null

        /**
         * Timestamp when the country record was last updated
         */
        updatedAt: string | string | null
    }

    export interface CreateCountryPayload {
        /**
         * Name of the country
         * Must have at least 1 non-whitespace character
         */
        name: string

        /**
         * ISO country code (e.g., "US", "CA", "MX")
         * Must have at least 1 non-whitespace character
         */
        code: string

        /**
         * Whether the country is active
         * @default true
         */
        active?: boolean
    }

    export interface ListCountriesQueryParams {
        orderBy?: {
            field: "id" | "name" | "active" | "code" | "createdAt" | "updatedAt"
            direction: "asc" | "desc"
        }[]
        filters?: {
            id?: number
            name?: string
            active?: boolean
            code?: string
            createdAt?: string | string | null
            updatedAt?: string | string | null
        }
        searchTerm?: string
    }

    export interface ListCountriesResult {
        data: Country[]
    }

    export interface PaginatedListCountriesQueryParams {
        page?: number
        pageSize?: number
        orderBy?: {
            field: "id" | "name" | "active" | "code" | "createdAt" | "updatedAt"
            direction: "asc" | "desc"
        }[]
        filters?: {
            id?: number
            name?: string
            active?: boolean
            code?: string
            createdAt?: string | string | null
            updatedAt?: string | string | null
        }
        searchTerm?: string
    }

    export interface PaginatedListCountriesResult {
        pagination: shared.PaginationMeta
        data: Country[]
    }
}

export namespace departments {
    export interface CreateDepartmentPayload {
        /**
         * ID of the tenant this department belongs to
         */
        tenantId: number

        /**
         * Name of the department
         * @minLength 2
         */
        name: string

        /**
         * Unique code for the department (alphanumeric with no spaces)
         * @minLength 2
         * @pattern ^[a-zA-Z0-9-]+$
         */
        code: string

        /**
         * Optional description of the department
         */
        description?: string
    }

    export interface Department {
        /**
         * Unique identifier for the department
         */
        id: number

        /**
         * ID of the tenant this department belongs to
         */
        tenantId: number

        /**
         * Name of the department
         */
        name: string

        /**
         * Unique code identifier for the department
         */
        code: string

        /**
         * Optional description of the department
         */
        description?: string | null

        /**
         * Whether the department is currently active
         */
        isActive: boolean

        /**
         * Timestamp when the department record was created
         */
        createdAt: string | string | null

        /**
         * Timestamp when the department record was last updated
         */
        updatedAt: string | string | null
    }

    export interface Departments {
        /**
         * List of departments
         */
        departments: Department[]
    }

    export interface DepartmentsQueryOptions {
        orderBy?: {
            field: "id" | "tenantId" | "name" | "code" | "description" | "isActive" | "createdAt" | "updatedAt"
            direction: "asc" | "desc"
        }[]
        filters?: {
            id?: number
            tenantId?: number
            name?: string
            code?: string
            description?: string | null
            isActive?: boolean
            createdAt?: string | string | null
            updatedAt?: string | string | null
        }
    }

    export interface PaginatedDepartments {
        pagination: shared.PaginationMeta
        data: Department[]
    }

    export interface PaginationParamsDepartments {
        page?: number
        pageSize?: number
        orderBy?: {
            field: "id" | "tenantId" | "name" | "code" | "description" | "isActive" | "createdAt" | "updatedAt"
            direction: "asc" | "desc"
        }[]
        filters?: {
            id?: number
            tenantId?: number
            name?: string
            code?: string
            description?: string | null
            isActive?: boolean
            createdAt?: string | string | null
            updatedAt?: string | string | null
        }
    }
}

export namespace drivers {
    export interface CreateDriverPayload {
        /**
         * Employee ID (Clave)
         * Must have at least 1 non-whitespace character
         */
        driverKey: string

        /**
         * Full name of the driver
         * Must have at least 1 non-whitespace character
         */
        fullName: string

        /**
         * Mexican tax ID (RFC)
         * Must have at least 1 non-whitespace character
         */
        rfc: string

        /**
         * CURP Mexican national ID
         * Must have at least 1 non-whitespace character
         */
        curp: string

        /**
         * Social security number (IMSS)
         */
        imss?: string

        /**
         * Civil status (Estado Civil)
         */
        civilStatus?: string

        /**
         * Number of dependents (Escolaridad)
         */
        dependents?: number

        /**
         * Street address (Calle)
         */
        addressStreet?: string

        /**
         * Neighborhood (Colonia)
         */
        addressNeighborhood?: string

        /**
         * City (Ciudad)
         */
        addressCity?: string

        /**
         * State (Estado)
         */
        addressState?: string

        /**
         * Postal code (Cdigo Postal)
         */
        postalCode?: string

        /**
         * Phone number (Telfono)
         * Must have at least 1 non-whitespace character
         */
        phoneNumber: string

        /**
         * Email address (E-Mail)
         * Must be a valid email format
         */
        email: string

        /**
         * Type of operator (Tipo Operador)
         * Must have at least 1 non-whitespace character
         */
        driverType: DriverType

        /**
         * Department (Departamento)
         */
        department?: string

        /**
         * Position (Clave Puesto)
         */
        position?: DriverPosition

        /**
         * Office code (Clave Oficina)
         */
        officeCode?: string

        /**
         * Office location
         */
        officeLocation?: string

        /**
         * Date of hiring (Fec. Ingreso)
         */
        hireDate?: string

        /**
         * Current status (Estado Actual)
         */
        status: DriverStatus

        /**
         * Status date (Fecha Estado)
         */
        statusDate: string

        /**
         * Federal license (Licencia Federal)
         */
        federalLicense?: string

        /**
         * Federal license expiry (Fecha Lic. Fed)
         */
        federalLicenseExpiry?: string

        /**
         * State license (Licencia Estatal)
         */
        stateLicense?: string

        /**
         * State license expiry (Fecha Lic. Est)
         */
        stateLicenseExpiry?: string

        /**
         * Credit card info (Tarjeta Crdito)
         */
        creditCard?: string

        /**
         * Credit card expiry (Fecha T. Crdito)
         */
        creditCardExpiry?: string

        /**
         * Company (Empresa Alterna)
         */
        company?: string

        /**
         * Whether the driver is active
         * @default true
         */
        active?: boolean

        /**
         * The transporter this driver is associated with
         */
        transporterId?: number | null

        /**
         * The bus line this driver is associated with
         */
        busLineId?: number | null

        /**
         * The bus this driver is assigned to
         */
        busId?: number | null
    }

    export interface Driver {
        /**
         * Unique identifier for the driver
         */
        id: number

        /**
         * Employee ID (Clave)
         */
        driverKey: string

        /**
         * Full name of the driver
         */
        fullName: string

        /**
         * Mexican tax ID (RFC)
         */
        rfc: string

        /**
         * CURP Mexican national ID
         */
        curp: string

        /**
         * Social security number (IMSS)
         */
        imss: string | null

        /**
         * Civil status (Estado Civil)
         */
        civilStatus: string | null

        /**
         * Number of dependents (Escolaridad)
         */
        dependents: number | null

        /**
         * Street address (Calle)
         */
        addressStreet: string | null

        /**
         * Neighborhood (Colonia)
         */
        addressNeighborhood: string | null

        /**
         * City (Ciudad)
         */
        addressCity: string | null

        /**
         * State (Estado)
         */
        addressState: string | null

        /**
         * Postal code (Cdigo Postal)
         */
        postalCode: string | null

        /**
         * Phone number (Telfono)
         */
        phoneNumber: string

        /**
         * Email address (E-Mail)
         */
        email: string

        /**
         * Type of operator (Tipo Operador)
         */
        driverType: DriverType

        /**
         * Position (Clave Puesto)
         */
        position: DriverPosition | null

        /**
         * Office code (Clave Oficina)
         */
        officeCode: string | null

        /**
         * Office location
         */
        officeLocation: string | null

        /**
         * Date of hiring (Fec. Ingreso)
         */
        hireDate: string | string | null

        /**
         * Current status (Estado Actual)
         */
        status: DriverStatus

        /**
         * Status date (Fecha Estado)
         */
        statusDate: string | string

        /**
         * Federal license (Licencia Federal)
         */
        federalLicense: string | null

        /**
         * Federal license expiry (Fecha Lic. Fed)
         */
        federalLicenseExpiry: string | string | null

        /**
         * State license (Licencia Estatal)
         */
        stateLicense: string | null

        /**
         * State license expiry (Fecha Lic. Est)
         */
        stateLicenseExpiry: string | string | null

        /**
         * Credit card info (Tarjeta Crdito)
         */
        creditCard: string | null

        /**
         * Credit card expiry (Fecha T. Crdito)
         */
        creditCardExpiry: string | string | null

        /**
         * Company (Empresa Alterna)
         */
        company: string | null

        /**
         * The transporter this driver is associated with
         */
        transporterId: number | null

        /**
         * The bus line this driver is associated with
         */
        busLineId: number | null

        /**
         * The bus this driver is assigned to
         */
        busId: number | null

        /**
         * Whether the driver is currently active in the system
         */
        active: boolean

        /**
         * Timestamp when the driver record was created
         */
        createdAt: string | string | null

        /**
         * Timestamp when the driver record was last updated
         */
        updatedAt: string | string | null
    }

    export type DriverPosition = "driver" | "senior_driver" | "auxiliary_driver" | "tourist_driver" | "premium_driver"

    export type DriverStatus = "active" | "inactive" | "suspended" | "on_leave" | "terminated" | "in_training" | "probation"

    export type DriverType = "standard" | "substitute" | "temporary" | "tourist"

    export interface DriverWithRelations {
        transporter: transporters.Transporter
        busLine: bus_lines.BusLine
        /**
         * Unique identifier for the driver
         */
        id: number

        /**
         * Employee ID (Clave)
         */
        driverKey: string

        /**
         * Full name of the driver
         */
        fullName: string

        /**
         * Mexican tax ID (RFC)
         */
        rfc: string

        /**
         * CURP Mexican national ID
         */
        curp: string

        /**
         * Social security number (IMSS)
         */
        imss: string | null

        /**
         * Civil status (Estado Civil)
         */
        civilStatus: string | null

        /**
         * Number of dependents (Escolaridad)
         */
        dependents: number | null

        /**
         * Street address (Calle)
         */
        addressStreet: string | null

        /**
         * Neighborhood (Colonia)
         */
        addressNeighborhood: string | null

        /**
         * City (Ciudad)
         */
        addressCity: string | null

        /**
         * State (Estado)
         */
        addressState: string | null

        /**
         * Postal code (Cdigo Postal)
         */
        postalCode: string | null

        /**
         * Phone number (Telfono)
         */
        phoneNumber: string

        /**
         * Email address (E-Mail)
         */
        email: string

        /**
         * Type of operator (Tipo Operador)
         */
        driverType: DriverType

        /**
         * Position (Clave Puesto)
         */
        position: DriverPosition | null

        /**
         * Office code (Clave Oficina)
         */
        officeCode: string | null

        /**
         * Office location
         */
        officeLocation: string | null

        /**
         * Date of hiring (Fec. Ingreso)
         */
        hireDate: string | string | null

        /**
         * Current status (Estado Actual)
         */
        status: DriverStatus

        /**
         * Status date (Fecha Estado)
         */
        statusDate: string | string

        /**
         * Federal license (Licencia Federal)
         */
        federalLicense: string | null

        /**
         * Federal license expiry (Fecha Lic. Fed)
         */
        federalLicenseExpiry: string | string | null

        /**
         * State license (Licencia Estatal)
         */
        stateLicense: string | null

        /**
         * State license expiry (Fecha Lic. Est)
         */
        stateLicenseExpiry: string | string | null

        /**
         * Credit card info (Tarjeta Crdito)
         */
        creditCard: string | null

        /**
         * Credit card expiry (Fecha T. Crdito)
         */
        creditCardExpiry: string | string | null

        /**
         * Company (Empresa Alterna)
         */
        company: string | null

        /**
         * The transporter this driver is associated with
         */
        transporterId: number | null

        /**
         * The bus line this driver is associated with
         */
        busLineId: number | null

        /**
         * The bus this driver is assigned to
         */
        busId: number | null

        /**
         * Whether the driver is currently active in the system
         */
        active: boolean

        /**
         * Timestamp when the driver record was created
         */
        createdAt: string | string | null

        /**
         * Timestamp when the driver record was last updated
         */
        updatedAt: string | string | null
    }

    export interface ListDriversQueryParams {
        orderBy?: {
            field: "id" | "driverKey" | "fullName" | "rfc" | "curp" | "imss" | "civilStatus" | "dependents" | "addressStreet" | "addressNeighborhood" | "addressCity" | "addressState" | "postalCode" | "phoneNumber" | "email" | "driverType" | "position" | "officeCode" | "officeLocation" | "hireDate" | "status" | "statusDate" | "federalLicense" | "federalLicenseExpiry" | "stateLicense" | "stateLicenseExpiry" | "creditCard" | "creditCardExpiry" | "company" | "transporterId" | "busLineId" | "busId" | "active" | "createdAt" | "updatedAt"
            direction: "asc" | "desc"
        }[]
        filters?: {
            id?: number
            driverKey?: string
            fullName?: string
            rfc?: string
            curp?: string
            imss?: string | null
            civilStatus?: string | null
            dependents?: number | null
            addressStreet?: string | null
            addressNeighborhood?: string | null
            addressCity?: string | null
            addressState?: string | null
            postalCode?: string | null
            phoneNumber?: string
            email?: string
            driverType?: DriverType
            position?: DriverPosition | null
            officeCode?: string | null
            officeLocation?: string | null
            hireDate?: string | string | null
            status?: DriverStatus
            statusDate?: string | string
            federalLicense?: string | null
            federalLicenseExpiry?: string | string | null
            stateLicense?: string | null
            stateLicenseExpiry?: string | string | null
            creditCard?: string | null
            creditCardExpiry?: string | string | null
            company?: string | null
            transporterId?: number | null
            busLineId?: number | null
            busId?: number | null
            active?: boolean
            createdAt?: string | string | null
            updatedAt?: string | string | null
        }
        searchTerm?: string
    }

    export interface ListDriversResult {
        data: Driver[]
    }

    export interface ListStatusesResult {
        data: DriverStatus[]
    }

    export interface PaginatedListDriversQueryParams {
        page?: number
        pageSize?: number
        orderBy?: {
            field: "id" | "driverKey" | "fullName" | "rfc" | "curp" | "imss" | "civilStatus" | "dependents" | "addressStreet" | "addressNeighborhood" | "addressCity" | "addressState" | "postalCode" | "phoneNumber" | "email" | "driverType" | "position" | "officeCode" | "officeLocation" | "hireDate" | "status" | "statusDate" | "federalLicense" | "federalLicenseExpiry" | "stateLicense" | "stateLicenseExpiry" | "creditCard" | "creditCardExpiry" | "company" | "transporterId" | "busLineId" | "busId" | "active" | "createdAt" | "updatedAt"
            direction: "asc" | "desc"
        }[]
        filters?: {
            id?: number
            driverKey?: string
            fullName?: string
            rfc?: string
            curp?: string
            imss?: string | null
            civilStatus?: string | null
            dependents?: number | null
            addressStreet?: string | null
            addressNeighborhood?: string | null
            addressCity?: string | null
            addressState?: string | null
            postalCode?: string | null
            phoneNumber?: string
            email?: string
            driverType?: DriverType
            position?: DriverPosition | null
            officeCode?: string | null
            officeLocation?: string | null
            hireDate?: string | string | null
            status?: DriverStatus
            statusDate?: string | string
            federalLicense?: string | null
            federalLicenseExpiry?: string | string | null
            stateLicense?: string | null
            stateLicenseExpiry?: string | string | null
            creditCard?: string | null
            creditCardExpiry?: string | string | null
            company?: string | null
            transporterId?: number | null
            busLineId?: number | null
            busId?: number | null
            active?: boolean
            createdAt?: string | string | null
            updatedAt?: string | string | null
        }
        searchTerm?: string
    }

    export interface PaginatedListDriversResult {
        pagination: shared.PaginationMeta
        data: DriverWithRelations[]
    }
}

export namespace event_types {
    export interface CreateEventTypePayload {
        /**
         * Name of the event type (required, non-empty)
         * Must have at least 1 non-whitespace character
         */
        name: string

        /**
         * Unique code for the event type (required, non-empty)
         * Must have at least 1 non-whitespace character
         */
        code: string

        /**
         * Optional description of the event type
         */
        description?: string

        /**
         * Base time in minutes (required, must be positive integer)
         * @minimum 1
         */
        baseTime: number

        /**
         * Whether this event type requires cost tracking (defaults to false)
         * @default false
         */
        needsCost?: boolean

        /**
         * Whether this event type requires quantity tracking (defaults to false)
         * @default false
         */
        needsQuantity?: boolean

        /**
         * Whether this event type is part of system integration
         * @default false
         */
        integration?: boolean

        /**
         * Whether this event type is active
         * @default true
         */
        active?: boolean
    }

    export interface EventType {
        /**
         * Unique identifier for the event type
         */
        id: number

        /**
         * Name of the event type
         */
        name: string

        /**
         * Unique code for the event type
         */
        code: string

        /**
         * Optional description of the event type
         */
        description: string | null

        /**
         * Base time in minutes for this event type
         */
        baseTime: number

        /**
         * Whether this event type requires cost tracking
         */
        needsCost: boolean

        /**
         * Whether this event type requires quantity tracking
         */
        needsQuantity: boolean

        /**
         * Whether this is an integration event type
         */
        integration: boolean

        /**
         * Whether the event type is active
         */
        active: boolean

        /**
         * Timestamp when the event type was created
         */
        createdAt: string | string | null

        /**
         * Timestamp when the event type was last updated
         */
        updatedAt: string | string | null
    }

    export interface ListEventTypesQueryParams {
        orderBy?: {
            field: "id" | "name" | "code" | "description" | "baseTime" | "needsCost" | "needsQuantity" | "integration" | "active" | "createdAt" | "updatedAt"
            direction: "asc" | "desc"
        }[]
        filters?: {
            id?: number
            name?: string
            code?: string
            description?: string | null
            baseTime?: number
            needsCost?: boolean
            needsQuantity?: boolean
            integration?: boolean
            active?: boolean
            createdAt?: string | string | null
            updatedAt?: string | string | null
        }
        searchTerm?: string
    }

    export interface ListEventTypesResult {
        data: EventType[]
    }

    export interface PaginatedListEventTypesQueryParams {
        page?: number
        pageSize?: number
        orderBy?: {
            field: "id" | "name" | "code" | "description" | "baseTime" | "needsCost" | "needsQuantity" | "integration" | "active" | "createdAt" | "updatedAt"
            direction: "asc" | "desc"
        }[]
        filters?: {
            id?: number
            name?: string
            code?: string
            description?: string | null
            baseTime?: number
            needsCost?: boolean
            needsQuantity?: boolean
            integration?: boolean
            active?: boolean
            createdAt?: string | string | null
            updatedAt?: string | string | null
        }
        searchTerm?: string
    }

    export interface PaginatedListEventTypesResult {
        pagination: shared.PaginationMeta
        data: EventType[]
    }
}

export namespace installation_properties {
    export interface PropertyInput {
        /**
         * Name of the property that should match a schema name
         */
        name: string

        /**
         * Raw value as string that needs to be cast to the appropriate type
         */
        value: string
    }
}

export namespace installation_schemas {
    export interface CreateInstallationSchemaPayload {
        /**
         * Name of the schema field
         * Must have at least 1 non-whitespace character
         */
        name: string

        /**
         * Optional description of the schema field
         */
        description?: string

        /**
         * Type of the field
         */
        type: InstallationSchemaFieldType

        /**
         * Configuration options for the field (only required for enum type)
         */
        options?: InstallationSchemaOptions

        /**
         * Whether the field is required
         * @default false
         */
        required?: boolean

        /**
         * ID of the installation type this schema belongs to
         */
        installationTypeId: number
    }

    export interface InstallationSchema {
        /**
         * Unique identifier for the installation schema
         */
        id: number

        /**
         * Name of the schema field
         */
        name: string

        /**
         * Optional description of the schema field
         */
        description: string | null

        /**
         * Type of the field (string, number, boolean, date, enum)
         */
        type: InstallationSchemaFieldType

        /**
         * Configuration options for the field (only used for enum type)
         */
        options: InstallationSchemaOptions

        /**
         * Whether the field is required
         */
        required: boolean

        /**
         * ID of the installation type this schema belongs to
         */
        installationTypeId: number

        /**
         * Timestamp when the installation schema record was created
         */
        createdAt: string | string | null

        /**
         * Timestamp when the installation schema record was last updated
         */
        updatedAt: string | string | null
    }

    export type InstallationSchemaFieldType = "string" | "long_text" | "number" | "boolean" | "date" | "enum"

    export interface InstallationSchemaOptions {
        /**
         * For enum type: array of possible values
         */
        enumValues?: string[]
    }

    export interface InstallationSchemaWithRelations {
        /**
         * Related installation type
         */
        installationType: {
            id: number
            name: string
            description: string | null
        }

        /**
         * Unique identifier for the installation schema
         */
        id: number

        /**
         * Name of the schema field
         */
        name: string

        /**
         * Optional description of the schema field
         */
        description: string | null

        /**
         * Type of the field (string, number, boolean, date, enum)
         */
        type: InstallationSchemaFieldType

        /**
         * Configuration options for the field (only used for enum type)
         */
        options: InstallationSchemaOptions

        /**
         * Whether the field is required
         */
        required: boolean

        /**
         * ID of the installation type this schema belongs to
         */
        installationTypeId: number

        /**
         * Timestamp when the installation schema record was created
         */
        createdAt: string | string | null

        /**
         * Timestamp when the installation schema record was last updated
         */
        updatedAt: string | string | null
    }

    export interface ListInstallationSchemasQueryParams {
        orderBy?: {
            field: "id" | "name" | "description" | "type" | "options" | "required" | "installationTypeId" | "createdAt" | "updatedAt"
            direction: "asc" | "desc"
        }[]
        filters?: {
            id?: number
            name?: string
            description?: string | null
            type?: InstallationSchemaFieldType
            options?: InstallationSchemaOptions
            required?: boolean
            installationTypeId?: number
            createdAt?: string | string | null
            updatedAt?: string | string | null
        }
        searchTerm?: string
    }

    export interface ListInstallationSchemasResult {
        data: InstallationSchema[]
    }

    export interface PaginatedListInstallationSchemasQueryParams {
        page?: number
        pageSize?: number
        orderBy?: {
            field: "id" | "name" | "description" | "type" | "options" | "required" | "installationTypeId" | "createdAt" | "updatedAt"
            direction: "asc" | "desc"
        }[]
        filters?: {
            id?: number
            name?: string
            description?: string | null
            type?: InstallationSchemaFieldType
            options?: InstallationSchemaOptions
            required?: boolean
            installationTypeId?: number
            createdAt?: string | string | null
            updatedAt?: string | string | null
        }
        searchTerm?: string
    }

    export interface PaginatedListInstallationSchemasResult {
        pagination: shared.PaginationMeta
        data: InstallationSchemaWithRelations[]
    }
}

export namespace installation_types {
    export interface CreateInstallationTypePayload {
        /**
         * Name of the installation type
         * Must have at least 1 non-whitespace character
         */
        name: string

        /**
         * Code of the installation type
         * Must have at least 1 non-whitespace character
         */
        code: string

        /**
         * Optional description of the installation type
         */
        description?: string | null

        /**
         * Whether the installation type is active
         * @default true
         */
        active?: boolean
    }

    export interface InstallationType {
        /**
         * Unique identifier for the installation type
         */
        id: number

        /**
         * Name of the installation type
         */
        name: string

        /**
         * Code of the installation type
         */
        code: string

        /**
         * Optional description of the installation type
         */
        description: string | null

        /**
         * Whether the installation type is active
         */
        active: boolean

        /**
         * Timestamp when the installation type record was created
         */
        createdAt: string | string | null

        /**
         * Timestamp when the installation type record was last updated
         */
        updatedAt: string | string | null
    }

    export interface InstallationTypeWithRelations {
        /**
         * Array of event types assigned to this installation type
         */
        eventTypes: event_types.EventType[]

        /**
         * Unique identifier for the installation type
         */
        id: number

        /**
         * Name of the installation type
         */
        name: string

        /**
         * Code of the installation type
         */
        code: string

        /**
         * Optional description of the installation type
         */
        description: string | null

        /**
         * Whether the installation type is active
         */
        active: boolean

        /**
         * Timestamp when the installation type record was created
         */
        createdAt: string | string | null

        /**
         * Timestamp when the installation type record was last updated
         */
        updatedAt: string | string | null
    }

    export interface ListInstallationTypesQueryParams {
        orderBy?: {
            field: "id" | "name" | "code" | "description" | "active" | "createdAt" | "updatedAt"
            direction: "asc" | "desc"
        }[]
        filters?: {
            id?: number
            name?: string
            code?: string
            description?: string | null
            active?: boolean
            createdAt?: string | string | null
            updatedAt?: string | string | null
        }
        searchTerm?: string
    }

    export interface ListInstallationTypesResult {
        data: InstallationType[]
    }

    export interface PaginatedListInstallationTypesQueryParams {
        page?: number
        pageSize?: number
        orderBy?: {
            field: "id" | "name" | "code" | "description" | "active" | "createdAt" | "updatedAt"
            direction: "asc" | "desc"
        }[]
        filters?: {
            id?: number
            name?: string
            code?: string
            description?: string | null
            active?: boolean
            createdAt?: string | string | null
            updatedAt?: string | string | null
        }
        searchTerm?: string
    }

    export interface PaginatedListInstallationTypesResult {
        pagination: shared.PaginationMeta
        data: InstallationType[]
    }

    export interface SyncInstallationSchemaPayload {
        /**
         * Optional ID for existing schemas (null/undefined for new schemas)
         * If provided, the schema will be updated; if not, a new schema will be created
         */
        id?: number | null

        name: string
        description?: string
        type: installation_schemas.InstallationSchemaFieldType
        options?: installation_schemas.InstallationSchemaOptions
        required?: boolean
    }
}

export namespace installations {
    export interface CreateNodeInstallationPayload {
        /**
         * ID of the node to associate the installation with
         * Must be a positive number
         */
        nodeId: number

        /**
         * Name of the installation
         * Must have at least 1 non-whitespace character
         */
        name: string

        /**
         * Physical address of the installation
         * Must have at least 1 non-whitespace character
         */
        address: string

        /**
         * Optional description of the installation
         */
        description?: string | null

        /**
         * Optional contact phone number for the installation
         * Must match phone number format if provided
         */
        contactPhone?: string | null

        /**
         * Optional contact email address for the installation
         * Must be a valid email format if provided
         */
        contactEmail?: string | null

        /**
         * Optional website URL for the installation
         * Must be a valid URL starting with http:// or https:// if provided
         */
        website?: string | null

        /**
         * Optional ID of the installation type this installation belongs to
         * Must be a positive number if provided
         */
        installationTypeId?: number | null

        /**
         * Optional operating hours of the installation
         */
        operatingHours?: OperatingHours | null
    }

    export interface Installation {
        /**
         * Unique identifier for the installation
         */
        id: number

        /**
         * Name of the installation
         */
        name: string

        /**
         * Physical address of the installation
         */
        address: string

        /**
         * Optional description of the installation
         */
        description: string | null

        /**
         * Contact phone number for the installation
         */
        contactPhone: string | null

        /**
         * Contact email address for the installation
         */
        contactEmail: string | null

        /**
         * Website URL for the installation
         */
        website: string | null

        /**
         * ID of the installation type this installation belongs to
         */
        installationTypeId: number | null

        /**
         * Operating hours of the installation
         */
        operatingHours: OperatingHours | null

        /**
         * Timestamp when the installation record was created
         */
        createdAt: string | string | null

        /**
         * Timestamp when the installation record was last updated
         */
        updatedAt: string | string | null
    }

    export interface InstallationLocation {
        /**
         * Latitude coordinate of the installation
         */
        latitude: number

        /**
         * Longitude coordinate of the installation
         */
        longitude: number

        /**
         * Radius of coverage for the installation in meters
         */
        radius: number
    }

    export interface InstallationPropertyResponse {
        /**
         * Unique identifier of the property instance (null if not yet created)
         */
        id?: number | null

        /**
         * Property name (identifier)
         */
        name: string

        /**
         * Human-readable label for display
         */
        label: string

        /**
         * Optional description/help text for the property
         */
        description?: string | null

        /**
         * Property data type
         */
        type: installation_schemas.InstallationSchemaFieldType

        /**
         * Current value casted to appropriate type (null if not set)
         */
        value: string | number | boolean | null

        /**
         * Whether this property is required
         */
        required: boolean

        /**
         * Available options for enum types
         */
        options?: installation_schemas.InstallationSchemaOptions | null

        /**
         * Schema ID for reference
         */
        schemaId: number
    }

    export interface InstallationWithDetails {
        /**
         * Location information from the associated node
         */
        location: InstallationLocation | null

        /**
         * Complete property definitions with values for this installation
         */
        properties: InstallationPropertyResponse[]

        /**
         * Amenities assigned to this installation (filtered by type = 'installation')
         */
        amenities: amenities.Amenity[]

        /**
         * Unique identifier for the installation
         */
        id: number

        /**
         * Name of the installation
         */
        name: string

        /**
         * Physical address of the installation
         */
        address: string

        /**
         * Optional description of the installation
         */
        description: string | null

        /**
         * Contact phone number for the installation
         */
        contactPhone: string | null

        /**
         * Contact email address for the installation
         */
        contactEmail: string | null

        /**
         * Website URL for the installation
         */
        website: string | null

        /**
         * ID of the installation type this installation belongs to
         */
        installationTypeId: number | null

        /**
         * Operating hours of the installation
         */
        operatingHours: OperatingHours | null

        /**
         * Timestamp when the installation record was created
         */
        createdAt: string | string | null

        /**
         * Timestamp when the installation record was last updated
         */
        updatedAt: string | string | null
    }

    export interface ListInstallationsQueryParams {
        orderBy?: {
            field: "id" | "name" | "address" | "description" | "contactPhone" | "contactEmail" | "website" | "installationTypeId" | "operatingHours" | "createdAt" | "updatedAt"
            direction: "asc" | "desc"
        }[]
        filters?: {
            id?: number
            name?: string
            address?: string
            description?: string | null
            contactPhone?: string | null
            contactEmail?: string | null
            website?: string | null
            installationTypeId?: number | null
            operatingHours?: OperatingHours | null
            createdAt?: string | string | null
            updatedAt?: string | string | null
        }
        searchTerm?: string
    }

    export interface ListInstallationsResult {
        data: Installation[]
    }

    export interface OperatingHours {
        /**
         * Monday opening hours - can be a single TimeSlot or array of TimeSlots
         */
        monday?: TimeSlot | TimeSlot[]

        /**
         * Tuesday opening hours - can be a single TimeSlot or array of TimeSlots
         */
        tuesday?: TimeSlot | TimeSlot[]

        /**
         * Wednesday opening hours - can be a single TimeSlot or array of TimeSlots
         */
        wednesday?: TimeSlot | TimeSlot[]

        /**
         * Thursday opening hours - can be a single TimeSlot or array of TimeSlots
         */
        thursday?: TimeSlot | TimeSlot[]

        /**
         * Friday opening hours - can be a single TimeSlot or array of TimeSlots
         */
        friday?: TimeSlot | TimeSlot[]

        /**
         * Saturday opening hours - can be a single TimeSlot or array of TimeSlots
         */
        saturday?: TimeSlot | TimeSlot[]

        /**
         * Sunday opening hours - can be a single TimeSlot or array of TimeSlots
         */
        sunday?: TimeSlot | TimeSlot[]
    }

    export interface PaginatedListInstallationsQueryParams {
        page?: number
        pageSize?: number
        orderBy?: {
            field: "id" | "name" | "address" | "description" | "contactPhone" | "contactEmail" | "website" | "installationTypeId" | "operatingHours" | "createdAt" | "updatedAt"
            direction: "asc" | "desc"
        }[]
        filters?: {
            id?: number
            name?: string
            address?: string
            description?: string | null
            contactPhone?: string | null
            contactEmail?: string | null
            website?: string | null
            installationTypeId?: number | null
            operatingHours?: OperatingHours | null
            createdAt?: string | string | null
            updatedAt?: string | string | null
        }
        searchTerm?: string
    }

    export interface PaginatedListInstallationsResult {
        pagination: shared.PaginationMeta
        data: InstallationWithDetails[]
    }

    export interface TimeSlot {
        /**
         * Opening time in format HH:MM (24-hour format)
         */
        open: string

        /**
         * Closing time in format HH:MM (24-hour format)
         */
        close: string
    }
}

export namespace labels {
    export interface CreateLabelPayload {
        /**
         * Name of the label
         * Must have at least 1 non-whitespace character
         */
        name: string

        /**
         * Optional description of the label
         */
        description?: string

        /**
         * Color of the label in hexadecimal format (#RRGGBB or #RGB)
         * Must be a valid hexadecimal color code
         */
        color: string

        /**
         * Whether the label is active
         * @default true
         */
        active?: boolean
    }

    export interface Label {
        /**
         * Unique identifier for the label
         */
        id: number

        /**
         * Name of the label
         */
        name: string

        /**
         * Optional description of the label
         */
        description: string | null

        /**
         * Color of the label in hexadecimal format (#RRGGBB or #RGB)
         */
        color: string

        /**
         * Whether the label is active
         */
        active: boolean

        /**
         * Timestamp when the label record was created
         */
        createdAt: string | string | null

        /**
         * Timestamp when the label record was last updated
         */
        updatedAt: string | string | null
    }

    export interface LabelWithNodeCount {
        /**
         * Number of nodes associated with this label
         */
        nodeCount: number

        /**
         * Unique identifier for the label
         */
        id: number

        /**
         * Name of the label
         */
        name: string

        /**
         * Optional description of the label
         */
        description: string | null

        /**
         * Color of the label in hexadecimal format (#RRGGBB or #RGB)
         */
        color: string

        /**
         * Whether the label is active
         */
        active: boolean

        /**
         * Timestamp when the label record was created
         */
        createdAt: string | string | null

        /**
         * Timestamp when the label record was last updated
         */
        updatedAt: string | string | null
    }

    export interface LabelsMetrics {
        /**
         * Total number of labels in the system
         */
        totalLabels: number

        /**
         * Number of labels that are currently assigned to at least one node
         */
        labelsInUse: number

        /**
         * Information about the most used labels (all labels with the highest node count)
         */
        mostUsedLabels: {
            /**
             * Number of nodes assigned to this label
             */
            nodeCount: number

            /**
             * Name of the label
             */
            name: string

            /**
             * Color of the label
             */
            color: string
        }[]
    }

    export interface ListLabelsQueryParams {
        orderBy?: {
            field: "id" | "name" | "description" | "color" | "active" | "createdAt" | "updatedAt"
            direction: "asc" | "desc"
        }[]
        filters?: {
            id?: number
            name?: string
            description?: string | null
            color?: string
            active?: boolean
            createdAt?: string | string | null
            updatedAt?: string | string | null
        }
        searchTerm?: string
    }

    export interface ListLabelsResult {
        data: LabelWithNodeCount[]
    }

    export interface PaginatedListLabelsQueryParams {
        page?: number
        pageSize?: number
        orderBy?: {
            field: "id" | "name" | "description" | "color" | "active" | "createdAt" | "updatedAt"
            direction: "asc" | "desc"
        }[]
        filters?: {
            id?: number
            name?: string
            description?: string | null
            color?: string
            active?: boolean
            createdAt?: string | string | null
            updatedAt?: string | string | null
        }
        searchTerm?: string
    }

    export interface PaginatedListLabelsResult {
        pagination: shared.PaginationMeta
        data: LabelWithNodeCount[]
    }
}

export namespace node_events {
    export interface NodeEventFlat {
        /**
         * From node_events table
         */
        id: number

        nodeId: number
        eventTypeId: number
        customTime: number | null
        createdAt: string | string | null
        updatedAt: string | string | null
        /**
         * From event_types table (flattened)
         */
        name: string

        code: string
        description: string | null
        baseTime: number
        needsCost: boolean
        needsQuantity: boolean
        integration: boolean
        active: boolean
    }
}

export namespace nodes {
    export interface CreateNodePayload {
        /**
         * Unique code identifier for the node
         * Must have at least 1 non-whitespace character
         */
        code: string

        /**
         * Name of the node
         * Must have at least 1 non-whitespace character
         */
        name: string

        /**
         * Latitude coordinate of the node
         * Must be a number between -90 and 90
         */
        latitude: number

        /**
         * Longitude coordinate of the node
         * Must be a number between -180 and 180
         */
        longitude: number

        /**
         * Radius of coverage for the node in meters
         * Must be a positive number
         */
        radius: number

        /**
         * Whether passengers can board at this node
         * @default false
         */
        allowsBoarding?: boolean

        /**
         * Whether passengers can alight at this node
         * @default false
         */
        allowsAlighting?: boolean

        /**
         * Whether the node is active or not
         * @default true
         */
        active?: boolean

        /**
         * ID of the city this node belongs to
         * Must be a positive number
         */
        cityId: number

        /**
         * ID of the population this node belongs to
         * Must be a positive number
         */
        populationId: number

        /**
         * Optional ID of the installation associated with this node
         * Must be a positive number if provided
         */
        installationId?: number
    }

    export interface ListNodesQueryParams {
        filters?: {
            id?: number
            code?: string
            name?: string
            latitude?: number
            longitude?: number
            radius?: number
            slug?: string
            allowsBoarding?: boolean
            allowsAlighting?: boolean
            active?: boolean
            cityId?: number
            populationId?: number
            installationId?: number | null
            createdAt?: string | string | null
            updatedAt?: string | string | null
            /**
             * Optional label IDs to filter nodes that have any of these labels assigned
             */
            labelIds?: number[] | null
        }
        orderBy?: {
            field: "id" | "code" | "name" | "latitude" | "longitude" | "radius" | "slug" | "allowsBoarding" | "allowsAlighting" | "active" | "cityId" | "populationId" | "installationId" | "createdAt" | "updatedAt"
            direction: "asc" | "desc"
        }[]
        searchTerm?: string
    }

    export interface ListNodesResult {
        data: Node[]
    }

    export interface Node {
        /**
         * Unique identifier for the node
         */
        id: number

        /**
         * Unique code identifier for the node
         */
        code: string

        /**
         * Name of the node
         */
        name: string

        /**
         * Latitude coordinate of the node
         */
        latitude: number

        /**
         * Longitude coordinate of the node
         */
        longitude: number

        /**
         * Radius of coverage for the node in meters
         */
        radius: number

        /**
         * URL-friendly identifier for the node
         */
        slug: string

        /**
         * Whether passengers can board at this node
         */
        allowsBoarding: boolean

        /**
         * Whether passengers can alight at this node
         */
        allowsAlighting: boolean

        /**
         * Whether the node is active or not
         */
        active: boolean

        /**
         * ID of the city this node belongs to
         */
        cityId: number

        /**
         * ID of the population this node belongs to
         */
        populationId: number

        /**
         * Optional ID of the installation associated with this node
         */
        installationId: number | null

        /**
         * Timestamp when the node record was created
         */
        createdAt: string | string | null

        /**
         * Timestamp when the node record was last updated
         */
        updatedAt: string | string | null
    }

    export interface NodeEventAssignmentPayload {
        /**
         * ID of the event type to assign
         */
        eventTypeId: number

        /**
         * Optional custom time that overrides the base time
         */
        customTime?: number
    }

    export interface NodeWithRelations {
        city: cities.City
        population: populations.Population
        installation: installations.InstallationWithDetails | null
        nodeEvents: node_events.NodeEventFlat[]
        labels: labels.Label[]
        /**
         * Unique identifier for the node
         */
        id: number

        /**
         * Unique code identifier for the node
         */
        code: string

        /**
         * Name of the node
         */
        name: string

        /**
         * Latitude coordinate of the node
         */
        latitude: number

        /**
         * Longitude coordinate of the node
         */
        longitude: number

        /**
         * Radius of coverage for the node in meters
         */
        radius: number

        /**
         * URL-friendly identifier for the node
         */
        slug: string

        /**
         * Whether passengers can board at this node
         */
        allowsBoarding: boolean

        /**
         * Whether passengers can alight at this node
         */
        allowsAlighting: boolean

        /**
         * Whether the node is active or not
         */
        active: boolean

        /**
         * ID of the city this node belongs to
         */
        cityId: number

        /**
         * ID of the population this node belongs to
         */
        populationId: number

        /**
         * Optional ID of the installation associated with this node
         */
        installationId: number | null

        /**
         * Timestamp when the node record was created
         */
        createdAt: string | string | null

        /**
         * Timestamp when the node record was last updated
         */
        updatedAt: string | string | null
    }

    export interface PaginatedListNodesQueryParams {
        filters?: {
            id?: number
            code?: string
            name?: string
            latitude?: number
            longitude?: number
            radius?: number
            slug?: string
            allowsBoarding?: boolean
            allowsAlighting?: boolean
            active?: boolean
            cityId?: number
            populationId?: number
            installationId?: number | null
            createdAt?: string | string | null
            updatedAt?: string | string | null
            /**
             * Optional label IDs to filter nodes that have any of these labels assigned
             */
            labelIds?: number[] | null
        }
        page?: number
        pageSize?: number
        orderBy?: {
            field: "id" | "code" | "name" | "latitude" | "longitude" | "radius" | "slug" | "allowsBoarding" | "allowsAlighting" | "active" | "cityId" | "populationId" | "installationId" | "createdAt" | "updatedAt"
            direction: "asc" | "desc"
        }[]
        searchTerm?: string
    }

    export interface PaginatedListNodesResult {
        pagination: shared.PaginationMeta
        data: NodeWithRelations[]
    }
}

export namespace pathways {
    export interface CreatePathwayPayload {
        /**
         * Name of the pathway
         * Must have at least 1 character
         */
        name: string

        /**
         * Distance of the pathway
         * Must be a positive number
         */
        distance: number

        /**
         * Typical time to travel the pathway
         * Must be a positive number
         */
        typicalTime: number

        /**
         * Metadata about the pathway
         */
        meta: { [key: string]: string | number | boolean | null }

        /**
         * Whether the pathway is a toll road
         */
        tollRoad: boolean

        /**
         * Whether the pathway is active
         */
        active: boolean
    }

    export interface PaginatedPathways {
        pagination: shared.PaginationMeta
        data: Pathway[]
    }

    export interface Pathway {
        /**
         * Unique identifier for the pathway
         */
        id: number

        /**
         * Name of the pathway
         */
        name: string

        /**
         * Distance of the pathway
         */
        distance: number

        /**
         * Typical time to travel the pathway
         */
        typicalTime: number

        /**
         * Metadata about the pathway
         */
        meta: { [key: string]: any }

        /**
         * Whether the pathway is a toll road
         */
        tollRoad: boolean

        /**
         * Whether the pathway is active
         */
        active: boolean

        /**
         * Timestamp when the pathway was created
         */
        createdAt: string | string | null

        /**
         * Timestamp when the pathway was last updated
         */
        updatedAt: string | string | null
    }

    export interface Pathways {
        pathways: Pathway[]
    }
}

export namespace permission_groups {
    export interface CreatePermissionGroupPayload {
        /**
         * Name of the permission group
         * Must have at least 1 non-whitespace character
         */
        name: string

        /**
         * Optional description for the permission group
         */
        description?: string | null

        /**
         * Optional array of permission IDs to associate with the group
         */
        permissionIds?: number[]
    }

    export interface PermissionGroup {
        /**
         * Unique identifier for the permission group
         */
        id: number

        /**
         * Name of the permission group
         */
        name: string

        /**
         * Optional description for the permission group
         */
        description?: string | null

        /**
         * Timestamp when the permission group record was created
         */
        createdAt: string | string | null

        /**
         * Timestamp when the permission group record was last updated
         */
        updatedAt: string | string | null

        /**
         * Array of permissions associated with this group (optional for flexibility)
         */
        permissions?: permissions.Permission[]
    }

    export interface PermissionGroups {
        /**
         * List of permission groups with their associated permissions
         */
        permissionGroups: PermissionGroup[]
    }
}

export namespace permissions {
    export interface CreatePermissionPayload {
        /**
         * Unique code identifier for the permission (e.g., 'CREATE_USER')
         * Must be uppercase with underscores and at least 3 characters
         */
        code: string

        /**
         * Human-readable name of the permission
         * Must have at least 3 non-whitespace characters
         */
        name: string

        /**
         * Description of what the permission allows
         */
        description?: string

        /**
         * ID of the permission group this permission belongs to
         */
        permissionGroupId?: number | null
    }

    export interface PaginatedPermissions {
        pagination: shared.PaginationMeta
        data: Permission[]
    }

    export interface PaginationParamsPermissions {
        page?: number
        pageSize?: number
        orderBy?: {
            field: "id" | "code" | "name" | "description" | "permissionGroupId" | "createdAt" | "updatedAt"
            direction: "asc" | "desc"
        }[]
        filters?: {
            id?: number
            code?: string
            name?: string
            description?: string | null
            permissionGroupId?: number | null
            createdAt?: string | string | null
            updatedAt?: string | string | null
        }
    }

    export interface Permission {
        /**
         * Unique identifier for the permission
         */
        id: number

        /**
         * Unique code identifier for the permission (e.g., 'CREATE_USER')
         */
        code: string

        /**
         * Human-readable name of the permission
         */
        name: string

        /**
         * Description of what the permission allows
         */
        description: string | null

        /**
         * ID of the permission group this permission belongs to (nullable when un-assigned)
         */
        permissionGroupId: number | null

        /**
         * Timestamp when the permission was created
         */
        createdAt: string | string | null

        /**
         * Timestamp when the permission was last updated
         */
        updatedAt: string | string | null
    }

    export interface Permissions {
        /**
         * List of permissions
         */
        permissions: Permission[]
    }

    export interface PermissionsQueryOptions {
        orderBy?: {
            field: "id" | "code" | "name" | "description" | "permissionGroupId" | "createdAt" | "updatedAt"
            direction: "asc" | "desc"
        }[]
        filters?: {
            id?: number
            code?: string
            name?: string
            description?: string | null
            permissionGroupId?: number | null
            createdAt?: string | string | null
            updatedAt?: string | string | null
        }
    }
}

export namespace populations {
    export interface CreatePopulationPayload {
        /**
         * Unique code for the population
         * Must have at least 1 non-whitespace character
         */
        code: string

        /**
         * Name of the population
         * Must have at least 1 non-whitespace character
         */
        name: string

        /**
         * Description of the population
         */
        description?: string

        /**
         * Whether the population is active
         * @default true
         */
        active?: boolean
    }

    export interface FindPopulationByAssignedCityResult {
        data?: PopulationWithRelations
    }

    export interface ListAvailableCitiesResult {
        data: cities.CityWithStateAndCountry[]
    }

    export interface ListPopulationsQueryParams {
        orderBy?: {
            field: "id" | "code" | "name" | "description" | "active" | "createdAt" | "updatedAt"
            direction: "asc" | "desc"
        }[]
        filters?: {
            id?: number
            code?: string
            name?: string
            description?: string | null
            active?: boolean
            createdAt?: string | string | null
            updatedAt?: string | string | null
        }
        searchTerm?: string
    }

    export interface ListPopulationsResult {
        data: Population[]
    }

    export interface PaginatedListPopulationsQueryParams {
        page?: number
        pageSize?: number
        orderBy?: {
            field: "id" | "code" | "name" | "description" | "active" | "createdAt" | "updatedAt"
            direction: "asc" | "desc"
        }[]
        filters?: {
            id?: number
            code?: string
            name?: string
            description?: string | null
            active?: boolean
            createdAt?: string | string | null
            updatedAt?: string | string | null
        }
        searchTerm?: string
    }

    export interface PaginatedListPopulationsResult {
        pagination: shared.PaginationMeta
        data: PopulationWithRelations[]
    }

    export interface Population {
        /**
         * Unique identifier for the population
         */
        id: number

        /**
         * Unique code for the population
         */
        code: string

        /**
         * Name of the population
         */
        name: string

        /**
         * Description of the population
         */
        description: string | null

        /**
         * Whether the population is currently active in the system
         */
        active: boolean

        /**
         * Timestamp when the population record was created
         */
        createdAt: string | string | null

        /**
         * Timestamp when the population record was last updated
         */
        updatedAt: string | string | null
    }

    export interface PopulationWithRelations {
        /**
         * Array of cities assigned to this population
         */
        cities: cities.City[]

        /**
         * Unique identifier for the population
         */
        id: number

        /**
         * Unique code for the population
         */
        code: string

        /**
         * Name of the population
         */
        name: string

        /**
         * Description of the population
         */
        description: string | null

        /**
         * Whether the population is currently active in the system
         */
        active: boolean

        /**
         * Timestamp when the population record was created
         */
        createdAt: string | string | null

        /**
         * Timestamp when the population record was last updated
         */
        updatedAt: string | string | null
    }
}

export namespace roles {
    export interface CreateRolePayload {
        /**
         * Human-readable name of the role
         * Must have at least 3 non-whitespace characters
         */
        name: string

        /**
         * Description of what the role represents
         */
        description?: string

        /**
         * ID of the tenant this role belongs to
         */
        tenantId: number

        /**
         * IDs of permissions to associate with this role
         */
        permissionIds?: number[]
    }

    export interface PaginatedRoles {
        pagination: shared.PaginationMeta
        data: Role[]
    }

    export interface PaginatedRolesWithPermissions {
        pagination: shared.PaginationMeta
        data: RoleWithPermissions[]
    }

    export interface PaginationParamsRoles {
        page?: number
        pageSize?: number
        orderBy?: {
            field: "id" | "name" | "description" | "tenantId" | "createdAt" | "updatedAt"
            direction: "asc" | "desc"
        }[]
        filters?: {
            id?: number
            name?: string
            description?: string | null
            tenantId?: number
            createdAt?: string | string | null
            updatedAt?: string | string | null
        }
        includePermissions?: boolean
    }

    export interface PaginationParamsRoles {
        page?: number
        pageSize?: number
        orderBy?: {
            field: "id" | "name" | "description" | "tenantId" | "createdAt" | "updatedAt"
            direction: "asc" | "desc"
        }[]
        filters?: {
            id?: number
            name?: string
            description?: string | null
            tenantId?: number
            createdAt?: string | string | null
            updatedAt?: string | string | null
        }
        includePermissions?: boolean
    }

    export interface Role {
        /**
         * Unique identifier for the role
         */
        id: number

        /**
         * Human-readable name of the role
         */
        name: string

        /**
         * Description of what the role represents
         */
        description: string | null

        /**
         * ID of the tenant this role belongs to
         */
        tenantId: number

        /**
         * Timestamp when the role was created
         */
        createdAt: string | string | null

        /**
         * Timestamp when the role was last updated
         */
        updatedAt: string | string | null
    }

    export interface RoleWithPermissions {
        /**
         * Permissions associated with this role
         */
        permissions: permissions.Permission[]

        /**
         * Unique identifier for the role
         */
        id: number

        /**
         * Human-readable name of the role
         */
        name: string

        /**
         * Description of what the role represents
         */
        description: string | null

        /**
         * ID of the tenant this role belongs to
         */
        tenantId: number

        /**
         * Timestamp when the role was created
         */
        createdAt: string | string | null

        /**
         * Timestamp when the role was last updated
         */
        updatedAt: string | string | null
    }

    export interface Roles {
        /**
         * List of roles
         */
        roles: Role[]
    }

    export interface RolesQueryOptions {
        orderBy?: {
            field: "id" | "name" | "description" | "tenantId" | "createdAt" | "updatedAt"
            direction: "asc" | "desc"
        }[]
        filters?: {
            id?: number
            name?: string
            description?: string | null
            tenantId?: number
            createdAt?: string | string | null
            updatedAt?: string | string | null
        }
        includePermissions?: boolean
    }

    export interface RolesWithPermissions {
        /**
         * List of roles with their permissions
         */
        roles: RoleWithPermissions[]
    }
}

export namespace route_segment {
    export interface RouteSegment {
        /**
         * Unique identifier for the route segment
         */
        id: number

        /**
         * Reference to the parent route
         */
        parentRouteId: number

        /**
         * Reference to the segment route
         */
        segmentRouteId: number

        /**
         * Sequence order of this segment within the parent route
         */
        sequence: number

        /**
         * Whether this route segment is active
         */
        active: boolean
    }
}

export namespace routes {
    export interface CreateSimpleRoutePayload {
        /**
         * Whether this is a compound route
         */
        isCompound: false

        name: string
        description?: string
        originCityId: number
        destinationCityId: number
        baseTime: number
        connectionCount?: number
        distance: number
        typicalTime: number
        meta: { [key: string]: string | number | boolean | null }
        tollRoad: boolean
        active: boolean
        /**
         * Custom name for the pathway (defaults to route name if not provided)
         */
        pathwayName?: string
    }

    export interface PaginatedRoutes {
        pagination: shared.PaginationMeta
        data: Route[]
    }

    export interface PaginationParamsRoutes {
        page?: number
        pageSize?: number
        orderBy?: {
            field: "id" | "name" | "description" | "originCityId" | "destinationCityId" | "pathwayId" | "distance" | "baseTime" | "isCompound" | "connectionCount" | "totalTravelTime" | "totalDistance" | "createdAt" | "updatedAt"
            direction: "asc" | "desc"
        }[]
        filters?: {
            id?: number
            name?: string
            description?: string | null
            originCityId?: number
            destinationCityId?: number
            pathwayId?: number | null
            distance?: number
            baseTime?: number
            isCompound?: boolean
            connectionCount?: number
            totalTravelTime?: number
            totalDistance?: number
            createdAt?: string | string | null
            updatedAt?: string | string | null
        }
    }

    export interface Route {
        /**
         * Unique identifier for the route
         */
        id: number

        /**
         * Name of the route
         */
        name: string

        /**
         * Description of the route (optional)
         */
        description: string | null

        /**
         * Reference to the origin city
         */
        originCityId: number

        /**
         * Reference to the destination city
         */
        destinationCityId: number

        /**
         * Reference to the pathway used by this route
         */
        pathwayId: number | null

        /**
         * Total distance of the route in kilometers
         */
        distance: number

        /**
         * Base travel time in minutes without any stops/services
         */
        baseTime: number

        /**
         * Whether this is a compound route (has connections)
         */
        isCompound: boolean

        /**
         * Number of connections in this route
         */
        connectionCount: number

        /**
         * Total travel time including all stops/services in minutes
         */
        totalTravelTime: number

        /**
         * Total distance including any detours for services in kilometers
         */
        totalDistance: number

        /**
         * Timestamp when the route was created
         */
        createdAt: string | string | null

        /**
         * Timestamp when the route was last updated
         */
        updatedAt: string | string | null
    }

    export interface RouteWithFullDetails {
        originCity: cities.City
        destinationCity: cities.City
        pathway: {
            id: number
            name: string
            distance: number
            typicalTime: number
            tollRoad: boolean
            active: boolean
            createdAt: string | string | null
            updatedAt: string | string | null
        } | null
        routeSegments: route_segment.RouteSegment[]
        /**
         * Unique identifier for the route
         */
        id: number

        /**
         * Name of the route
         */
        name: string

        /**
         * Description of the route (optional)
         */
        description: string | null

        /**
         * Reference to the origin city
         */
        originCityId: number

        /**
         * Reference to the destination city
         */
        destinationCityId: number

        /**
         * Reference to the pathway used by this route
         */
        pathwayId: number | null

        /**
         * Total distance of the route in kilometers
         */
        distance: number

        /**
         * Base travel time in minutes without any stops/services
         */
        baseTime: number

        /**
         * Whether this is a compound route (has connections)
         */
        isCompound: boolean

        /**
         * Number of connections in this route
         */
        connectionCount: number

        /**
         * Total travel time including all stops/services in minutes
         */
        totalTravelTime: number

        /**
         * Total distance including any detours for services in kilometers
         */
        totalDistance: number

        /**
         * Timestamp when the route was created
         */
        createdAt: string | string | null

        /**
         * Timestamp when the route was last updated
         */
        updatedAt: string | string | null
    }

    export interface Routes {
        routes: Route[]
    }

    export interface RoutesQueryOptions {
        orderBy?: {
            field: "id" | "name" | "description" | "originCityId" | "destinationCityId" | "pathwayId" | "distance" | "baseTime" | "isCompound" | "connectionCount" | "totalTravelTime" | "totalDistance" | "createdAt" | "updatedAt"
            direction: "asc" | "desc"
        }[]
        filters?: {
            id?: number
            name?: string
            description?: string | null
            originCityId?: number
            destinationCityId?: number
            pathwayId?: number | null
            distance?: number
            baseTime?: number
            isCompound?: boolean
            connectionCount?: number
            totalTravelTime?: number
            totalDistance?: number
            createdAt?: string | string | null
            updatedAt?: string | string | null
        }
    }
}

export namespace seat_diagram_zones {
    export interface PaginatedSeatDiagramZones {
        pagination: shared.PaginationMeta
        data: SeatDiagramZone[]
    }

    export interface SeatDiagramZone {
        /**
         * Unique identifier for the zone
         */
        id: number

        /**
         * Reference to the seat diagram
         */
        seatDiagramId: number

        /**
         * Name of the zone
         */
        name: string

        /**
         * Array of row numbers that belong to this zone
         */
        rowNumbers: number[]

        /**
         * Price multiplier for seats in this zone
         */
        priceMultiplier: number

        /**
         * Timestamp when the zone was created
         */
        createdAt: string | string | null

        /**
         * Timestamp when the zone was last updated
         */
        updatedAt: string | string | null
    }

    export interface SeatDiagramZones {
        /**
         * List of seat diagram zones
         */
        seatDiagramZones: SeatDiagramZone[]
    }
}

export namespace seat_diagrams {
    export interface SeatDiagram {
        /**
         * Unique identifier for the seat diagram
         */
        id: number

        /**
         * Bus diagram model ID (reference to bus_diagram_models)
         */
        busDiagramModelId: number

        /**
         * Name of the seat diagram
         */
        name: string

        /**
         * Description of the seat diagram
         */
        description: string | null

        /**
         * Maximum capacity
         */
        maxCapacity: number

        /**
         * Number of floors in the seat diagram
         */
        numFloors: number

        /**
         * Configuration of seats per floor
         */
        seatsPerFloor: shared.FloorSeats[]

        /**
         * Total number of seats
         */
        totalSeats: number

        /**
         * Indicates if this is a factory default diagram
         */
        isFactoryDefault: boolean

        /**
         * Indicates if the diagram has been modified from its template
         */
        isModified: boolean

        /**
         * Whether the seat diagram is active
         */
        active: boolean

        /**
         * Timestamp when the seat diagram was created
         */
        createdAt: string | string | null

        /**
         * Timestamp when the seat diagram was last updated
         */
        updatedAt: string | string | null
    }
}

export namespace service_types {
    export interface CreateServiceTypePayload {
        /**
         * Name of the service type
         * Must have at least 1 non-whitespace character
         */
        name: string

        /**
         * Unique business code for the service type
         * Must have at least 1 non-whitespace character
         */
        code: string

        /**
         * Category for the service type
         * Must be one of the allowed categories
         */
        category: ServiceTypeCategory

        /**
         * Description of the service type (optional)
         */
        description?: string

        /**
         * Whether the service type is active
         * @default true
         */
        active?: boolean
    }

    export interface ListServiceTypesQueryParams {
        orderBy?: {
            field: "id" | "name" | "code" | "category" | "description" | "active" | "createdAt" | "updatedAt"
            direction: "asc" | "desc"
        }[]
        filters?: {
            id?: number
            name?: string
            code?: string
            category?: ServiceTypeCategory
            description?: string | null
            active?: boolean
            createdAt?: string | string | null
            updatedAt?: string | string | null
        }
        searchTerm?: string
    }

    export interface ListServiceTypesResult {
        data: ServiceType[]
    }

    export interface PaginatedListServiceTypesQueryParams {
        page?: number
        pageSize?: number
        orderBy?: {
            field: "id" | "name" | "code" | "category" | "description" | "active" | "createdAt" | "updatedAt"
            direction: "asc" | "desc"
        }[]
        filters?: {
            id?: number
            name?: string
            code?: string
            category?: ServiceTypeCategory
            description?: string | null
            active?: boolean
            createdAt?: string | string | null
            updatedAt?: string | string | null
        }
        searchTerm?: string
    }

    export interface PaginatedListServiceTypesResult {
        pagination: shared.PaginationMeta
        data: ServiceType[]
    }

    export interface ServiceType {
        /**
         * Unique identifier for the service type
         */
        id: number

        /**
         * Name of the service type
         */
        name: string

        /**
         * Unique code for the service type
         */
        code: string

        /**
         * Category this service type belongs to
         */
        category: ServiceTypeCategory

        /**
         * Description of what this service type represents
         */
        description: string | null

        /**
         * Whether this service type is currently active
         */
        active: boolean

        /**
         * Timestamp when this service type was created
         */
        createdAt: string | string | null

        /**
         * Timestamp when this service type was last updated
         */
        updatedAt: string | string | null
    }

    export type ServiceTypeCategory = "regular" | "express" | "luxury" | "economic"

    export interface ServiceTypeWithAmenities {
        /**
         * Amenities assigned to this service type
         */
        amenities: amenities.Amenity[]

        /**
         * Unique identifier for the service type
         */
        id: number

        /**
         * Name of the service type
         */
        name: string

        /**
         * Unique code for the service type
         */
        code: string

        /**
         * Category this service type belongs to
         */
        category: ServiceTypeCategory

        /**
         * Description of what this service type represents
         */
        description: string | null

        /**
         * Whether this service type is currently active
         */
        active: boolean

        /**
         * Timestamp when this service type was created
         */
        createdAt: string | string | null

        /**
         * Timestamp when this service type was last updated
         */
        updatedAt: string | string | null
    }
}

export namespace shared {
    export interface FloorSeats {
        /**
         * Floor number
         */
        floorNumber: number

        /**
         * Number of rows in this floor
         */
        numRows: number

        /**
         * Number of seats on the left side per row for this floor
         */
        seatsLeft: number

        /**
         * Number of seats on the right side per row for this floor
         */
        seatsRight: number
    }

    export interface PaginationMeta {
        /**
         * Current page number (1-based)
         */
        currentPage: number

        /**
         * Number of items per page
         */
        pageSize: number

        /**
         * Total number of items across all pages
         */
        totalCount: number

        /**
         * Total number of pages
         */
        totalPages: number

        /**
         * Whether there is a next page available
         */
        hasNextPage: boolean

        /**
         * Whether there is a previous page available
         */
        hasPreviousPage: boolean
    }

    export interface PaginationParams {
        page?: number
        pageSize?: number
    }

    export interface PaginationParams {
        page?: number
        pageSize?: number
    }

    export interface SeatPosition {
        x: number
        y: number
    }

    export type SeatType = "regular" | "premium" | "vip" | "business" | "executive"

    export type SpaceType = "seat" | "hallway" | "bathroom" | "empty" | "stairs"
}

export namespace states {
    export interface CreateStatePayload {
        /**
         * Name of the state
         * Must have at least 1 non-whitespace character
         */
        name: string

        /**
         * State code (e.g., "TX", "CA", "NY")
         * Must have at least 1 non-whitespace character
         */
        code: string

        /**
         * ID of the country this state belongs to
         * Must be a positive number
         */
        countryId: number

        /**
         * Whether the state is active
         * @default true
         */
        active?: boolean
    }

    export interface ListStatesQueryParams {
        orderBy?: {
            field: "id" | "name" | "code" | "countryId" | "active" | "createdAt" | "updatedAt"
            direction: "asc" | "desc"
        }[]
        filters?: {
            id?: number
            name?: string
            code?: string
            countryId?: number
            active?: boolean
            createdAt?: string | string | null
            updatedAt?: string | string | null
        }
        searchTerm?: string
    }

    export interface ListStatesResult {
        data: State[]
    }

    export interface PaginatedListStatesQueryParams {
        page?: number
        pageSize?: number
        orderBy?: {
            field: "id" | "name" | "code" | "countryId" | "active" | "createdAt" | "updatedAt"
            direction: "asc" | "desc"
        }[]
        filters?: {
            id?: number
            name?: string
            code?: string
            countryId?: number
            active?: boolean
            createdAt?: string | string | null
            updatedAt?: string | string | null
        }
        searchTerm?: string
    }

    export interface PaginatedListStatesResult {
        pagination: shared.PaginationMeta
        data: State[]
    }

    export interface State {
        /**
         * Unique identifier for the state
         */
        id: number

        /**
         * Name of the state
         */
        name: string

        /**
         * State code (e.g., "TX", "CA", "NY")
         */
        code: string

        /**
         * ID of the country this state belongs to
         */
        countryId: number

        /**
         * Whether the state is currently active in the system
         */
        active: boolean

        /**
         * Timestamp when the state record was created
         */
        createdAt: string | string | null

        /**
         * Timestamp when the state record was last updated
         */
        updatedAt: string | string | null
    }
}

export namespace tenants {
    export interface CreateTenantPayload {
        /**
         * Name of the tenant
         * @minLength 2
         */
        name: string

        /**
         * Unique code for the tenant (alphanumeric with no spaces)
         * @minLength 2
         * @pattern ^[a-zA-Z0-9-]+$
         */
        code: string

        /**
         * Optional description of the tenant
         */
        description?: string
    }

    export interface PaginatedTenants {
        pagination: shared.PaginationMeta
        data: Tenant[]
    }

    export interface PaginationParamsTenants {
        page?: number
        pageSize?: number
        orderBy?: {
            field: "id" | "name" | "code" | "description" | "isActive" | "createdAt" | "updatedAt"
            direction: "asc" | "desc"
        }[]
        filters?: {
            id?: number
            name?: string
            code?: string
            description?: string | null
            isActive?: boolean
            createdAt?: string | string | null
            updatedAt?: string | string | null
        }
    }

    export interface Tenant {
        id: number
        name: string
        code: string
        description?: string | null
        isActive: boolean
        createdAt: string | string | null
        updatedAt: string | string | null
    }

    export interface Tenants {
        tenants: Tenant[]
    }

    export interface TenantsQueryOptions {
        orderBy?: {
            field: "id" | "name" | "code" | "description" | "isActive" | "createdAt" | "updatedAt"
            direction: "asc" | "desc"
        }[]
        filters?: {
            id?: number
            name?: string
            code?: string
            description?: string | null
            isActive?: boolean
            createdAt?: string | string | null
            updatedAt?: string | string | null
        }
    }
}

export namespace timezones {
    export interface Timezone {
        /**
         * Unique identifier for the timezone
         */
        id: string
    }

    export interface Timezones {
        /**
         * List of timezones
         */
        timezones: Timezone[]
    }
}

export namespace transporters {
    export interface CreateTransporterPayload {
        /**
         * The name of the transportation company
         * Must have at least 1 non-whitespace character
         */
        name: string

        /**
         * Unique business code for the transporter (1-10 characters)
         * Must contain only uppercase letters, numbers, and hyphens
         */
        code: string

        /**
         * Description of the transporter
         */
        description?: string | null

        /**
         * Legal name (Razn Social) of the company
         */
        legalName?: string | null

        /**
         * Physical address of the headquarter/company
         */
        address?: string | null

        /**
         * Website URL of the transporter
         */
        website?: string | null

        /**
         * Contact email of the transporter
         */
        email?: string | null

        /**
         * Contact phone number of the transporter
         */
        phone?: string | null

        /**
         * ID of the city where the transporter is headquartered
         * Must be a positive number
         */
        headquarterCityId?: number | null

        /**
         * URL to the transporter's logo
         */
        logoUrl?: string | null

        /**
         * Additional contact information
         */
        contactInfo?: string | null

        /**
         * Regulatory license number
         */
        licenseNumber?: string | null

        /**
         * Whether the transporter is active
         * @default true
         */
        active?: boolean
    }

    export interface ListTransportersQueryParams {
        orderBy?: {
            field: "id" | "name" | "code" | "legalName" | "address" | "description" | "website" | "email" | "phone" | "headquarterCityId" | "logoUrl" | "contactInfo" | "licenseNumber" | "active" | "createdAt" | "updatedAt"
            direction: "asc" | "desc"
        }[]
        filters?: {
            id?: number
            name?: string
            code?: string
            legalName?: string | null
            address?: string | null
            description?: string | null
            website?: string | null
            email?: string | null
            phone?: string | null
            headquarterCityId?: number | null
            logoUrl?: string | null
            contactInfo?: string | null
            licenseNumber?: string | null
            active?: boolean
            createdAt?: string | string | null
            updatedAt?: string | string | null
        }
        searchTerm?: string
    }

    export interface ListTransportersResult {
        data: TransporterWithCity[]
    }

    export interface PaginatedListTransportersQueryParams {
        page?: number
        pageSize?: number
        orderBy?: {
            field: "id" | "name" | "code" | "legalName" | "address" | "description" | "website" | "email" | "phone" | "headquarterCityId" | "logoUrl" | "contactInfo" | "licenseNumber" | "active" | "createdAt" | "updatedAt"
            direction: "asc" | "desc"
        }[]
        filters?: {
            id?: number
            name?: string
            code?: string
            legalName?: string | null
            address?: string | null
            description?: string | null
            website?: string | null
            email?: string | null
            phone?: string | null
            headquarterCityId?: number | null
            logoUrl?: string | null
            contactInfo?: string | null
            licenseNumber?: string | null
            active?: boolean
            createdAt?: string | string | null
            updatedAt?: string | string | null
        }
        searchTerm?: string
    }

    export interface PaginatedListTransportersResult {
        pagination: shared.PaginationMeta
        data: TransporterWithCity[]
    }

    export interface Transporter {
        /**
         * Unique identifier for the transporter
         */
        id: number

        /**
         * Name of the transportation company
         */
        name: string

        /**
         * Unique business code for the transporter
         */
        code: string

        /**
         * Legal name (Razn Social) of the company
         */
        legalName: string | null

        /**
         * Physical address of the headquarter/company
         */
        address: string | null

        /**
         * Description of the transporter
         */
        description: string | null

        /**
         * Website URL of the transporter
         */
        website: string | null

        /**
         * Contact email of the transporter
         */
        email: string | null

        /**
         * Contact phone number of the transporter
         */
        phone: string | null

        /**
         * ID of the city where the transporter is headquartered
         */
        headquarterCityId: number | null

        /**
         * URL to the transporter's logo
         */
        logoUrl: string | null

        /**
         * Additional contact information
         */
        contactInfo: string | null

        /**
         * Regulatory license number
         */
        licenseNumber: string | null

        /**
         * Whether the transporter is currently active in the system
         */
        active: boolean

        /**
         * Timestamp when the transporter record was created
         */
        createdAt: string | string | null

        /**
         * Timestamp when the transporter record was last updated
         */
        updatedAt: string | string | null
    }

    export interface TransporterWithCity {
        headquarterCity: cities.City | null
        /**
         * Unique identifier for the transporter
         */
        id: number

        /**
         * Name of the transportation company
         */
        name: string

        /**
         * Unique business code for the transporter
         */
        code: string

        /**
         * Legal name (Razn Social) of the company
         */
        legalName: string | null

        /**
         * Physical address of the headquarter/company
         */
        address: string | null

        /**
         * Description of the transporter
         */
        description: string | null

        /**
         * Website URL of the transporter
         */
        website: string | null

        /**
         * Contact email of the transporter
         */
        email: string | null

        /**
         * Contact phone number of the transporter
         */
        phone: string | null

        /**
         * ID of the city where the transporter is headquartered
         */
        headquarterCityId: number | null

        /**
         * URL to the transporter's logo
         */
        logoUrl: string | null

        /**
         * Additional contact information
         */
        contactInfo: string | null

        /**
         * Regulatory license number
         */
        licenseNumber: string | null

        /**
         * Whether the transporter is currently active in the system
         */
        active: boolean

        /**
         * Timestamp when the transporter record was created
         */
        createdAt: string | string | null

        /**
         * Timestamp when the transporter record was last updated
         */
        updatedAt: string | string | null
    }
}

export namespace user_permissions {
    export interface UserWithPermissions {
        /**
         * Directly assigned permissions
         */
        directPermissions: permissions.Permission[]

        /**
         * Roles assigned to this user, including their permissions
         */
        roles: roles.RoleWithPermissions[]

        /**
         * Permissions that came from roles only
         */
        rolesPermissions: permissions.Permission[]

        /**
         * All effective permissions (combined from direct assignments and roles)
         */
        effectivePermissions: permissions.Permission[]

        id: number
        tenantId: number
        departmentId: number
        username: string
        email: string
        firstName: string
        lastName: string
        phone: string | null
        position: string | null
        employeeId: string | null
        mfaSettings: { [key: string]: any } | null
        lastLogin: string | string | null
        isActive: boolean
        isSystemAdmin: boolean
        createdAt: string | string | null
        updatedAt: string | string | null
    }

    export interface UserWithRoles {
        /**
         * Roles assigned to this user
         */
        roles: roles.Role[]

        id: number
        tenantId: number
        departmentId: number
        username: string
        email: string
        firstName: string
        lastName: string
        phone: string | null
        position: string | null
        employeeId: string | null
        mfaSettings: { [key: string]: any } | null
        lastLogin: string | string | null
        isActive: boolean
        isSystemAdmin: boolean
        createdAt: string | string | null
        updatedAt: string | string | null
    }
}



function encodeQuery(parts: Record<string, string | string[]>): string {
    const pairs: string[] = []
    for (const key in parts) {
        const val = (Array.isArray(parts[key]) ?  parts[key] : [parts[key]]) as string[]
        for (const v of val) {
            pairs.push(`${key}=${encodeURIComponent(v)}`)
        }
    }
    return pairs.join("&")
}

// makeRecord takes a record and strips any undefined values from it,
// and returns the same record with a narrower type.
// @ts-ignore - TS ignore because makeRecord is not always used
function makeRecord<K extends string | number | symbol, V>(record: Record<K, V | undefined>): Record<K, V> {
    for (const key in record) {
        if (record[key] === undefined) {
            delete record[key]
        }
    }
    return record as Record<K, V>
}

function encodeWebSocketHeaders(headers: Record<string, string>) {
    // url safe, no pad
    const base64encoded = btoa(JSON.stringify(headers))
      .replaceAll("=", "")
      .replaceAll("+", "-")
      .replaceAll("/", "_");
    return "encore.dev.headers." + base64encoded;
}

class WebSocketConnection {
    public ws: WebSocket;

    private hasUpdateHandlers: (() => void)[] = [];

    constructor(url: string, headers?: Record<string, string>) {
        let protocols = ["encore-ws"];
        if (headers) {
            protocols.push(encodeWebSocketHeaders(headers))
        }

        this.ws = new WebSocket(url, protocols)

        this.on("error", () => {
            this.resolveHasUpdateHandlers();
        });

        this.on("close", () => {
            this.resolveHasUpdateHandlers();
        });
    }

    resolveHasUpdateHandlers() {
        const handlers = this.hasUpdateHandlers;
        this.hasUpdateHandlers = [];

        for (const handler of handlers) {
            handler()
        }
    }

    async hasUpdate() {
        // await until a new message have been received, or the socket is closed
        await new Promise((resolve) => {
            this.hasUpdateHandlers.push(() => resolve(null))
        });
    }

    on(type: "error" | "close" | "message" | "open", handler: (event: any) => void) {
        this.ws.addEventListener(type, handler);
    }

    off(type: "error" | "close" | "message" | "open", handler: (event: any) => void) {
        this.ws.removeEventListener(type, handler);
    }

    close() {
        this.ws.close();
    }
}

export class StreamInOut<Request, Response> {
    public socket: WebSocketConnection;
    private buffer: Response[] = [];

    constructor(url: string, headers?: Record<string, string>) {
        this.socket = new WebSocketConnection(url, headers);
        this.socket.on("message", (event: any) => {
            this.buffer.push(JSON.parse(event.data));
            this.socket.resolveHasUpdateHandlers();
        });
    }

    close() {
        this.socket.close();
    }

    async send(msg: Request) {
        if (this.socket.ws.readyState === WebSocket.CONNECTING) {
            // await that the socket is opened
            await new Promise((resolve) => {
                this.socket.ws.addEventListener("open", resolve, { once: true });
            });
        }

        return this.socket.ws.send(JSON.stringify(msg));
    }

    async next(): Promise<Response | undefined> {
        for await (const next of this) return next;
        return undefined;
    }

    async *[Symbol.asyncIterator](): AsyncGenerator<Response, undefined, void> {
        while (true) {
            if (this.buffer.length > 0) {
                yield this.buffer.shift() as Response;
            } else {
                if (this.socket.ws.readyState === WebSocket.CLOSED) return;
                await this.socket.hasUpdate();
            }
        }
    }
}

export class StreamIn<Response> {
    public socket: WebSocketConnection;
    private buffer: Response[] = [];

    constructor(url: string, headers?: Record<string, string>) {
        this.socket = new WebSocketConnection(url, headers);
        this.socket.on("message", (event: any) => {
            this.buffer.push(JSON.parse(event.data));
            this.socket.resolveHasUpdateHandlers();
        });
    }

    close() {
        this.socket.close();
    }

    async next(): Promise<Response | undefined> {
        for await (const next of this) return next;
        return undefined;
    }

    async *[Symbol.asyncIterator](): AsyncGenerator<Response, undefined, void> {
        while (true) {
            if (this.buffer.length > 0) {
                yield this.buffer.shift() as Response;
            } else {
                if (this.socket.ws.readyState === WebSocket.CLOSED) return;
                await this.socket.hasUpdate();
            }
        }
    }
}

export class StreamOut<Request, Response> {
    public socket: WebSocketConnection;
    private responseValue: Promise<Response>;

    constructor(url: string, headers?: Record<string, string>) {
        let responseResolver: (_: any) => void;
        this.responseValue = new Promise((resolve) => responseResolver = resolve);

        this.socket = new WebSocketConnection(url, headers);
        this.socket.on("message", (event: any) => {
            responseResolver(JSON.parse(event.data))
        });
    }

    async response(): Promise<Response> {
        return this.responseValue;
    }

    close() {
        this.socket.close();
    }

    async send(msg: Request) {
        if (this.socket.ws.readyState === WebSocket.CONNECTING) {
            // await that the socket is opened
            await new Promise((resolve) => {
                this.socket.ws.addEventListener("open", resolve, { once: true });
            });
        }

        return this.socket.ws.send(JSON.stringify(msg));
    }
}
// CallParameters is the type of the parameters to a method call, but require headers to be a Record type
type CallParameters = Omit<RequestInit, "method" | "body" | "headers"> & {
    /** Headers to be sent with the request */
    headers?: Record<string, string>

    /** Query parameters to be sent with the request */
    query?: Record<string, string | string[]>
}

// AuthDataGenerator is a function that returns a new instance of the authentication data required by this API
export type AuthDataGenerator = () =>
  | users.AuthParams
  | Promise<users.AuthParams | undefined>
  | undefined;

// A fetcher is the prototype for the inbuilt Fetch function
export type Fetcher = typeof fetch;

const boundFetch = fetch.bind(this);

class BaseClient {
    readonly baseURL: string
    readonly fetcher: Fetcher
    readonly headers: Record<string, string>
    readonly requestInit: Omit<RequestInit, "headers"> & { headers?: Record<string, string> }
    readonly authGenerator?: AuthDataGenerator

    constructor(baseURL: string, options: ClientOptions) {
        this.baseURL = baseURL
        this.headers = {}

        // Add User-Agent header if the script is running in the server
        // because browsers do not allow setting User-Agent headers to requests
        if (!BROWSER) {
            this.headers["User-Agent"] = "server-nest-8sci-Generated-TS-Client (Encore/v1.48.9)";
        }

        this.requestInit = options.requestInit ?? {};

        // Setup what fetch function we'll be using in the base client
        if (options.fetcher !== undefined) {
            this.fetcher = options.fetcher
        } else {
            this.fetcher = boundFetch
        }

        // Setup an authentication data generator using the auth data token option
        if (options.auth !== undefined) {
            const auth = options.auth
            if (typeof auth === "function") {
                this.authGenerator = auth
            } else {
                this.authGenerator = () => auth
            }
        }
    }

    async getAuthData(): Promise<CallParameters | undefined> {
        let authData: users.AuthParams | undefined;

        // If authorization data generator is present, call it and add the returned data to the request
        if (this.authGenerator) {
            const mayBePromise = this.authGenerator();
            if (mayBePromise instanceof Promise) {
                authData = await mayBePromise;
            } else {
                authData = mayBePromise;
            }
        }

        if (authData) {
            const data: CallParameters = {};

            data.headers = makeRecord<string, string>({
                authorization: authData.authorization,
            });

            return data;
        }

        return undefined;
    }

    // createStreamInOut sets up a stream to a streaming API endpoint.
    async createStreamInOut<Request, Response>(path: string, params?: CallParameters): Promise<StreamInOut<Request, Response>> {
        let { query, headers } = params ?? {};

        // Fetch auth data if there is any
        const authData = await this.getAuthData();

        // If we now have authentication data, add it to the request
        if (authData) {
            if (authData.query) {
                query = {...query, ...authData.query};
            }
            if (authData.headers) {
                headers = {...headers, ...authData.headers};
            }
        }

        const queryString = query ? '?' + encodeQuery(query) : ''
        return new StreamInOut(this.baseURL + path + queryString, headers);
    }

    // createStreamIn sets up a stream to a streaming API endpoint.
    async createStreamIn<Response>(path: string, params?: CallParameters): Promise<StreamIn<Response>> {
        let { query, headers } = params ?? {};

        // Fetch auth data if there is any
        const authData = await this.getAuthData();

        // If we now have authentication data, add it to the request
        if (authData) {
            if (authData.query) {
                query = {...query, ...authData.query};
            }
            if (authData.headers) {
                headers = {...headers, ...authData.headers};
            }
        }

        const queryString = query ? '?' + encodeQuery(query) : ''
        return new StreamIn(this.baseURL + path + queryString, headers);
    }

    // createStreamOut sets up a stream to a streaming API endpoint.
    async createStreamOut<Request, Response>(path: string, params?: CallParameters): Promise<StreamOut<Request, Response>> {
        let { query, headers } = params ?? {};

        // Fetch auth data if there is any
        const authData = await this.getAuthData();

        // If we now have authentication data, add it to the request
        if (authData) {
            if (authData.query) {
                query = {...query, ...authData.query};
            }
            if (authData.headers) {
                headers = {...headers, ...authData.headers};
            }
        }

        const queryString = query ? '?' + encodeQuery(query) : ''
        return new StreamOut(this.baseURL + path + queryString, headers);
    }

    // callTypedAPI makes an API call, defaulting content type to "application/json"
    public async callTypedAPI(method: string, path: string, body?: RequestInit["body"], params?: CallParameters): Promise<Response> {
        return this.callAPI(method, path, body, {
            ...params,
            headers: { "Content-Type": "application/json", ...params?.headers }
        });
    }

    // callAPI is used by each generated API method to actually make the request
    public async callAPI(method: string, path: string, body?: RequestInit["body"], params?: CallParameters): Promise<Response> {
        let { query, headers, ...rest } = params ?? {}
        const init = {
            ...this.requestInit,
            ...rest,
            method,
            body: body ?? null,
        }

        // Merge our headers with any predefined headers
        init.headers = {...this.headers, ...init.headers, ...headers}

        // Fetch auth data if there is any
        const authData = await this.getAuthData();

        // If we now have authentication data, add it to the request
        if (authData) {
            if (authData.query) {
                query = {...query, ...authData.query};
            }
            if (authData.headers) {
                init.headers = {...init.headers, ...authData.headers};
            }
        }

        // Make the actual request
        const queryString = query ? '?' + encodeQuery(query) : ''
        const response = await this.fetcher(this.baseURL+path+queryString, init)

        // handle any error responses
        if (!response.ok) {
            // try and get the error message from the response body
            let body: APIErrorResponse = { code: ErrCode.Unknown, message: `request failed: status ${response.status}` }

            // if we can get the structured error we should, otherwise give a best effort
            try {
                const text = await response.text()

                try {
                    const jsonBody = JSON.parse(text)
                    if (isAPIErrorResponse(jsonBody)) {
                        body = jsonBody
                    } else {
                        body.message += ": " + JSON.stringify(jsonBody)
                    }
                } catch {
                    body.message += ": " + text
                }
            } catch (e) {
                // otherwise we just append the text to the error message
                body.message += ": " + String(e)
            }

            throw new APIError(response.status, body)
        }

        return response
    }
}

/**
 * APIErrorDetails represents the response from an Encore API in the case of an error
 */
interface APIErrorResponse {
    code: ErrCode
    message: string
    details?: any
}

function isAPIErrorResponse(err: any): err is APIErrorResponse {
    return (
        err !== undefined && err !== null &&
        isErrCode(err.code) &&
        typeof(err.message) === "string" &&
        (err.details === undefined || err.details === null || typeof(err.details) === "object")
    )
}

function isErrCode(code: any): code is ErrCode {
    return code !== undefined && Object.values(ErrCode).includes(code)
}

/**
 * APIError represents a structured error as returned from an Encore application.
 */
export class APIError extends Error {
    /**
     * The HTTP status code associated with the error.
     */
    public readonly status: number

    /**
     * The Encore error code
     */
    public readonly code: ErrCode

    /**
     * The error details
     */
    public readonly details?: any

    constructor(status: number, response: APIErrorResponse) {
        // extending errors causes issues after you construct them, unless you apply the following fixes
        super(response.message);

        // set error name as constructor name, make it not enumerable to keep native Error behavior
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new.target#new.target_in_constructors
        Object.defineProperty(this, 'name', {
            value:        'APIError',
            enumerable:   false,
            configurable: true,
        })

        // fix the prototype chain
        if ((Object as any).setPrototypeOf == undefined) {
            (this as any).__proto__ = APIError.prototype
        } else {
            Object.setPrototypeOf(this, APIError.prototype);
        }

        // capture a stack trace
        if ((Error as any).captureStackTrace !== undefined) {
            (Error as any).captureStackTrace(this, this.constructor);
        }

        this.status = status
        this.code = response.code
        this.details = response.details
    }
}

/**
 * Typeguard allowing use of an APIError's fields'
 */
export function isAPIError(err: any): err is APIError {
    return err instanceof APIError;
}

export enum ErrCode {
    /**
     * OK indicates the operation was successful.
     */
    OK = "ok",

    /**
     * Canceled indicates the operation was canceled (typically by the caller).
     *
     * Encore will generate this error code when cancellation is requested.
     */
    Canceled = "canceled",

    /**
     * Unknown error. An example of where this error may be returned is
     * if a Status value received from another address space belongs to
     * an error-space that is not known in this address space. Also
     * errors raised by APIs that do not return enough error information
     * may be converted to this error.
     *
     * Encore will generate this error code in the above two mentioned cases.
     */
    Unknown = "unknown",

    /**
     * InvalidArgument indicates client specified an invalid argument.
     * Note that this differs from FailedPrecondition. It indicates arguments
     * that are problematic regardless of the state of the system
     * (e.g., a malformed file name).
     *
     * This error code will not be generated by the gRPC framework.
     */
    InvalidArgument = "invalid_argument",

    /**
     * DeadlineExceeded means operation expired before completion.
     * For operations that change the state of the system, this error may be
     * returned even if the operation has completed successfully. For
     * example, a successful response from a server could have been delayed
     * long enough for the deadline to expire.
     *
     * The gRPC framework will generate this error code when the deadline is
     * exceeded.
     */
    DeadlineExceeded = "deadline_exceeded",

    /**
     * NotFound means some requested entity (e.g., file or directory) was
     * not found.
     *
     * This error code will not be generated by the gRPC framework.
     */
    NotFound = "not_found",

    /**
     * AlreadyExists means an attempt to create an entity failed because one
     * already exists.
     *
     * This error code will not be generated by the gRPC framework.
     */
    AlreadyExists = "already_exists",

    /**
     * PermissionDenied indicates the caller does not have permission to
     * execute the specified operation. It must not be used for rejections
     * caused by exhausting some resource (use ResourceExhausted
     * instead for those errors). It must not be
     * used if the caller cannot be identified (use Unauthenticated
     * instead for those errors).
     *
     * This error code will not be generated by the gRPC core framework,
     * but expect authentication middleware to use it.
     */
    PermissionDenied = "permission_denied",

    /**
     * ResourceExhausted indicates some resource has been exhausted, perhaps
     * a per-user quota, or perhaps the entire file system is out of space.
     *
     * This error code will be generated by the gRPC framework in
     * out-of-memory and server overload situations, or when a message is
     * larger than the configured maximum size.
     */
    ResourceExhausted = "resource_exhausted",

    /**
     * FailedPrecondition indicates operation was rejected because the
     * system is not in a state required for the operation's execution.
     * For example, directory to be deleted may be non-empty, an rmdir
     * operation is applied to a non-directory, etc.
     *
     * A litmus test that may help a service implementor in deciding
     * between FailedPrecondition, Aborted, and Unavailable:
     *  (a) Use Unavailable if the client can retry just the failing call.
     *  (b) Use Aborted if the client should retry at a higher-level
     *      (e.g., restarting a read-modify-write sequence).
     *  (c) Use FailedPrecondition if the client should not retry until
     *      the system state has been explicitly fixed. E.g., if an "rmdir"
     *      fails because the directory is non-empty, FailedPrecondition
     *      should be returned since the client should not retry unless
     *      they have first fixed up the directory by deleting files from it.
     *  (d) Use FailedPrecondition if the client performs conditional
     *      REST Get/Update/Delete on a resource and the resource on the
     *      server does not match the condition. E.g., conflicting
     *      read-modify-write on the same resource.
     *
     * This error code will not be generated by the gRPC framework.
     */
    FailedPrecondition = "failed_precondition",

    /**
     * Aborted indicates the operation was aborted, typically due to a
     * concurrency issue like sequencer check failures, transaction aborts,
     * etc.
     *
     * See litmus test above for deciding between FailedPrecondition,
     * Aborted, and Unavailable.
     */
    Aborted = "aborted",

    /**
     * OutOfRange means operation was attempted past the valid range.
     * E.g., seeking or reading past end of file.
     *
     * Unlike InvalidArgument, this error indicates a problem that may
     * be fixed if the system state changes. For example, a 32-bit file
     * system will generate InvalidArgument if asked to read at an
     * offset that is not in the range [0,2^32-1], but it will generate
     * OutOfRange if asked to read from an offset past the current
     * file size.
     *
     * There is a fair bit of overlap between FailedPrecondition and
     * OutOfRange. We recommend using OutOfRange (the more specific
     * error) when it applies so that callers who are iterating through
     * a space can easily look for an OutOfRange error to detect when
     * they are done.
     *
     * This error code will not be generated by the gRPC framework.
     */
    OutOfRange = "out_of_range",

    /**
     * Unimplemented indicates operation is not implemented or not
     * supported/enabled in this service.
     *
     * This error code will be generated by the gRPC framework. Most
     * commonly, you will see this error code when a method implementation
     * is missing on the server. It can also be generated for unknown
     * compression algorithms or a disagreement as to whether an RPC should
     * be streaming.
     */
    Unimplemented = "unimplemented",

    /**
     * Internal errors. Means some invariants expected by underlying
     * system has been broken. If you see one of these errors,
     * something is very broken.
     *
     * This error code will be generated by the gRPC framework in several
     * internal error conditions.
     */
    Internal = "internal",

    /**
     * Unavailable indicates the service is currently unavailable.
     * This is a most likely a transient condition and may be corrected
     * by retrying with a backoff. Note that it is not always safe to retry
     * non-idempotent operations.
     *
     * See litmus test above for deciding between FailedPrecondition,
     * Aborted, and Unavailable.
     *
     * This error code will be generated by the gRPC framework during
     * abrupt shutdown of a server process or network connection.
     */
    Unavailable = "unavailable",

    /**
     * DataLoss indicates unrecoverable data loss or corruption.
     *
     * This error code will not be generated by the gRPC framework.
     */
    DataLoss = "data_loss",

    /**
     * Unauthenticated indicates the request does not have valid
     * authentication credentials for the operation.
     *
     * The gRPC framework will generate this error code when the
     * authentication metadata is invalid or a Credentials callback fails,
     * but also expect authentication middleware to generate it.
     */
    Unauthenticated = "unauthenticated",
}
